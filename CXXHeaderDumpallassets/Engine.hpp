#ifndef UE4SS_SDK_Engine_HPP
#define UE4SS_SDK_Engine_HPP

#include "Engine_enums.hpp"

struct FTickFunction
{
    TEnumAsByte<ETickingGroup> TickGroup;                                             // 0x0008 (size: 0x1)
    TEnumAsByte<ETickingGroup> EndTickGroup;                                          // 0x0009 (size: 0x1)
    uint8 bTickEvenWhenPaused;                                                        // 0x000A (size: 0x1)
    uint8 bCanEverTick;                                                               // 0x000A (size: 0x1)
    uint8 bStartWithTickEnabled;                                                      // 0x000A (size: 0x1)
    uint8 bAllowTickOnDedicatedServer;                                                // 0x000A (size: 0x1)
    float TickInterval;                                                               // 0x000C (size: 0x4)

}; // Size: 0x28

struct FActorTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FRepMovement
{
    FVector LinearVelocity;                                                           // 0x0000 (size: 0xC)
    FVector AngularVelocity;                                                          // 0x000C (size: 0xC)
    FVector Location;                                                                 // 0x0018 (size: 0xC)
    FRotator Rotation;                                                                // 0x0024 (size: 0xC)
    uint8 bSimulatedPhysicSleep;                                                      // 0x0030 (size: 0x1)
    uint8 bRepPhysics;                                                                // 0x0030 (size: 0x1)
    EVectorQuantization LocationQuantizationLevel;                                    // 0x0031 (size: 0x1)
    EVectorQuantization VelocityQuantizationLevel;                                    // 0x0032 (size: 0x1)
    ERotatorQuantization RotationQuantizationLevel;                                   // 0x0033 (size: 0x1)

}; // Size: 0x34

struct FVector_NetQuantize100 : public FVector
{
}; // Size: 0xC

struct FRepAttachment
{
    class AActor* AttachParent;                                                       // 0x0000 (size: 0x8)
    FVector_NetQuantize100 LocationOffset;                                            // 0x0008 (size: 0xC)
    FVector_NetQuantize100 RelativeScale3D;                                           // 0x0014 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x0020 (size: 0xC)
    FName AttachSocket;                                                               // 0x002C (size: 0x8)
    class USceneComponent* AttachComponent;                                           // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FVector_NetQuantize : public FVector
{
}; // Size: 0xC

struct FVector_NetQuantizeNormal : public FVector
{
}; // Size: 0xC

struct FHitResult
{
    int32 FaceIndex;                                                                  // 0x0000 (size: 0x4)
    float Time;                                                                       // 0x0004 (size: 0x4)
    float Distance;                                                                   // 0x0008 (size: 0x4)
    FVector_NetQuantize Location;                                                     // 0x000C (size: 0xC)
    FVector_NetQuantize ImpactPoint;                                                  // 0x0018 (size: 0xC)
    FVector_NetQuantizeNormal Normal;                                                 // 0x0024 (size: 0xC)
    FVector_NetQuantizeNormal ImpactNormal;                                           // 0x0030 (size: 0xC)
    FVector_NetQuantize TraceStart;                                                   // 0x003C (size: 0xC)
    FVector_NetQuantize TraceEnd;                                                     // 0x0048 (size: 0xC)
    float PenetrationDepth;                                                           // 0x0054 (size: 0x4)
    int32 Item;                                                                       // 0x0058 (size: 0x4)
    uint8 ElementIndex;                                                               // 0x005C (size: 0x1)
    uint8 bBlockingHit;                                                               // 0x005D (size: 0x1)
    uint8 bStartPenetrating;                                                          // 0x005D (size: 0x1)
    TWeakObjectPtr<class UPhysicalMaterial> PhysMaterial;                             // 0x0060 (size: 0x8)
    TWeakObjectPtr<class AActor> Actor;                                               // 0x0068 (size: 0x8)
    TWeakObjectPtr<class UPrimitiveComponent> Component;                              // 0x0070 (size: 0x8)
    FName BoneName;                                                                   // 0x0078 (size: 0x8)
    FName MyBoneName;                                                                 // 0x0080 (size: 0x8)

}; // Size: 0x88

class AActor : public UObject
{
    FActorTickFunction PrimaryActorTick;                                              // 0x0030 (size: 0x30)
    uint8 bNetTemporary;                                                              // 0x0060 (size: 0x1)
    uint8 bNetStartup;                                                                // 0x0060 (size: 0x1)
    uint8 bOnlyRelevantToOwner;                                                       // 0x0060 (size: 0x1)
    uint8 bAlwaysRelevant;                                                            // 0x0060 (size: 0x1)
    uint8 bReplicateMovement;                                                         // 0x0060 (size: 0x1)
    uint8 bHidden;                                                                    // 0x0060 (size: 0x1)
    uint8 bTearOff;                                                                   // 0x0060 (size: 0x1)
    uint8 bForceNetAddressable;                                                       // 0x0060 (size: 0x1)
    uint8 bExchangedRoles;                                                            // 0x0061 (size: 0x1)
    uint8 bNetLoadOnClient;                                                           // 0x0061 (size: 0x1)
    uint8 bNetUseOwnerRelevancy;                                                      // 0x0061 (size: 0x1)
    uint8 bRelevantForNetworkReplays;                                                 // 0x0061 (size: 0x1)
    uint8 bRelevantForLevelBounds;                                                    // 0x0061 (size: 0x1)
    uint8 bReplayRewindable;                                                          // 0x0061 (size: 0x1)
    uint8 bAllowTickBeforeBeginPlay;                                                  // 0x0061 (size: 0x1)
    uint8 bAutoDestroyWhenFinished;                                                   // 0x0061 (size: 0x1)
    uint8 bCanBeDamaged;                                                              // 0x0062 (size: 0x1)
    uint8 bBlockInput;                                                                // 0x0062 (size: 0x1)
    uint8 bCollideWhenPlacing;                                                        // 0x0062 (size: 0x1)
    uint8 bFindCameraComponentWhenViewTarget;                                         // 0x0062 (size: 0x1)
    uint8 bGenerateOverlapEventsDuringLevelStreaming;                                 // 0x0062 (size: 0x1)
    uint8 bIgnoresOriginShifting;                                                     // 0x0062 (size: 0x1)
    uint8 bEnableAutoLODGeneration;                                                   // 0x0062 (size: 0x1)
    uint8 bIsEditorOnlyActor;                                                         // 0x0062 (size: 0x1)
    uint8 bActorSeamlessTraveled;                                                     // 0x0063 (size: 0x1)
    uint8 bReplicates;                                                                // 0x0063 (size: 0x1)
    uint8 bCanBeInCluster;                                                            // 0x0063 (size: 0x1)
    uint8 bAllowReceiveTickEventOnDedicatedServer;                                    // 0x0063 (size: 0x1)
    uint8 bActorEnableCollision;                                                      // 0x0064 (size: 0x1)
    uint8 bActorIsBeingDestroyed;                                                     // 0x0064 (size: 0x1)
    EActorUpdateOverlapsMethod UpdateOverlapsMethodDuringLevelStreaming;              // 0x0065 (size: 0x1)
    EActorUpdateOverlapsMethod DefaultUpdateOverlapsMethodDuringLevelStreaming;       // 0x0066 (size: 0x1)
    TEnumAsByte<ENetRole> RemoteRole;                                                 // 0x0067 (size: 0x1)
    FRepMovement ReplicatedMovement;                                                  // 0x0068 (size: 0x34)
    float InitialLifeSpan;                                                            // 0x009C (size: 0x4)
    float CustomTimeDilation;                                                         // 0x00A0 (size: 0x4)
    FRepAttachment AttachmentReplication;                                             // 0x00A8 (size: 0x40)
    class AActor* Owner;                                                              // 0x00E8 (size: 0x8)
    FName NetDriverName;                                                              // 0x00F0 (size: 0x8)
    TEnumAsByte<ENetRole> Role;                                                       // 0x00F8 (size: 0x1)
    TEnumAsByte<ENetDormancy> NetDormancy;                                            // 0x00F9 (size: 0x1)
    ESpawnActorCollisionHandlingMethod SpawnCollisionHandlingMethod;                  // 0x00FA (size: 0x1)
    TEnumAsByte<EAutoReceiveInput::Type> AutoReceiveInput;                            // 0x00FB (size: 0x1)
    int32 InputPriority;                                                              // 0x00FC (size: 0x4)
    class UInputComponent* InputComponent;                                            // 0x0100 (size: 0x8)
    float NetCullDistanceSquared;                                                     // 0x0108 (size: 0x4)
    int32 NetTag;                                                                     // 0x010C (size: 0x4)
    float NetUpdateFrequency;                                                         // 0x0110 (size: 0x4)
    float MinNetUpdateFrequency;                                                      // 0x0114 (size: 0x4)
    float NetPriority;                                                                // 0x0118 (size: 0x4)
    class APawn* Instigator;                                                          // 0x0120 (size: 0x8)
    TArray<class AActor*> Children;                                                   // 0x0128 (size: 0x10)
    class USceneComponent* RootComponent;                                             // 0x0138 (size: 0x8)
    TArray<class AMatineeActor*> ControllingMatineeActors;                            // 0x0140 (size: 0x10)
    TArray<FName> Layers;                                                             // 0x0158 (size: 0x10)
    TWeakObjectPtr<class UChildActorComponent> ParentComponent;                       // 0x0168 (size: 0x8)
    TArray<FName> Tags;                                                               // 0x0178 (size: 0x10)
    FActorOnTakeAnyDamage OnTakeAnyDamage;                                            // 0x0188 (size: 0x1)
    void TakeAnyDamageSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
    FActorOnTakePointDamage OnTakePointDamage;                                        // 0x0189 (size: 0x1)
    void TakePointDamageSignature(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, FVector HitLocation, class UPrimitiveComponent* FHitComponent, FName BoneName, FVector ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
    FActorOnTakeRadialDamage OnTakeRadialDamage;                                      // 0x018A (size: 0x1)
    void TakeRadialDamageSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, FVector Origin, FHitResult HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
    FActorOnActorBeginOverlap OnActorBeginOverlap;                                    // 0x018B (size: 0x1)
    void ActorBeginOverlapSignature(class AActor* OverlappedActor, class AActor* OtherActor);
    FActorOnActorEndOverlap OnActorEndOverlap;                                        // 0x018C (size: 0x1)
    void ActorEndOverlapSignature(class AActor* OverlappedActor, class AActor* OtherActor);
    FActorOnBeginCursorOver OnBeginCursorOver;                                        // 0x018D (size: 0x1)
    void ActorBeginCursorOverSignature(class AActor* TouchedActor);
    FActorOnEndCursorOver OnEndCursorOver;                                            // 0x018E (size: 0x1)
    void ActorEndCursorOverSignature(class AActor* TouchedActor);
    FActorOnClicked OnClicked;                                                        // 0x018F (size: 0x1)
    void ActorOnClickedSignature(class AActor* TouchedActor, FKey ButtonPressed);
    FActorOnReleased OnReleased;                                                      // 0x0190 (size: 0x1)
    void ActorOnReleasedSignature(class AActor* TouchedActor, FKey ButtonReleased);
    FActorOnInputTouchBegin OnInputTouchBegin;                                        // 0x0191 (size: 0x1)
    void ActorOnInputTouchBeginSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchEnd OnInputTouchEnd;                                            // 0x0192 (size: 0x1)
    void ActorOnInputTouchEndSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchEnter OnInputTouchEnter;                                        // 0x0193 (size: 0x1)
    void ActorBeginTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchLeave OnInputTouchLeave;                                        // 0x0194 (size: 0x1)
    void ActorEndTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnActorHit OnActorHit;                                                      // 0x0195 (size: 0x1)
    void ActorHitSignature(class AActor* SelfActor, class AActor* OtherActor, FVector NormalImpulse, const FHitResult& Hit);
    FActorOnDestroyed OnDestroyed;                                                    // 0x0196 (size: 0x1)
    void ActorDestroyedSignature(class AActor* DestroyedActor);
    FActorOnEndPlay OnEndPlay;                                                        // 0x0197 (size: 0x1)
    void ActorEndPlaySignature(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    TArray<class UActorComponent*> InstanceComponents;                                // 0x01F8 (size: 0x10)
    TArray<class UActorComponent*> BlueprintCreatedComponents;                        // 0x0208 (size: 0x10)

    bool WasRecentlyRendered(float Tolerance);
    void UserConstructionScript();
    void TearOff();
    void SnapRootComponentTo(class AActor* InParentActor, FName InSocketName);
    void SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void SetReplicates(bool bInReplicates);
    void SetReplicateMovement(bool bInReplicateMovement);
    void SetOwner(class AActor* NewOwner);
    void SetNetDormancy(TEnumAsByte<ENetDormancy> NewDormancy);
    void SetLifeSpan(float InLifespan);
    void SetAutoDestroyWhenFinished(bool bVal);
    void SetActorTickInterval(float TickInterval);
    void SetActorTickEnabled(bool bEnabled);
    void SetActorScale3D(FVector NewScale3D);
    void SetActorRelativeScale3D(FVector NewRelativeScale);
    void SetActorHiddenInGame(bool bNewHidden);
    void SetActorEnableCollision(bool bNewActorEnableCollision);
    void RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void ReceiveTick(float DeltaSeconds);
    void ReceiveRadialDamage(float DamageReceived, const class UDamageType* DamageType, FVector Origin, const FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
    void ReceivePointDamage(float Damage, const class UDamageType* DamageType, FVector HitLocation, FVector HitNormal, class UPrimitiveComponent* HitComponent, FName BoneName, FVector ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, const FHitResult& HitInfo);
    void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit);
    void ReceiveEndPlay(TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void ReceiveDestroyed();
    void ReceiveBeginPlay();
    void ReceiveAnyDamage(float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
    void ReceiveActorOnReleased(FKey ButtonReleased);
    void ReceiveActorOnInputTouchLeave(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchEnter(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchEnd(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchBegin(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnClicked(FKey ButtonPressed);
    void ReceiveActorEndOverlap(class AActor* OtherActor);
    void ReceiveActorEndCursorOver();
    void ReceiveActorBeginOverlap(class AActor* OtherActor);
    void ReceiveActorBeginCursorOver();
    void PrestreamTextures(float Seconds, bool bEnableStreaming, int32 CinematicTextureGroups);
    void OnRep_ReplicateMovement();
    void OnRep_ReplicatedMovement();
    void OnRep_Owner();
    void OnRep_Instigator();
    void OnRep_AttachmentReplication();
    void MakeNoise(float Loudness, class APawn* NoiseInstigator, FVector NoiseLocation, float MaxRange, FName Tag);
    class UMaterialInstanceDynamic* MakeMIDForMaterial(class UMaterialInterface* Parent);
    bool K2_TeleportTo(FVector DestLocation, FRotator DestRotation);
    bool K2_SetActorTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorRotation(FRotator NewRotation, bool bTeleportPhysics);
    void K2_SetActorRelativeTransform(const FTransform& NewRelativeTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeRotation(FRotator NewRelativeRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeLocation(FVector NewRelativeLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_OnReset();
    void K2_OnEndViewTarget(class APlayerController* PC);
    void K2_OnBecomeViewTarget(class APlayerController* PC);
    class USceneComponent* K2_GetRootComponent();
    TArray<class UActorComponent*> K2_GetComponentsByClass(TSubclassOf<class UActorComponent> ComponentClass);
    FRotator K2_GetActorRotation();
    FVector K2_GetActorLocation();
    void K2_DetachFromActor(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
    void K2_DestroyComponent(class UActorComponent* Component);
    void K2_DestroyActor();
    void K2_AttachToComponent(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_AttachToActor(class AActor* ParentActor, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_AttachRootComponentToActor(class AActor* InParentActor, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AttachRootComponentTo(class USceneComponent* InParent, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AddActorWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool IsOverlappingActor(const class AActor* Other);
    bool IsChildActor();
    bool IsActorTickEnabled();
    bool IsActorBeingDestroyed();
    bool HasAuthority();
    float GetVerticalDistanceTo(const class AActor* OtherActor);
    FVector GetVelocity();
    FTransform GetTransform();
    bool GetTickableWhenPaused();
    float GetSquaredHorizontalDistanceTo(const class AActor* OtherActor);
    float GetSquaredDistanceTo(const class AActor* OtherActor);
    TEnumAsByte<ENetRole> GetRemoteRole();
    class UChildActorComponent* GetParentComponent();
    class AActor* GetParentActor();
    class AActor* GetOwner();
    void GetOverlappingComponents(TArray<class UPrimitiveComponent*>& OverlappingComponents);
    void GetOverlappingActors(TArray<class AActor*>& OverlappingActors, TSubclassOf<class AActor> ClassFilter);
    TEnumAsByte<ENetRole> GetLocalRole();
    float GetLifeSpan();
    class AController* GetInstigatorController();
    class APawn* GetInstigator();
    FVector GetInputVectorAxisValue(const FKey InputAxisKey);
    float GetInputAxisValue(const FName InputAxisName);
    float GetInputAxisKeyValue(const FKey InputAxisKey);
    float GetHorizontalDotProductTo(const class AActor* OtherActor);
    float GetHorizontalDistanceTo(const class AActor* OtherActor);
    float GetGameTimeSinceCreation();
    float GetDotProductTo(const class AActor* OtherActor);
    float GetDistanceTo(const class AActor* OtherActor);
    TArray<class UActorComponent*> GetComponentsByTag(TSubclassOf<class UActorComponent> ComponentClass, FName Tag);
    TArray<class UActorComponent*> GetComponentsByInterface(TSubclassOf<class UInterface> Interface);
    class UActorComponent* GetComponentByClass(TSubclassOf<class UActorComponent> ComponentClass);
    FName GetAttachParentSocketName();
    class AActor* GetAttachParentActor();
    void GetAttachedActors(TArray<class AActor*>& OutActors, bool bResetArray);
    void GetAllChildActors(TArray<class AActor*>& ChildActors, bool bIncludeDescendants);
    FVector GetActorUpVector();
    float GetActorTimeDilation();
    float GetActorTickInterval();
    FVector GetActorScale3D();
    FVector GetActorRightVector();
    FVector GetActorRelativeScale3D();
    FVector GetActorForwardVector();
    void GetActorEyesViewPoint(FVector& OutLocation, FRotator& OutRotation);
    bool GetActorEnableCollision();
    void GetActorBounds(bool bOnlyCollidingComponents, FVector& Origin, FVector& BoxExtent, bool bIncludeFromChildActors);
    void ForceNetUpdate();
    void FlushNetDormancy();
    void FinishAddComponent(class UActorComponent* Component, bool bManualAttachment, const FTransform& RelativeTransform);
    void EnableInput(class APlayerController* PlayerController);
    void DisableInput(class APlayerController* PlayerController);
    void DetachRootComponentFromParent(bool bMaintainWorldPosition);
    void AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void AddTickPrerequisiteActor(class AActor* PrerequisiteActor);
    class UActorComponent* AddComponentByClass(TSubclassOf<class UActorComponent> Class, bool bManualAttachment, const FTransform& RelativeTransform, bool bDeferredFinish);
    class UActorComponent* AddComponent(FName TemplateName, bool bManualAttachment, const FTransform& RelativeTransform, const class UObject* ComponentTemplateContext, bool bDeferredFinish);
    bool ActorHasTag(FName Tag);
}; // Size: 0x228

struct FActorComponentTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FSimpleMemberReference
{
    class UObject* MemberParent;                                                      // 0x0000 (size: 0x8)
    FName MemberName;                                                                 // 0x0008 (size: 0x8)
    FGuid MemberGuid;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

class UActorComponent : public UObject
{
    FActorComponentTickFunction PrimaryComponentTick;                                 // 0x0030 (size: 0x30)
    TArray<FName> ComponentTags;                                                      // 0x0060 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0070 (size: 0x10)
    int32 UCSSerializationIndex;                                                      // 0x0084 (size: 0x4)
    uint8 bNetAddressable;                                                            // 0x0088 (size: 0x1)
    uint8 bReplicates;                                                                // 0x0088 (size: 0x1)
    uint8 bAutoActivate;                                                              // 0x0089 (size: 0x1)
    uint8 bIsActive;                                                                  // 0x008A (size: 0x1)
    uint8 bEditableWhenInherited;                                                     // 0x008A (size: 0x1)
    uint8 bCanEverAffectNavigation;                                                   // 0x008A (size: 0x1)
    uint8 bIsEditorOnly;                                                              // 0x008A (size: 0x1)
    EComponentCreationMethod CreationMethod;                                          // 0x008C (size: 0x1)
    FActorComponentOnComponentActivated OnComponentActivated;                         // 0x008D (size: 0x1)
    void ActorComponentActivatedSignature(class UActorComponent* Component, bool bReset);
    FActorComponentOnComponentDeactivated OnComponentDeactivated;                     // 0x008E (size: 0x1)
    void ActorComponentDeactivateSignature(class UActorComponent* Component);
    TArray<FSimpleMemberReference> UCSModifiedProperties;                             // 0x0090 (size: 0x10)

    void ToggleActive();
    void SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void SetIsReplicated(bool ShouldReplicate);
    void SetComponentTickIntervalAndCooldown(float TickInterval);
    void SetComponentTickInterval(float TickInterval);
    void SetComponentTickEnabled(bool bEnabled);
    void SetAutoActivate(bool bNewAutoActivate);
    void SetActive(bool bNewActive, bool bReset);
    void RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void ReceiveTick(float DeltaSeconds);
    void ReceiveEndPlay(TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void ReceiveBeginPlay();
    void OnRep_IsActive();
    void K2_DestroyComponent(class UObject* Object);
    bool IsComponentTickEnabled();
    bool IsBeingDestroyed();
    bool IsActive();
    class AActor* GetOwner();
    float GetComponentTickInterval();
    void Deactivate();
    bool ComponentHasTag(FName Tag);
    void AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void AddTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void Activate(bool bReset);
}; // Size: 0xB0

class USceneComponent : public UActorComponent
{
    TWeakObjectPtr<class APhysicsVolume> PhysicsVolume;                               // 0x00B8 (size: 0x8)
    class USceneComponent* AttachParent;                                              // 0x00C0 (size: 0x8)
    FName AttachSocketName;                                                           // 0x00C8 (size: 0x8)
    TArray<class USceneComponent*> AttachChildren;                                    // 0x00D0 (size: 0x10)
    TArray<class USceneComponent*> ClientAttachedChildren;                            // 0x00E0 (size: 0x10)
    FVector RelativeLocation;                                                         // 0x011C (size: 0xC)
    FRotator RelativeRotation;                                                        // 0x0128 (size: 0xC)
    FVector RelativeScale3D;                                                          // 0x0134 (size: 0xC)
    FVector ComponentVelocity;                                                        // 0x0140 (size: 0xC)
    uint8 bComponentToWorldUpdated;                                                   // 0x014C (size: 0x1)
    uint8 bAbsoluteLocation;                                                          // 0x014C (size: 0x1)
    uint8 bAbsoluteRotation;                                                          // 0x014C (size: 0x1)
    uint8 bAbsoluteScale;                                                             // 0x014C (size: 0x1)
    uint8 bVisible;                                                                   // 0x014C (size: 0x1)
    uint8 bShouldBeAttached;                                                          // 0x014C (size: 0x1)
    uint8 bShouldSnapLocationWhenAttached;                                            // 0x014C (size: 0x1)
    uint8 bShouldSnapRotationWhenAttached;                                            // 0x014D (size: 0x1)
    uint8 bShouldUpdatePhysicsVolume;                                                 // 0x014D (size: 0x1)
    uint8 bHiddenInGame;                                                              // 0x014D (size: 0x1)
    uint8 bBoundsChangeTriggersStreamingDataRebuild;                                  // 0x014D (size: 0x1)
    uint8 bUseAttachParentBound;                                                      // 0x014D (size: 0x1)
    TEnumAsByte<EComponentMobility::Type> Mobility;                                   // 0x014F (size: 0x1)
    TEnumAsByte<EDetailMode> DetailMode;                                              // 0x0150 (size: 0x1)
    FSceneComponentPhysicsVolumeChangedDelegate PhysicsVolumeChangedDelegate;         // 0x0151 (size: 0x1)
    void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);

    void ToggleVisibility(bool bPropagateToChildren);
    bool SnapTo(class USceneComponent* InParent, FName InSocketName);
    void SetWorldScale3D(FVector NewScale);
    void SetVisibility(bool bNewVisibility, bool bPropagateToChildren);
    void SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume);
    void SetRelativeScale3D(FVector NewScale3D);
    void SetMobility(TEnumAsByte<EComponentMobility::Type> NewMobility);
    void SetHiddenInGame(bool NewHidden, bool bPropagateToChildren);
    void SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale);
    void ResetRelativeTransform();
    void OnRep_Visibility(bool OldValue);
    void OnRep_Transform();
    void OnRep_AttachSocketName();
    void OnRep_AttachParent();
    void OnRep_AttachChildren();
    void K2_SetWorldTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    FTransform K2_GetComponentToWorld();
    FVector K2_GetComponentScale();
    FRotator K2_GetComponentRotation();
    FVector K2_GetComponentLocation();
    void K2_DetachFromComponent(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule, bool bCallModify);
    bool K2_AttachToComponent(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    bool K2_AttachTo(class USceneComponent* InParent, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachType, bool bWeldSimulatedBodies);
    void K2_AddWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeLocation(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool IsVisible();
    bool IsSimulatingPhysics(FName BoneName);
    bool IsAnySimulatingPhysics();
    FVector GetUpVector();
    FTransform GetSocketTransform(FName InSocketName, TEnumAsByte<ERelativeTransformSpace> TransformSpace);
    FRotator GetSocketRotation(FName InSocketName);
    FQuat GetSocketQuaternion(FName InSocketName);
    FVector GetSocketLocation(FName InSocketName);
    bool GetShouldUpdatePhysicsVolume();
    FVector GetRightVector();
    FTransform GetRelativeTransform();
    class APhysicsVolume* GetPhysicsVolume();
    void GetParentComponents(TArray<class USceneComponent*>& Parents);
    int32 GetNumChildrenComponents();
    FVector GetForwardVector();
    FVector GetComponentVelocity();
    void GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>& Children);
    class USceneComponent* GetChildComponent(int32 ChildIndex);
    FName GetAttachSocketName();
    class USceneComponent* GetAttachParent();
    TArray<FName> GetAllSocketNames();
    bool DoesSocketExist(FName InSocketName);
    void DetachFromParent(bool bMaintainWorldPosition, bool bCallModify);
}; // Size: 0x200

struct FLightingChannels
{
    uint8 bChannel0;                                                                  // 0x0000 (size: 0x1)
    uint8 bChannel1;                                                                  // 0x0000 (size: 0x1)
    uint8 bChannel2;                                                                  // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FCustomPrimitiveData
{
    TArray<float> Data;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCollisionResponseContainer
{
    TEnumAsByte<ECollisionResponse> WorldStatic;                                      // 0x0000 (size: 0x1)
    TEnumAsByte<ECollisionResponse> WorldDynamic;                                     // 0x0001 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Pawn;                                             // 0x0002 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Visibility;                                       // 0x0003 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Camera;                                           // 0x0004 (size: 0x1)
    TEnumAsByte<ECollisionResponse> PhysicsBody;                                      // 0x0005 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Vehicle;                                          // 0x0006 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Destructible;                                     // 0x0007 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel1;                              // 0x0008 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel2;                              // 0x0009 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel3;                              // 0x000A (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel4;                              // 0x000B (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel5;                              // 0x000C (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel6;                              // 0x000D (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel1;                                // 0x000E (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel2;                                // 0x000F (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel3;                                // 0x0010 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel4;                                // 0x0011 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel5;                                // 0x0012 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel6;                                // 0x0013 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel7;                                // 0x0014 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel8;                                // 0x0015 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel9;                                // 0x0016 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel10;                               // 0x0017 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel11;                               // 0x0018 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel12;                               // 0x0019 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel13;                               // 0x001A (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel14;                               // 0x001B (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel15;                               // 0x001C (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel16;                               // 0x001D (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel17;                               // 0x001E (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel18;                               // 0x001F (size: 0x1)

}; // Size: 0x20

struct FResponseChannel
{
    FName Channel;                                                                    // 0x0000 (size: 0x8)
    TEnumAsByte<ECollisionResponse> Response;                                         // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FCollisionResponse
{
    FCollisionResponseContainer ResponseToChannels;                                   // 0x0000 (size: 0x20)
    TArray<FResponseChannel> ResponseArray;                                           // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FWalkableSlopeOverride
{
    TEnumAsByte<EWalkableSlopeBehavior> WalkableSlopeBehavior;                        // 0x0000 (size: 0x1)
    float WalkableSlopeAngle;                                                         // 0x0004 (size: 0x4)

}; // Size: 0x10

struct FBodyInstance : public FBodyInstanceCore
{
    TEnumAsByte<ECollisionChannel> ObjectType;                                        // 0x001E (size: 0x1)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0020 (size: 0x1)
    ESleepFamily SleepFamily;                                                         // 0x0059 (size: 0x1)
    TEnumAsByte<EDOFMode::Type> DOFMode;                                              // 0x005A (size: 0x1)
    uint8 bUseCCD;                                                                    // 0x005B (size: 0x1)
    uint8 bIgnoreAnalyticCollisions;                                                  // 0x005B (size: 0x1)
    uint8 bNotifyRigidBodyCollision;                                                  // 0x005B (size: 0x1)
    uint8 bLockTranslation;                                                           // 0x005B (size: 0x1)
    uint8 bLockRotation;                                                              // 0x005B (size: 0x1)
    uint8 bLockXTranslation;                                                          // 0x005B (size: 0x1)
    uint8 bLockYTranslation;                                                          // 0x005B (size: 0x1)
    uint8 bLockZTranslation;                                                          // 0x005C (size: 0x1)
    uint8 bLockXRotation;                                                             // 0x005C (size: 0x1)
    uint8 bLockYRotation;                                                             // 0x005C (size: 0x1)
    uint8 bLockZRotation;                                                             // 0x005C (size: 0x1)
    uint8 bOverrideMaxAngularVelocity;                                                // 0x005C (size: 0x1)
    uint8 bOverrideMaxDepenetrationVelocity;                                          // 0x005C (size: 0x1)
    uint8 bOverrideWalkableSlopeOnInstance;                                           // 0x005D (size: 0x1)
    uint8 bInterpolateWhenSubStepping;                                                // 0x005D (size: 0x1)
    FName CollisionProfileName;                                                       // 0x006C (size: 0x8)
    uint8 PositionSolverIterationCount;                                               // 0x0074 (size: 0x1)
    uint8 VelocitySolverIterationCount;                                               // 0x0075 (size: 0x1)
    FCollisionResponse CollisionResponses;                                            // 0x0078 (size: 0x30)
    float MaxDepenetrationVelocity;                                                   // 0x00A8 (size: 0x4)
    float MassInKgOverride;                                                           // 0x00AC (size: 0x4)
    float LinearDamping;                                                              // 0x00B8 (size: 0x4)
    float AngularDamping;                                                             // 0x00BC (size: 0x4)
    FVector CustomDOFPlaneNormal;                                                     // 0x00C0 (size: 0xC)
    FVector COMNudge;                                                                 // 0x00CC (size: 0xC)
    float MassScale;                                                                  // 0x00D8 (size: 0x4)
    FVector InertiaTensorScale;                                                       // 0x00DC (size: 0xC)
    FWalkableSlopeOverride WalkableSlopeOverride;                                     // 0x00F8 (size: 0x10)
    class UPhysicalMaterial* PhysMaterialOverride;                                    // 0x0108 (size: 0x8)
    float MaxAngularVelocity;                                                         // 0x0110 (size: 0x4)
    float CustomSleepThresholdMultiplier;                                             // 0x0114 (size: 0x4)
    float StabilizationThresholdMultiplier;                                           // 0x0118 (size: 0x4)
    float PhysicsBlendWeight;                                                         // 0x011C (size: 0x4)

}; // Size: 0x158

class UPrimitiveComponent : public USceneComponent
{
    float MinDrawDistance;                                                            // 0x0200 (size: 0x4)
    float LDMaxDrawDistance;                                                          // 0x0204 (size: 0x4)
    float CachedMaxDrawDistance;                                                      // 0x0208 (size: 0x4)
    TEnumAsByte<ESceneDepthPriorityGroup> DepthPriorityGroup;                         // 0x020C (size: 0x1)
    TEnumAsByte<ESceneDepthPriorityGroup> ViewOwnerDepthPriorityGroup;                // 0x020D (size: 0x1)
    TEnumAsByte<EIndirectLightingCacheQuality> IndirectLightingCacheQuality;          // 0x020E (size: 0x1)
    ELightmapType LightmapType;                                                       // 0x020F (size: 0x1)
    uint8 bUseMaxLODAsImposter;                                                       // 0x0210 (size: 0x1)
    uint8 bBatchImpostersAsInstances;                                                 // 0x0210 (size: 0x1)
    uint8 bNeverDistanceCull;                                                         // 0x0210 (size: 0x1)
    uint8 bAlwaysCreatePhysicsState;                                                  // 0x0210 (size: 0x1)
    uint8 bGenerateOverlapEvents;                                                     // 0x0211 (size: 0x1)
    uint8 bMultiBodyOverlap;                                                          // 0x0211 (size: 0x1)
    uint8 bTraceComplexOnMove;                                                        // 0x0211 (size: 0x1)
    uint8 bReturnMaterialOnMove;                                                      // 0x0211 (size: 0x1)
    uint8 bUseViewOwnerDepthPriorityGroup;                                            // 0x0211 (size: 0x1)
    uint8 bAllowCullDistanceVolume;                                                   // 0x0211 (size: 0x1)
    uint8 bHasMotionBlurVelocityMeshes;                                               // 0x0211 (size: 0x1)
    uint8 bVisibleInReflectionCaptures;                                               // 0x0211 (size: 0x1)
    uint8 bVisibleInRealTimeSkyCaptures;                                              // 0x0212 (size: 0x1)
    uint8 bVisibleInRayTracing;                                                       // 0x0212 (size: 0x1)
    uint8 bRenderInMainPass;                                                          // 0x0212 (size: 0x1)
    uint8 bRenderInDepthPass;                                                         // 0x0212 (size: 0x1)
    uint8 bReceivesDecals;                                                            // 0x0212 (size: 0x1)
    uint8 bOwnerNoSee;                                                                // 0x0212 (size: 0x1)
    uint8 bOnlyOwnerSee;                                                              // 0x0212 (size: 0x1)
    uint8 bTreatAsBackgroundForOcclusion;                                             // 0x0212 (size: 0x1)
    uint8 bUseAsOccluder;                                                             // 0x0213 (size: 0x1)
    uint8 bSelectable;                                                                // 0x0213 (size: 0x1)
    uint8 bForceMipStreaming;                                                         // 0x0213 (size: 0x1)
    uint8 bHasPerInstanceHitProxies;                                                  // 0x0213 (size: 0x1)
    uint8 CastShadow;                                                                 // 0x0213 (size: 0x1)
    uint8 bAffectDynamicIndirectLighting;                                             // 0x0213 (size: 0x1)
    uint8 bAffectDistanceFieldLighting;                                               // 0x0213 (size: 0x1)
    uint8 bCastDynamicShadow;                                                         // 0x0213 (size: 0x1)
    uint8 bCastStaticShadow;                                                          // 0x0214 (size: 0x1)
    uint8 bCastVolumetricTranslucentShadow;                                           // 0x0214 (size: 0x1)
    uint8 bCastContactShadow;                                                         // 0x0214 (size: 0x1)
    uint8 bSelfShadowOnly;                                                            // 0x0214 (size: 0x1)
    uint8 bCastFarShadow;                                                             // 0x0214 (size: 0x1)
    uint8 bCastInsetShadow;                                                           // 0x0214 (size: 0x1)
    uint8 bCastCinematicShadow;                                                       // 0x0214 (size: 0x1)
    uint8 bCastHiddenShadow;                                                          // 0x0214 (size: 0x1)
    uint8 bCastShadowAsTwoSided;                                                      // 0x0215 (size: 0x1)
    uint8 bLightAsIfStatic;                                                           // 0x0215 (size: 0x1)
    uint8 bLightAttachmentsAsGroup;                                                   // 0x0215 (size: 0x1)
    uint8 bExcludeFromLightAttachmentGroup;                                           // 0x0215 (size: 0x1)
    uint8 bReceiveMobileCSMShadows;                                                   // 0x0215 (size: 0x1)
    uint8 bSingleSampleShadowFromStationaryLights;                                    // 0x0215 (size: 0x1)
    uint8 bIgnoreRadialImpulse;                                                       // 0x0215 (size: 0x1)
    uint8 bIgnoreRadialForce;                                                         // 0x0215 (size: 0x1)
    uint8 bApplyImpulseOnDamage;                                                      // 0x0216 (size: 0x1)
    uint8 bReplicatePhysicsToAutonomousProxy;                                         // 0x0216 (size: 0x1)
    uint8 bFillCollisionUnderneathForNavmesh;                                         // 0x0216 (size: 0x1)
    uint8 AlwaysLoadOnClient;                                                         // 0x0216 (size: 0x1)
    uint8 AlwaysLoadOnServer;                                                         // 0x0216 (size: 0x1)
    uint8 bUseEditorCompositing;                                                      // 0x0216 (size: 0x1)
    uint8 bRenderCustomDepth;                                                         // 0x0216 (size: 0x1)
    uint8 bVisibleInSceneCaptureOnly;                                                 // 0x0216 (size: 0x1)
    uint8 bHiddenInSceneCapture;                                                      // 0x0217 (size: 0x1)
    TEnumAsByte<EHasCustomNavigableGeometry::Type> bHasCustomNavigableGeometry;       // 0x0218 (size: 0x1)
    TEnumAsByte<ECanBeCharacterBase> CanCharacterStepUpOn;                            // 0x021A (size: 0x1)
    FLightingChannels LightingChannels;                                               // 0x021B (size: 0x1)
    ERendererStencilMask CustomDepthStencilWriteMask;                                 // 0x021C (size: 0x1)
    int32 CustomDepthStencilValue;                                                    // 0x0220 (size: 0x4)
    FCustomPrimitiveData CustomPrimitiveData;                                         // 0x0228 (size: 0x10)
    FCustomPrimitiveData CustomPrimitiveDataInternal;                                 // 0x0238 (size: 0x10)
    int32 TranslucencySortPriority;                                                   // 0x0250 (size: 0x4)
    float TranslucencySortDistanceOffset;                                             // 0x0254 (size: 0x4)
    int32 VisibilityId;                                                               // 0x0258 (size: 0x4)
    TArray<class URuntimeVirtualTexture*> RuntimeVirtualTextures;                     // 0x0260 (size: 0x10)
    int8 VirtualTextureLodBias;                                                       // 0x0270 (size: 0x1)
    int8 VirtualTextureCullMips;                                                      // 0x0271 (size: 0x1)
    int8 VirtualTextureMinCoverage;                                                   // 0x0272 (size: 0x1)
    ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;                  // 0x0273 (size: 0x1)
    float LpvBiasMultiplier;                                                          // 0x0278 (size: 0x4)
    float BoundsScale;                                                                // 0x0284 (size: 0x4)
    TArray<class AActor*> MoveIgnoreActors;                                           // 0x0298 (size: 0x10)
    TArray<class UPrimitiveComponent*> MoveIgnoreComponents;                          // 0x02A8 (size: 0x10)
    FBodyInstance BodyInstance;                                                       // 0x02C8 (size: 0x158)
    FPrimitiveComponentOnComponentHit OnComponentHit;                                 // 0x0420 (size: 0x1)
    void ComponentHitSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit);
    FPrimitiveComponentOnComponentBeginOverlap OnComponentBeginOverlap;               // 0x0421 (size: 0x1)
    void ComponentBeginOverlapSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    FPrimitiveComponentOnComponentEndOverlap OnComponentEndOverlap;                   // 0x0422 (size: 0x1)
    void ComponentEndOverlapSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    FPrimitiveComponentOnComponentWake OnComponentWake;                               // 0x0423 (size: 0x1)
    void ComponentWakeSignature(class UPrimitiveComponent* WakingComponent, FName BoneName);
    FPrimitiveComponentOnComponentSleep OnComponentSleep;                             // 0x0424 (size: 0x1)
    void ComponentSleepSignature(class UPrimitiveComponent* SleepingComponent, FName BoneName);
    FPrimitiveComponentOnBeginCursorOver OnBeginCursorOver;                           // 0x0426 (size: 0x1)
    void ComponentBeginCursorOverSignature(class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnEndCursorOver OnEndCursorOver;                               // 0x0427 (size: 0x1)
    void ComponentEndCursorOverSignature(class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnClicked OnClicked;                                           // 0x0428 (size: 0x1)
    void ComponentOnClickedSignature(class UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);
    FPrimitiveComponentOnReleased OnReleased;                                         // 0x0429 (size: 0x1)
    void ComponentOnReleasedSignature(class UPrimitiveComponent* TouchedComponent, FKey ButtonReleased);
    FPrimitiveComponentOnInputTouchBegin OnInputTouchBegin;                           // 0x042A (size: 0x1)
    void ComponentOnInputTouchBeginSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchEnd OnInputTouchEnd;                               // 0x042B (size: 0x1)
    void ComponentOnInputTouchEndSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchEnter OnInputTouchEnter;                           // 0x042C (size: 0x1)
    void ComponentBeginTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchLeave OnInputTouchLeave;                           // 0x042D (size: 0x1)
    void ComponentEndTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    class UPrimitiveComponent* LODParentPrimitive;                                    // 0x0448 (size: 0x8)

    bool WasRecentlyRendered(float Tolerance);
    void WakeRigidBody(FName BoneName);
    void WakeAllRigidBodies();
    void SetWalkableSlopeOverride(const FWalkableSlopeOverride& NewOverride);
    void SetVisibleInSceneCaptureOnly(bool bValue);
    void SetUseCCD(bool InUseCCD, FName BoneName);
    void SetTranslucentSortPriority(int32 NewTranslucentSortPriority);
    void SetTranslucencySortDistanceOffset(float NewTranslucencySortDistanceOffset);
    void SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights);
    void SetSimulatePhysics(bool bSimulate);
    void SetRenderInMainPass(bool bValue);
    void SetRenderCustomDepth(bool bValue);
    void SetReceivesDecals(bool bNewReceivesDecals);
    void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
    void SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInRadians(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInDegrees(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocity(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetOwnerNoSee(bool bNewOwnerNoSee);
    void SetOnlyOwnerSee(bool bNewOnlyOwnerSee);
    void SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision);
    void SetMaterialByName(FName MaterialSlotName, class UMaterialInterface* Material);
    void SetMaterial(int32 ElementIndex, class UMaterialInterface* Material);
    void SetMassScale(FName BoneName, float InMassScale);
    void SetMassOverrideInKg(FName BoneName, float MassInKg, bool bOverrideMass);
    void SetLinearDamping(float InDamping);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup);
    void SetHiddenInSceneCapture(bool bValue);
    void SetGenerateOverlapEvents(bool bInGenerateOverlapEvents);
    void SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup);
    void SetEnableGravity(bool bGravityEnabled);
    void SetDefaultCustomPrimitiveDataVector4(int32 DataIndex, FVector4 Value);
    void SetDefaultCustomPrimitiveDataVector3(int32 DataIndex, FVector Value);
    void SetDefaultCustomPrimitiveDataVector2(int32 DataIndex, FVector2D Value);
    void SetDefaultCustomPrimitiveDataFloat(int32 DataIndex, float Value);
    void SetCustomPrimitiveDataVector4(int32 DataIndex, FVector4 Value);
    void SetCustomPrimitiveDataVector3(int32 DataIndex, FVector Value);
    void SetCustomPrimitiveDataVector2(int32 DataIndex, FVector2D Value);
    void SetCustomPrimitiveDataFloat(int32 DataIndex, float Value);
    void SetCustomDepthStencilWriteMask(ERendererStencilMask WriteMaskBit);
    void SetCustomDepthStencilValue(int32 Value);
    void SetCullDistance(float NewCullDistance);
    void SetConstraintMode(TEnumAsByte<EDOFMode::Type> ConstraintMode);
    void SetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel, TEnumAsByte<ECollisionResponse> NewResponse);
    void SetCollisionResponseToAllChannels(TEnumAsByte<ECollisionResponse> NewResponse);
    void SetCollisionProfileName(FName InCollisionProfileName, bool bUpdateOverlaps);
    void SetCollisionObjectType(TEnumAsByte<ECollisionChannel> Channel);
    void SetCollisionEnabled(TEnumAsByte<ECollisionEnabled::Type> NewType);
    void SetCenterOfMass(FVector CenterOfMassOffset, FName BoneName);
    void SetCastShadow(bool NewCastShadow);
    void SetCastInsetShadow(bool bInCastInsetShadow);
    void SetCastHiddenShadow(bool NewCastHiddenShadow);
    void SetBoundsScale(float NewBoundsScale);
    void SetAngularDamping(float InDamping);
    void SetAllUseCCD(bool InUseCCD);
    void SetAllPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent);
    void SetAllPhysicsAngularVelocityInRadians(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllPhysicsAngularVelocityInDegrees(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllMassScale(float InMassScale);
    FVector ScaleByMomentOfInertia(FVector InputVector, FName BoneName);
    void PutRigidBodyToSleep(FName BoneName);
    bool K2_SphereTraceComponent(FVector TraceStart, FVector TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_SphereOverlapComponent(FVector InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_LineTraceComponent(FVector TraceStart, FVector TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_IsQueryCollisionEnabled();
    bool K2_IsPhysicsCollisionEnabled();
    bool K2_IsCollisionEnabled();
    bool K2_BoxOverlapComponent(FVector InBoxCentre, const FBox InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool IsOverlappingComponent(const class UPrimitiveComponent* OtherComp);
    bool IsOverlappingActor(const class AActor* Other);
    bool IsGravityEnabled();
    bool IsAnyRigidBodyAwake();
    void IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore);
    void IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore);
    FWalkableSlopeOverride GetWalkableSlopeOverride();
    FVector GetPhysicsLinearVelocityAtPoint(FVector Point, FName BoneName);
    FVector GetPhysicsLinearVelocity(FName BoneName);
    FVector GetPhysicsAngularVelocityInRadians(FName BoneName);
    FVector GetPhysicsAngularVelocityInDegrees(FName BoneName);
    FVector GetPhysicsAngularVelocity(FName BoneName);
    void GetOverlappingComponents(TArray<class UPrimitiveComponent*>& OutOverlappingComponents);
    void GetOverlappingActors(TArray<class AActor*>& OverlappingActors, TSubclassOf<class AActor> ClassFilter);
    int32 GetNumMaterials();
    class UMaterialInterface* GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32& SectionIndex);
    class UMaterialInterface* GetMaterial(int32 ElementIndex);
    float GetMassScale(FName BoneName);
    float GetMass();
    float GetLinearDamping();
    FVector GetInertiaTensor(FName BoneName);
    bool GetGenerateOverlapEvents();
    TEnumAsByte<ECollisionResponse> GetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel);
    FName GetCollisionProfileName();
    TEnumAsByte<ECollisionChannel> GetCollisionObjectType();
    TEnumAsByte<ECollisionEnabled::Type> GetCollisionEnabled();
    float GetClosestPointOnCollision(const FVector& Point, FVector& OutPointOnBody, FName BoneName);
    FVector GetCenterOfMass(FName BoneName);
    float GetAngularDamping();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(int32 ElementIndex, class UMaterialInterface* SourceMaterial, FName OptionalName);
    class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent);
    class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamic(int32 ElementIndex);
    TArray<class UPrimitiveComponent*> CopyArrayOfMoveIgnoreComponents();
    TArray<class AActor*> CopyArrayOfMoveIgnoreActors();
    void ClearMoveIgnoreComponents();
    void ClearMoveIgnoreActors();
    bool CanCharacterStepUp(class APawn* Pawn);
    void AddTorqueInRadians(FVector Torque, FName BoneName, bool bAccelChange);
    void AddTorqueInDegrees(FVector Torque, FName BoneName, bool bAccelChange);
    void AddTorque(FVector Torque, FName BoneName, bool bAccelChange);
    void AddRadialImpulse(FVector Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bVelChange);
    void AddRadialForce(FVector Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bAccelChange);
    void AddImpulseAtLocation(FVector Impulse, FVector Location, FName BoneName);
    void AddImpulse(FVector Impulse, FName BoneName, bool bVelChange);
    void AddForceAtLocationLocal(FVector Force, FVector Location, FName BoneName);
    void AddForceAtLocation(FVector Force, FVector Location, FName BoneName);
    void AddForce(FVector Force, FName BoneName, bool bAccelChange);
    void AddAngularImpulseInRadians(FVector Impulse, FName BoneName, bool bVelChange);
    void AddAngularImpulseInDegrees(FVector Impulse, FName BoneName, bool bVelChange);
    void AddAngularImpulse(FVector Impulse, FName BoneName, bool bVelChange);
}; // Size: 0x450

struct FDirectoryPath
{
    FString Path;                                                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FMeshBuildSettings
{
    uint8 bUseMikkTSpace;                                                             // 0x0000 (size: 0x1)
    uint8 bRecomputeNormals;                                                          // 0x0000 (size: 0x1)
    uint8 bRecomputeTangents;                                                         // 0x0000 (size: 0x1)
    uint8 bComputeWeightedNormals;                                                    // 0x0000 (size: 0x1)
    uint8 bRemoveDegenerates;                                                         // 0x0000 (size: 0x1)
    uint8 bBuildAdjacencyBuffer;                                                      // 0x0000 (size: 0x1)
    uint8 bBuildReversedIndexBuffer;                                                  // 0x0000 (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x0000 (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x0001 (size: 0x1)
    uint8 bGenerateLightmapUVs;                                                       // 0x0001 (size: 0x1)
    uint8 bGenerateDistanceFieldAsIfTwoSided;                                         // 0x0001 (size: 0x1)
    uint8 bSupportFaceRemap;                                                          // 0x0001 (size: 0x1)
    int32 MinLightmapResolution;                                                      // 0x0004 (size: 0x4)
    int32 SrcLightmapIndex;                                                           // 0x0008 (size: 0x4)
    int32 DstLightmapIndex;                                                           // 0x000C (size: 0x4)
    float BuildScale;                                                                 // 0x0010 (size: 0x4)
    FVector BuildScale3D;                                                             // 0x0014 (size: 0xC)
    float DistanceFieldResolutionScale;                                               // 0x0020 (size: 0x4)
    class UStaticMesh* DistanceFieldReplacementMesh;                                  // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FTimerHandle
{
    uint64 Handle;                                                                    // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FMeshUVChannelInfo
{
    bool bInitialized;                                                                // 0x0000 (size: 0x1)
    bool bOverrideDensities;                                                          // 0x0001 (size: 0x1)
    float LocalUVDensities;                                                           // 0x0004 (size: 0x10)

}; // Size: 0x14

struct FStaticMaterial
{
    class UMaterialInterface* MaterialInterface;                                      // 0x0000 (size: 0x8)
    FName MaterialSlotName;                                                           // 0x0008 (size: 0x8)
    FName ImportedMaterialSlotName;                                                   // 0x0010 (size: 0x8)
    FMeshUVChannelInfo UVChannelData;                                                 // 0x0018 (size: 0x14)

}; // Size: 0x30

class UMeshComponent : public UPrimitiveComponent
{
    TArray<class UMaterialInterface*> OverrideMaterials;                              // 0x0450 (size: 0x10)
    uint8 bEnableMaterialParameterCaching;                                            // 0x0470 (size: 0x1)

    void SetVectorParameterValueOnMaterials(const FName ParameterName, const FVector ParameterValue);
    void SetScalarParameterValueOnMaterials(const FName ParameterName, const float ParameterValue);
    void PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32 CinematicTextureGroups);
    bool IsMaterialSlotNameValid(FName MaterialSlotName);
    TArray<FName> GetMaterialSlotNames();
    TArray<class UMaterialInterface*> GetMaterials();
    int32 GetMaterialIndex(FName MaterialSlotName);
}; // Size: 0x480

struct FVertexOffsetUsage
{
    int32 Usage;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSkelMeshComponentLODInfo
{
    TArray<bool> HiddenMaterials;                                                     // 0x0000 (size: 0x10)

}; // Size: 0x48

struct FSkelMeshSkinWeightInfo
{
    int32 Bones;                                                                      // 0x0000 (size: 0x30)
    uint8 Weights;                                                                    // 0x0030 (size: 0xC)

}; // Size: 0x3C

class USkinnedMeshComponent : public UMeshComponent
{
    class USkeletalMesh* SkeletalMesh;                                                // 0x0480 (size: 0x8)
    TWeakObjectPtr<class USkinnedMeshComponent> MasterPoseComponent;                  // 0x0488 (size: 0x8)
    TArray<ESkinCacheUsage> SkinCacheUsage;                                           // 0x0490 (size: 0x10)
    TArray<FVertexOffsetUsage> VertexOffsetUsage;                                     // 0x04A0 (size: 0x10)
    class UPhysicsAsset* PhysicsAssetOverride;                                        // 0x05A8 (size: 0x8)
    int32 ForcedLodModel;                                                             // 0x05B0 (size: 0x4)
    int32 MinLodModel;                                                                // 0x05B4 (size: 0x4)
    float StreamingDistanceMultiplier;                                                // 0x05C0 (size: 0x4)
    TArray<FSkelMeshComponentLODInfo> LODInfo;                                        // 0x05D0 (size: 0x10)
    EVisibilityBasedAnimTickOption VisibilityBasedAnimTickOption;                     // 0x0604 (size: 0x1)
    uint8 bOverrideMinLod;                                                            // 0x0606 (size: 0x1)
    uint8 bUseBoundsFromMasterPoseComponent;                                          // 0x0606 (size: 0x1)
    uint8 bForceWireframe;                                                            // 0x0606 (size: 0x1)
    uint8 bDisplayBones;                                                              // 0x0606 (size: 0x1)
    uint8 bDisableMorphTarget;                                                        // 0x0606 (size: 0x1)
    uint8 bHideSkin;                                                                  // 0x0607 (size: 0x1)
    uint8 bPerBoneMotionBlur;                                                         // 0x0607 (size: 0x1)
    uint8 bComponentUseFixedSkelBounds;                                               // 0x0607 (size: 0x1)
    uint8 bConsiderAllBodiesForBounds;                                                // 0x0607 (size: 0x1)
    uint8 bSyncAttachParentLOD;                                                       // 0x0607 (size: 0x1)
    uint8 bCanHighlightSelectedSections;                                              // 0x0607 (size: 0x1)
    uint8 bRecentlyRendered;                                                          // 0x0607 (size: 0x1)
    uint8 bCastCapsuleDirectShadow;                                                   // 0x0607 (size: 0x1)
    uint8 bCastCapsuleIndirectShadow;                                                 // 0x0608 (size: 0x1)
    uint8 bCPUSkinning;                                                               // 0x0608 (size: 0x1)
    uint8 bEnableUpdateRateOptimizations;                                             // 0x0608 (size: 0x1)
    uint8 bDisplayDebugUpdateRateOptimizations;                                       // 0x0608 (size: 0x1)
    uint8 bRenderStatic;                                                              // 0x0608 (size: 0x1)
    uint8 bIgnoreMasterPoseComponentLOD;                                              // 0x0608 (size: 0x1)
    uint8 bCachedLocalBoundsUpToDate;                                                 // 0x0609 (size: 0x1)
    uint8 bForceMeshObjectUpdate;                                                     // 0x0609 (size: 0x1)
    float CapsuleIndirectShadowMinVisibility;                                         // 0x060C (size: 0x4)
    FBoxSphereBounds CachedWorldSpaceBounds;                                          // 0x0620 (size: 0x1C)
    FMatrix CachedWorldToLocalTransform;                                              // 0x0640 (size: 0x40)

    void UnloadSkinWeightProfile(FName InProfileName);
    void UnHideBoneByName(FName BoneName);
    void TransformToBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation);
    void TransformFromBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation);
    void ShowMaterialSection(int32 MaterialID, int32 SectionIndex, bool bShow, int32 LODIndex);
    void ShowAllMaterialSections(int32 LODIndex);
    void SetVertexOffsetUsage(int32 LODIndex, int32 Usage);
    void SetVertexColorOverride_LinearColor(int32 LODIndex, const TArray<FLinearColor>& VertexColors);
    bool SetSkinWeightProfile(FName InProfileName);
    void SetSkinWeightOverride(int32 LODIndex, const TArray<FSkelMeshSkinWeightInfo>& SkinWeights);
    void SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose);
    void SetRenderStatic(bool bNewValue);
    void SetPreSkinningOffsets(int32 LODIndex, TArray<FVector> Offsets);
    void SetPostSkinningOffsets(int32 LODIndex, TArray<FVector> Offsets);
    void SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit);
    void SetMinLOD(int32 InNewMinLOD);
    void SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent, bool bForceUpdate);
    void SetForcedLOD(int32 InNewForcedLOD);
    void SetCastCapsuleIndirectShadow(bool bNewValue);
    void SetCastCapsuleDirectShadow(bool bNewValue);
    void SetCapsuleIndirectShadowMinVisibility(float newValue);
    bool IsUsingSkinWeightProfile();
    bool IsMaterialSectionShown(int32 MaterialID, int32 LODIndex);
    bool IsBoneHiddenByName(FName BoneName);
    void HideBoneByName(FName BoneName, TEnumAsByte<EPhysBodyOp> PhysBodyOption);
    int32 GetVertexOffsetUsage(int32 LODIndex);
    bool GetTwistAndSwingAngleOfDeltaRotationFromRefPose(FName BoneName, float& OutTwistAngle, float& OutSwingAngle);
    FName GetSocketBoneName(FName InSocketName);
    FVector GetRefPosePosition(int32 BoneIndex);
    FName GetParentBone(FName BoneName);
    int32 GetNumLODs();
    int32 GetNumBones();
    int32 GetForcedLOD();
    FTransform GetDeltaTransformFromRefPose(FName BoneName, FName BaseName);
    FName GetCurrentSkinWeightProfileName();
    FName GetBoneName(int32 BoneIndex);
    int32 GetBoneIndex(FName BoneName);
    FName FindClosestBone_K2(FVector TestLocation, FVector& BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset);
    void ClearVertexColorOverride(int32 LODIndex);
    void ClearSkinWeightProfile();
    void ClearSkinWeightOverride(int32 LODIndex);
    bool BoneIsChildOf(FName BoneName, FName ParentBoneName);
}; // Size: 0x6A0

struct FFractureEffect
{
    class UParticleSystem* ParticleSystem;                                            // 0x0000 (size: 0x8)
    class USoundBase* Sound;                                                          // 0x0008 (size: 0x8)

}; // Size: 0x10

class UStreamableRenderAsset : public UObject
{
    double ForceMipLevelsToBeResidentTimestamp;                                       // 0x0040 (size: 0x8)
    int32 NumCinematicMipLevels;                                                      // 0x0048 (size: 0x4)
    int32 StreamingIndex;                                                             // 0x004C (size: 0x4)
    int32 CachedCombinedLODBias;                                                      // 0x0050 (size: 0x4)
    uint8 NeverStream;                                                                // 0x0054 (size: 0x1)
    uint8 bGlobalForceMipLevelsToBeResident;                                          // 0x0054 (size: 0x1)
    uint8 bHasStreamingUpdatePending;                                                 // 0x0054 (size: 0x1)
    uint8 bForceMiplevelsToBeResident;                                                // 0x0054 (size: 0x1)
    uint8 bIgnoreStreamingMipBias;                                                    // 0x0054 (size: 0x1)
    uint8 bUseCinematicMipLevels;                                                     // 0x0054 (size: 0x1)

}; // Size: 0x60

struct FSkeletalMaterial
{
    class UMaterialInterface* MaterialInterface;                                      // 0x0000 (size: 0x8)
    FName MaterialSlotName;                                                           // 0x0008 (size: 0x8)
    FMeshUVChannelInfo UVChannelData;                                                 // 0x0010 (size: 0x14)

}; // Size: 0x28

struct FBoneMirrorInfo
{
    int32 SourceIndex;                                                                // 0x0000 (size: 0x4)
    TEnumAsByte<EAxis::Type> BoneFlipAxis;                                            // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FPerPlatformFloat
{
    float Default;                                                                    // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSkeletalMeshBuildSettings
{
    uint8 bRecomputeNormals;                                                          // 0x0000 (size: 0x1)
    uint8 bRecomputeTangents;                                                         // 0x0000 (size: 0x1)
    uint8 bUseMikkTSpace;                                                             // 0x0000 (size: 0x1)
    uint8 bComputeWeightedNormals;                                                    // 0x0000 (size: 0x1)
    uint8 bRemoveDegenerates;                                                         // 0x0000 (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x0000 (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x0000 (size: 0x1)
    uint8 bBuildAdjacencyBuffer;                                                      // 0x0000 (size: 0x1)
    float ThresholdPosition;                                                          // 0x0004 (size: 0x4)
    float ThresholdTangentNormal;                                                     // 0x0008 (size: 0x4)
    float ThresholdUV;                                                                // 0x000C (size: 0x4)
    float MorphThresholdPosition;                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FSkeletalMeshOptimizationSettings
{
    TEnumAsByte<SkeletalMeshTerminationCriterion> TerminationCriterion;               // 0x0000 (size: 0x1)
    float NumOfTrianglesPercentage;                                                   // 0x0004 (size: 0x4)
    float NumOfVertPercentage;                                                        // 0x0008 (size: 0x4)
    uint32 MaxNumOfTriangles;                                                         // 0x000C (size: 0x4)
    uint32 MaxNumOfVerts;                                                             // 0x0010 (size: 0x4)
    float MaxDeviationPercentage;                                                     // 0x0014 (size: 0x4)
    TEnumAsByte<SkeletalMeshOptimizationType> ReductionMethod;                        // 0x0018 (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> SilhouetteImportance;             // 0x0019 (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> TextureImportance;                // 0x001A (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> ShadingImportance;                // 0x001B (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> SkinningImportance;               // 0x001C (size: 0x1)
    uint8 bRemapMorphTargets;                                                         // 0x001D (size: 0x1)
    uint8 bRecalcNormals;                                                             // 0x001D (size: 0x1)
    float WeldingThreshold;                                                           // 0x0020 (size: 0x4)
    float NormalsThreshold;                                                           // 0x0024 (size: 0x4)
    int32 MaxBonesPerVertex;                                                          // 0x0028 (size: 0x4)
    uint8 bEnforceBoneBoundaries;                                                     // 0x002C (size: 0x1)
    float VolumeImportance;                                                           // 0x0030 (size: 0x4)
    uint8 bLockEdges;                                                                 // 0x0034 (size: 0x1)
    uint8 bLockColorBounaries;                                                        // 0x0034 (size: 0x1)
    int32 BaseLOD;                                                                    // 0x0038 (size: 0x4)

}; // Size: 0x3C

struct FBoneReference
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FSkeletalMeshLODInfo
{
    FPerPlatformFloat ScreenSize;                                                     // 0x0000 (size: 0x4)
    float LODHysteresis;                                                              // 0x0004 (size: 0x4)
    TArray<int32> LODMaterialMap;                                                     // 0x0008 (size: 0x10)
    FSkeletalMeshBuildSettings BuildSettings;                                         // 0x0018 (size: 0x14)
    FSkeletalMeshOptimizationSettings ReductionSettings;                              // 0x002C (size: 0x3C)
    TArray<FBoneReference> BonesToRemove;                                             // 0x0068 (size: 0x10)
    TArray<FBoneReference> BonesToPrioritize;                                         // 0x0078 (size: 0x10)
    float WeightOfPrioritization;                                                     // 0x0088 (size: 0x4)
    class UAnimSequence* BakePose;                                                    // 0x0090 (size: 0x8)
    class UAnimSequence* BakePoseOverride;                                            // 0x0098 (size: 0x8)
    FString SourceImportFilename;                                                     // 0x00A0 (size: 0x10)
    ESkinCacheUsage SkinCacheUsage;                                                   // 0x00B0 (size: 0x1)
    uint8 bHasBeenSimplified;                                                         // 0x00B1 (size: 0x1)
    uint8 bHasPerLODVertexColors;                                                     // 0x00B1 (size: 0x1)
    uint8 bAllowCPUAccess;                                                            // 0x00B1 (size: 0x1)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x00B1 (size: 0x1)

}; // Size: 0xB8

struct FPerPlatformInt
{
    int32 Default;                                                                    // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FPerPlatformBool
{
    bool Default;                                                                     // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FSkeletalMeshSamplingRegionMaterialFilter
{
    FName MaterialName;                                                               // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSkeletalMeshSamplingRegionBoneFilter
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    uint8 bIncludeOrExclude;                                                          // 0x0008 (size: 0x1)
    uint8 bApplyToChildren;                                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSkeletalMeshSamplingRegion
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    int32 LODIndex;                                                                   // 0x0008 (size: 0x4)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x000C (size: 0x1)
    TArray<FSkeletalMeshSamplingRegionMaterialFilter> MaterialFilters;                // 0x0010 (size: 0x10)
    TArray<FSkeletalMeshSamplingRegionBoneFilter> BoneFilters;                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSkeletalMeshSamplingLODBuiltData
{
}; // Size: 0x48

struct FSkeletalMeshSamplingRegionBuiltData
{
}; // Size: 0x78

struct FSkeletalMeshSamplingBuiltData
{
    TArray<FSkeletalMeshSamplingLODBuiltData> WholeMeshBuiltData;                     // 0x0000 (size: 0x10)
    TArray<FSkeletalMeshSamplingRegionBuiltData> RegionBuiltData;                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSkeletalMeshSamplingInfo
{
    TArray<FSkeletalMeshSamplingRegion> Regions;                                      // 0x0000 (size: 0x10)
    FSkeletalMeshSamplingBuiltData BuiltData;                                         // 0x0010 (size: 0x20)

}; // Size: 0x30

struct FSkinWeightProfileInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FPerPlatformBool DefaultProfile;                                                  // 0x0008 (size: 0x1)
    FPerPlatformInt DefaultProfileFromLODIndex;                                       // 0x000C (size: 0x4)

}; // Size: 0x10

class USkeletalMesh : public UStreamableRenderAsset
{
    class USkeleton* Skeleton;                                                        // 0x0080 (size: 0x8)
    FBoxSphereBounds ImportedBounds;                                                  // 0x0088 (size: 0x1C)
    FBoxSphereBounds ExtendedBounds;                                                  // 0x00A4 (size: 0x1C)
    FVector PositiveBoundsExtension;                                                  // 0x00C0 (size: 0xC)
    FVector NegativeBoundsExtension;                                                  // 0x00CC (size: 0xC)
    TArray<FSkeletalMaterial> Materials;                                              // 0x00D8 (size: 0x10)
    TArray<FBoneMirrorInfo> SkelMirrorTable;                                          // 0x00E8 (size: 0x10)
    TArray<FSkeletalMeshLODInfo> LODInfo;                                             // 0x00F8 (size: 0x10)
    FPerPlatformInt MinLOD;                                                           // 0x0158 (size: 0x4)
    FPerPlatformBool DisableBelowMinLodStripping;                                     // 0x015C (size: 0x1)
    TEnumAsByte<EAxis::Type> SkelMirrorAxis;                                          // 0x015D (size: 0x1)
    TEnumAsByte<EAxis::Type> SkelMirrorFlipAxis;                                      // 0x015E (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x015F (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x015F (size: 0x1)
    uint8 bHasBeenSimplified;                                                         // 0x015F (size: 0x1)
    uint8 bHasVertexColors;                                                           // 0x015F (size: 0x1)
    uint8 bEnablePerPolyCollision;                                                    // 0x015F (size: 0x1)
    class UBodySetup* BodySetup;                                                      // 0x0160 (size: 0x8)
    class UPhysicsAsset* PhysicsAsset;                                                // 0x0168 (size: 0x8)
    class UPhysicsAsset* ShadowPhysicsAsset;                                          // 0x0170 (size: 0x8)
    TArray<class UNodeMappingContainer*> NodeMappingData;                             // 0x0178 (size: 0x10)
    uint8 bSupportRayTracing;                                                         // 0x0188 (size: 0x1)
    TArray<class UMorphTarget*> MorphTargets;                                         // 0x0190 (size: 0x10)
    TSubclassOf<class UAnimInstance> PostProcessAnimBlueprint;                        // 0x0318 (size: 0x8)
    TArray<class UClothingAssetBase*> MeshClothingAssets;                             // 0x0320 (size: 0x10)
    FSkeletalMeshSamplingInfo SamplingInfo;                                           // 0x0330 (size: 0x30)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0360 (size: 0x10)
    TArray<class USkeletalMeshSocket*> Sockets;                                       // 0x0370 (size: 0x10)
    TArray<FSkinWeightProfileInfo> SkinWeightProfiles;                                // 0x0390 (size: 0x10)

    void SetMorphTargets(const TArray<class UMorphTarget*>& InMorphTargets);
    void SetMeshClothingAssets(const TArray<class UClothingAssetBase*>& InMeshClothingAssets);
    void SetMaterials(const TArray<FSkeletalMaterial>& InMaterials);
    void SetLODSettings(class USkeletalMeshLODSettings* InLODSettings);
    void SetDefaultAnimatingRig(TSoftObjectPtr<UObject> InAnimatingRig);
    int32 NumSockets();
    TArray<FString> K2_GetAllMorphTargetNames();
    bool IsSectionUsingCloth(int32 InSectionIndex, bool bCheckCorrespondingSections);
    class USkeletalMeshSocket* GetSocketByIndex(int32 Index);
    class USkeleton* GetSkeleton();
    class UPhysicsAsset* GetShadowPhysicsAsset();
    class UPhysicsAsset* GetPhysicsAsset();
    TArray<class UNodeMappingContainer*> GetNodeMappingData();
    class UNodeMappingContainer* GetNodeMappingContainer(class UBlueprint* SourceAsset);
    TArray<class UMorphTarget*> GetMorphTargets();
    TArray<class UClothingAssetBase*> GetMeshClothingAssets();
    TArray<FSkeletalMaterial> GetMaterials();
    class USkeletalMeshLODSettings* GetLODSettings();
    FBoxSphereBounds GetImportedBounds();
    TSoftObjectPtr<UObject> GetDefaultAnimatingRig();
    FBoxSphereBounds GetBounds();
    class USkeletalMeshSocket* FindSocketInfo(FName InSocketName, FTransform& OutTransform, int32& OutBoneIndex, int32& OutIndex);
    class USkeletalMeshSocket* FindSocketAndIndex(FName InSocketName, int32& OutIndex);
    class USkeletalMeshSocket* FindSocket(FName InSocketName);
}; // Size: 0x3A0

class UBlueprintFunctionLibrary : public UObject
{
}; // Size: 0x28

class AController : public AActor
{
    class APlayerState* PlayerState;                                                  // 0x0230 (size: 0x8)
    FControllerOnInstigatedAnyDamage OnInstigatedAnyDamage;                           // 0x0240 (size: 0x10)
    void InstigatedAnyDamageSignature(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser);
    FName StateName;                                                                  // 0x0250 (size: 0x8)
    class APawn* Pawn;                                                                // 0x0258 (size: 0x8)
    class ACharacter* Character;                                                      // 0x0268 (size: 0x8)
    class USceneComponent* TransformComponent;                                        // 0x0270 (size: 0x8)
    FRotator ControlRotation;                                                         // 0x0290 (size: 0xC)
    uint8 bAttachToPawn;                                                              // 0x029C (size: 0x1)

    void UnPossess();
    void StopMovement();
    void SetInitialLocationAndRotation(const FVector& NewLocation, const FRotator& NewRotation);
    void SetIgnoreMoveInput(bool bNewMoveInput);
    void SetIgnoreLookInput(bool bNewLookInput);
    void SetControlRotation(const FRotator& NewRotation);
    void ResetIgnoreMoveInput();
    void ResetIgnoreLookInput();
    void ResetIgnoreInputFlags();
    void ReceiveUnPossess(class APawn* UnpossessedPawn);
    void ReceivePossess(class APawn* PossessedPawn);
    void ReceiveInstigatedAnyDamage(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser);
    void Possess(class APawn* InPawn);
    void OnRep_PlayerState();
    void OnRep_Pawn();
    bool LineOfSightTo(const class AActor* Other, FVector ViewPoint, bool bAlternateChecks);
    class APawn* K2_GetPawn();
    bool IsPlayerController();
    bool IsMoveInputIgnored();
    bool IsLookInputIgnored();
    bool IsLocalPlayerController();
    bool IsLocalController();
    class AActor* GetViewTarget();
    FRotator GetDesiredRotation();
    FRotator GetControlRotation();
    void ClientSetRotation(FRotator NewRotation, bool bResetCamera);
    void ClientSetLocation(FVector NewLocation, FRotator NewRotation);
    class APlayerController* CastToPlayerController();
}; // Size: 0x2A0

struct FActiveForceFeedbackEffect
{
    class UForceFeedbackEffect* ForceFeedbackEffect;                                  // 0x0000 (size: 0x8)

}; // Size: 0x18

struct FViewTargetTransitionParams
{
    float BlendTime;                                                                  // 0x0000 (size: 0x4)
    TEnumAsByte<EViewTargetBlendFunction> BlendFunction;                              // 0x0004 (size: 0x1)
    float BlendExp;                                                                   // 0x0008 (size: 0x4)
    uint8 bLockOutgoing;                                                              // 0x000C (size: 0x1)

}; // Size: 0x10

struct FUpdateLevelVisibilityLevelInfo
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    FName Filename;                                                                   // 0x0008 (size: 0x8)
    uint8 bIsVisible;                                                                 // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FUniqueNetIdRepl : public FUniqueNetIdWrapper
{
    TArray<uint8> ReplicationBytes;                                                   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FLatentActionInfo
{
    int32 Linkage;                                                                    // 0x0000 (size: 0x4)
    int32 UUID;                                                                       // 0x0004 (size: 0x4)
    FName ExecutionFunction;                                                          // 0x0008 (size: 0x8)
    class UObject* CallbackTarget;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FUpdateLevelStreamingLevelStatus
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    int32 LODIndex;                                                                   // 0x0008 (size: 0x4)
    bool bNewShouldBeLoaded;                                                          // 0x000C (size: 0x1)
    bool bNewShouldBeVisible;                                                         // 0x000D (size: 0x1)
    bool bNewShouldBlockOnLoad;                                                       // 0x000E (size: 0x1)

}; // Size: 0x10

struct FForceFeedbackParameters
{
    FName Tag;                                                                        // 0x0000 (size: 0x8)
    bool bLooping;                                                                    // 0x0008 (size: 0x1)
    bool bIgnoreTimeDilation;                                                         // 0x0009 (size: 0x1)
    bool bPlayWhilePaused;                                                            // 0x000A (size: 0x1)

}; // Size: 0xC

class APlayerController : public AController
{
    class UPlayer* Player;                                                            // 0x02A0 (size: 0x8)
    class APawn* AcknowledgedPawn;                                                    // 0x02A8 (size: 0x8)
    class UInterpTrackInstDirector* ControllingDirTrackInst;                          // 0x02B0 (size: 0x8)
    class AHUD* MyHUD;                                                                // 0x02B8 (size: 0x8)
    class APlayerCameraManager* PlayerCameraManager;                                  // 0x02C0 (size: 0x8)
    TSubclassOf<class APlayerCameraManager> PlayerCameraManagerClass;                 // 0x02C8 (size: 0x8)
    bool bAutoManageActiveCameraTarget;                                               // 0x02D0 (size: 0x1)
    FRotator TargetViewRotation;                                                      // 0x02D4 (size: 0xC)
    float SmoothTargetViewRotationSpeed;                                              // 0x02EC (size: 0x4)
    TArray<class AActor*> HiddenActors;                                               // 0x02F8 (size: 0x10)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenPrimitiveComponents;            // 0x0308 (size: 0x10)
    float LastSpectatorStateSynchTime;                                                // 0x031C (size: 0x4)
    FVector LastSpectatorSyncLocation;                                                // 0x0320 (size: 0xC)
    FRotator LastSpectatorSyncRotation;                                               // 0x032C (size: 0xC)
    int32 ClientCap;                                                                  // 0x0338 (size: 0x4)
    class UCheatManager* CheatManager;                                                // 0x0340 (size: 0x8)
    TSubclassOf<class UCheatManager> CheatClass;                                      // 0x0348 (size: 0x8)
    class UPlayerInput* PlayerInput;                                                  // 0x0350 (size: 0x8)
    TArray<FActiveForceFeedbackEffect> ActiveForceFeedbackEffects;                    // 0x0358 (size: 0x10)
    uint8 bPlayerIsWaiting;                                                           // 0x03D8 (size: 0x1)
    uint8 NetPlayerIndex;                                                             // 0x03DC (size: 0x1)
    class UNetConnection* PendingSwapConnection;                                      // 0x0418 (size: 0x8)
    class UNetConnection* NetConnection;                                              // 0x0420 (size: 0x8)
    float InputYawScale;                                                              // 0x0434 (size: 0x4)
    float InputPitchScale;                                                            // 0x0438 (size: 0x4)
    float InputRollScale;                                                             // 0x043C (size: 0x4)
    uint8 bShowMouseCursor;                                                           // 0x0440 (size: 0x1)
    uint8 bEnableClickEvents;                                                         // 0x0440 (size: 0x1)
    uint8 bEnableTouchEvents;                                                         // 0x0440 (size: 0x1)
    uint8 bEnableMouseOverEvents;                                                     // 0x0440 (size: 0x1)
    uint8 bEnableTouchOverEvents;                                                     // 0x0440 (size: 0x1)
    uint8 bForceFeedbackEnabled;                                                      // 0x0440 (size: 0x1)
    float ForceFeedbackScale;                                                         // 0x0444 (size: 0x4)
    TArray<FKey> ClickEventKeys;                                                      // 0x0448 (size: 0x10)
    TEnumAsByte<EMouseCursor::Type> DefaultMouseCursor;                               // 0x0458 (size: 0x1)
    TEnumAsByte<EMouseCursor::Type> CurrentMouseCursor;                               // 0x0459 (size: 0x1)
    TEnumAsByte<ECollisionChannel> DefaultClickTraceChannel;                          // 0x045A (size: 0x1)
    TEnumAsByte<ECollisionChannel> CurrentClickTraceChannel;                          // 0x045B (size: 0x1)
    float HitResultTraceDistance;                                                     // 0x045C (size: 0x4)
    uint16 SeamlessTravelCount;                                                       // 0x0460 (size: 0x2)
    uint16 LastCompletedSeamlessTravelCount;                                          // 0x0462 (size: 0x2)
    class UInputComponent* InactiveStateInputComponent;                               // 0x04D8 (size: 0x8)
    uint8 bShouldPerformFullTickWhenPaused;                                           // 0x04E0 (size: 0x1)
    class UTouchInterface* CurrentTouchInterface;                                     // 0x04F8 (size: 0x8)
    class ASpectatorPawn* SpectatorPawn;                                              // 0x0550 (size: 0x8)
    bool bIsLocalPlayerController;                                                    // 0x055C (size: 0x1)
    FVector SpawnLocation;                                                            // 0x0560 (size: 0xC)

    bool WasInputKeyJustReleased(FKey Key);
    bool WasInputKeyJustPressed(FKey Key);
    void ToggleSpeaking(bool bInSpeaking);
    void TestServerLevelVisibilityChange(const FName PackageName, const FName Filename);
    void SwitchLevel(FString URL);
    void StopHapticEffect(EControllerHand Hand);
    void StartFire(uint8 FireModeNum);
    void SetVirtualJoystickVisibility(bool bVisible);
    void SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, TEnumAsByte<EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing);
    void SetName(FString S);
    void SetMouseLocation(const int32 X, const int32 Y);
    void SetMouseCursorWidget(TEnumAsByte<EMouseCursor::Type> Cursor, class UUserWidget* CursorWidget);
    void SetHapticsByValue(const float Frequency, const float Amplitude, EControllerHand Hand);
    void SetDisableHaptics(bool bNewDisabled);
    void SetControllerLightColor(FColor Color);
    void SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    void SetAudioListenerOverride(class USceneComponent* AttachToComponent, FVector Location, FRotator Rotation);
    void SetAudioListenerAttenuationOverride(class USceneComponent* AttachToComponent, FVector AttenuationLocationOVerride);
    void ServerViewSelf(FViewTargetTransitionParams TransitionParams);
    void ServerViewPrevPlayer();
    void ServerViewNextPlayer();
    void ServerVerifyViewTarget();
    void ServerUpdateMultipleLevelsVisibility(const TArray<FUpdateLevelVisibilityLevelInfo>& LevelVisibilities);
    void ServerUpdateLevelVisibility(const FUpdateLevelVisibilityLevelInfo& LevelVisibility);
    void ServerUpdateCamera(FVector_NetQuantize CamLoc, int32 CamPitchAndYaw);
    void ServerUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerToggleAILogging();
    void ServerShortTimeout();
    void ServerSetSpectatorWaiting(bool bWaiting);
    void ServerSetSpectatorLocation(FVector NewLoc, FRotator NewRot);
    void ServerRestartPlayer();
    void ServerPause();
    void ServerNotifyLoadedWorld(FName WorldPackageName);
    void ServerMutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerExecRPC(FString Msg);
    void ServerExec(FString Msg);
    void ServerCheckClientPossessionReliable();
    void ServerCheckClientPossession();
    void ServerChangeName(FString S);
    void ServerCamera(FName NewMode);
    void ServerAcknowledgePossession(class APawn* P);
    void SendToConsole(FString Command);
    void RestartLevel();
    void ResetControllerLightColor();
    bool ProjectWorldLocationToScreen(FVector WorldLocation, FVector2D& ScreenLocation, bool bPlayerViewportRelative);
    void PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, EControllerHand Hand, float Scale, bool bLoop);
    void PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, TEnumAsByte<EDynamicForceFeedbackAction::Type> Action, FLatentActionInfo LatentInfo);
    void Pause();
    void OnServerStartedVisualLogger(bool bIsLogging);
    void LocalTravel(FString URL);
    void K2_ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
    bool IsInputKeyDown(FKey Key);
    void GetViewportSize(int32& SizeX, int32& SizeY);
    class ASpectatorPawn* GetSpectatorPawn();
    bool GetMousePosition(float& LocationX, float& LocationY);
    FVector GetInputVectorKeyState(FKey Key);
    void GetInputTouchState(TEnumAsByte<ETouchIndex::Type> FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed);
    void GetInputMouseDelta(float& DeltaX, float& DeltaY);
    void GetInputMotionState(FVector& Tilt, FVector& RotationRate, FVector& Gravity, FVector& Acceleration);
    float GetInputKeyTimeDown(FKey Key);
    void GetInputAnalogStickState(TEnumAsByte<EControllerAnalogStick::Type> WhichStick, float& StickX, float& StickY);
    float GetInputAnalogKeyState(FKey Key);
    class AHUD* GetHUD();
    bool GetHitResultUnderFingerForObjects(TEnumAsByte<ETouchIndex::Type> FingerIndex, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderFingerByChannel(TEnumAsByte<ETouchIndex::Type> FingerIndex, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderFinger(TEnumAsByte<ETouchIndex::Type> FingerIndex, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursorForObjects(const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursorByChannel(TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursor(TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    FVector GetFocalLocation();
    void FOV(float NewFOV);
    void EnableCheats();
    bool DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, FVector& WorldLocation, FVector& WorldDirection);
    bool DeprojectMousePositionToWorld(FVector& WorldLocation, FVector& WorldDirection);
    void ConsoleKey(FKey Key);
    void ClientWasKicked(const FText& KickReason);
    void ClientVoiceHandshakeComplete();
    void ClientUpdateMultipleLevelsStreamingStatus(const TArray<FUpdateLevelStreamingLevelStatus>& LevelStatuses);
    void ClientUpdateLevelStreamingStatus(FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32 LODIndex);
    void ClientUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientTravelInternal(FString URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientTravel(FString URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientTeamMessage(class APlayerState* SenderPlayerState, FString S, FName Type, float MsgLifeTime);
    void ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, FName Tag);
    void ClientStopCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void ClientStopCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately);
    void ClientStopCameraAnim(class UCameraAnim* AnimToStop);
    void ClientStartOnlineSession();
    void ClientStartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent);
    void ClientStartCameraShake(TSubclassOf<class UCameraShakeBase> Shake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void ClientSpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
    void ClientSetViewTarget(class AActor* A, FViewTargetTransitionParams TransitionParams);
    void ClientSetSpectatorWaiting(bool bWaiting);
    void ClientSetHUD(TSubclassOf<class AHUD> NewHUDClass);
    void ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32 CinematicTextureGroups);
    void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
    void ClientSetCameraMode(FName NewCamMode);
    void ClientSetCameraFade(bool bEnableFading, FColor FadeColor, FVector2D FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldWhenFinished);
    void ClientSetBlockOnAsyncLoading();
    void ClientReturnToMainMenuWithTextReason(const FText& ReturnReason);
    void ClientReturnToMainMenu(FString ReturnReason);
    void ClientRetryClientRestart(class APawn* NewPawn);
    void ClientRestart(class APawn* NewPawn);
    void ClientReset();
    void ClientRepObjRef(class UObject* Object);
    void ClientReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> Message, int32 SWITCH, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject);
    void ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32 CinematicTextureGroups);
    void ClientPrepareMapChange(FName LevelName, bool bFirst, bool bLast);
    void ClientPlaySoundAtLocation(class USoundBase* Sound, FVector Location, float VolumeMultiplier, float PitchMultiplier);
    void ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
    void ClientPlayForceFeedback_Internal(class UForceFeedbackEffect* ForceFeedbackEffect, FForceFeedbackParameters Params);
    void ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float blendInTime, float blendOutTime, bool bLoop, bool bRandomStartTime, ECameraShakePlaySpace Space, FRotator CustomPlaySpace);
    void ClientMutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientMessage(FString S, FName Type, float MsgLifeTime);
    void ClientIgnoreMoveInput(bool bIgnore);
    void ClientIgnoreLookInput(bool bIgnore);
    void ClientGotoState(FName NewState);
    void ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
    void ClientForceGarbageCollection();
    void ClientFlushLevelStreaming();
    void ClientEndOnlineSession();
    void ClientEnableNetworkVoice(bool bEnable);
    void ClientCommitMapChange();
    void ClientClearCameraLensEffects();
    void ClientCapBandwidth(int32 Cap);
    void ClientCancelPendingMapChange();
    void ClientAddTextureStreamingLoc(FVector InLoc, float Duration, bool bOverrideLocation);
    void ClearAudioListenerOverride();
    void ClearAudioListenerAttenuationOverride();
    bool CanRestartPlayer();
    void Camera(FName NewMode);
    void AddYawInput(float Val);
    void AddRollInput(float Val);
    void AddPitchInput(float Val);
    void ActivateTouchInterface(class UTouchInterface* NewTouchInterface);
}; // Size: 0x578

struct FSubtitleCue
{
    FText Text;                                                                       // 0x0000 (size: 0x18)
    float Time;                                                                       // 0x0018 (size: 0x4)

}; // Size: 0x20

class UBlueprintAsyncActionBase : public UObject
{

    void Activate();
}; // Size: 0x30

struct FKeyHandleMap
{
}; // Size: 0x60

struct FIndexedCurve
{
    FKeyHandleMap KeyHandlesToIndices;                                                // 0x0008 (size: 0x60)

}; // Size: 0x68

struct FRealCurve : public FIndexedCurve
{
    float DefaultValue;                                                               // 0x0068 (size: 0x4)
    TEnumAsByte<ERichCurveExtrapolation> PreInfinityExtrap;                           // 0x006C (size: 0x1)
    TEnumAsByte<ERichCurveExtrapolation> PostInfinityExtrap;                          // 0x006D (size: 0x1)

}; // Size: 0x70

struct FRichCurveKey
{
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x0000 (size: 0x1)
    TEnumAsByte<ERichCurveTangentMode> TangentMode;                                   // 0x0001 (size: 0x1)
    TEnumAsByte<ERichCurveTangentWeightMode> TangentWeightMode;                       // 0x0002 (size: 0x1)
    float Time;                                                                       // 0x0004 (size: 0x4)
    float Value;                                                                      // 0x0008 (size: 0x4)
    float ArriveTangent;                                                              // 0x000C (size: 0x4)
    float ArriveTangentWeight;                                                        // 0x0010 (size: 0x4)
    float LeaveTangent;                                                               // 0x0014 (size: 0x4)
    float LeaveTangentWeight;                                                         // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FRichCurve : public FRealCurve
{
    TArray<FRichCurveKey> Keys;                                                       // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FRuntimeFloatCurve
{
    FRichCurve EditorCurveData;                                                       // 0x0000 (size: 0x80)
    class UCurveFloat* ExternalCurve;                                                 // 0x0080 (size: 0x8)

}; // Size: 0x88

class UGameInstance : public UObject
{
    TArray<class ULocalPlayer*> LocalPlayers;                                         // 0x0038 (size: 0x10)
    class UOnlineSession* OnlineSession;                                              // 0x0048 (size: 0x8)
    TArray<class UObject*> ReferencedObjects;                                         // 0x0050 (size: 0x10)
    FGameInstanceOnPawnControllerChangedDelegates OnPawnControllerChangedDelegates;   // 0x0078 (size: 0x10)
    void OnPawnControllerChanged(class APawn* Pawn, class AController* Controller);

    void ReceiveShutdown();
    void ReceiveInit();
    void HandleTravelError(TEnumAsByte<ETravelFailure::Type> FailureType);
    void HandleNetworkError(TEnumAsByte<ENetworkFailure::Type> FailureType, bool bIsServer);
    void DebugRemovePlayer(int32 ControllerId);
    void DebugCreatePlayer(int32 ControllerId);
}; // Size: 0x1A8

class UPlatformGameInstance : public UGameInstance
{
    FPlatformGameInstanceApplicationWillDeactivateDelegate ApplicationWillDeactivateDelegate; // 0x01A8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationHasReactivatedDelegate ApplicationHasReactivatedDelegate; // 0x01B8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationWillEnterBackgroundDelegate ApplicationWillEnterBackgroundDelegate; // 0x01C8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationHasEnteredForegroundDelegate ApplicationHasEnteredForegroundDelegate; // 0x01D8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationWillTerminateDelegate ApplicationWillTerminateDelegate; // 0x01E8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationShouldUnloadResourcesDelegate ApplicationShouldUnloadResourcesDelegate; // 0x01F8 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationReceivedStartupArgumentsDelegate ApplicationReceivedStartupArgumentsDelegate; // 0x0208 (size: 0x10)
    void PlatformStartupArgumentsDelegate(const TArray<FString>& StartupArguments);
    FPlatformGameInstanceApplicationRegisteredForRemoteNotificationsDelegate ApplicationRegisteredForRemoteNotificationsDelegate; // 0x0218 (size: 0x10)
    void PlatformRegisteredForRemoteNotificationsDelegate(const TArray<uint8>& inArray);
    FPlatformGameInstanceApplicationRegisteredForUserNotificationsDelegate ApplicationRegisteredForUserNotificationsDelegate; // 0x0228 (size: 0x10)
    void PlatformRegisteredForUserNotificationsDelegate(int32 inInt);
    FPlatformGameInstanceApplicationFailedToRegisterForRemoteNotificationsDelegate ApplicationFailedToRegisterForRemoteNotificationsDelegate; // 0x0238 (size: 0x10)
    void PlatformFailedToRegisterForRemoteNotificationsDelegate(FString inString);
    FPlatformGameInstanceApplicationReceivedRemoteNotificationDelegate ApplicationReceivedRemoteNotificationDelegate; // 0x0248 (size: 0x10)
    void PlatformReceivedRemoteNotificationDelegate(FString inString, TEnumAsByte<EApplicationState::Type> inAppState);
    FPlatformGameInstanceApplicationReceivedLocalNotificationDelegate ApplicationReceivedLocalNotificationDelegate; // 0x0258 (size: 0x10)
    void PlatformReceivedLocalNotificationDelegate(FString inString, int32 inInt, TEnumAsByte<EApplicationState::Type> inAppState);
    FPlatformGameInstanceApplicationReceivedScreenOrientationChangedNotificationDelegate ApplicationReceivedScreenOrientationChangedNotificationDelegate; // 0x0268 (size: 0x10)
    void PlatformScreenOrientationChangedDelegate(TEnumAsByte<EScreenOrientation::Type> inScreenOrientation);

}; // Size: 0x278

struct FDebugTextInfo
{
    class AActor* SrcActor;                                                           // 0x0000 (size: 0x8)
    FVector SrcActorOffset;                                                           // 0x0008 (size: 0xC)
    FVector SrcActorDesiredOffset;                                                    // 0x0014 (size: 0xC)
    FString DebugText;                                                                // 0x0020 (size: 0x10)
    float TimeRemaining;                                                              // 0x0030 (size: 0x4)
    float Duration;                                                                   // 0x0034 (size: 0x4)
    FColor TextColor;                                                                 // 0x0038 (size: 0x4)
    uint8 bAbsoluteLocation;                                                          // 0x003C (size: 0x1)
    uint8 bKeepAttachedToActor;                                                       // 0x003C (size: 0x1)
    uint8 bDrawShadow;                                                                // 0x003C (size: 0x1)
    FVector OrigActorLocation;                                                        // 0x0040 (size: 0xC)
    class UFont* Font;                                                                // 0x0050 (size: 0x8)
    float FontScale;                                                                  // 0x0058 (size: 0x4)

}; // Size: 0x60

class AHUD : public AActor
{
    class APlayerController* PlayerOwner;                                             // 0x0228 (size: 0x8)
    uint8 bLostFocusPaused;                                                           // 0x0230 (size: 0x1)
    uint8 bShowHUD;                                                                   // 0x0230 (size: 0x1)
    uint8 bShowDebugInfo;                                                             // 0x0230 (size: 0x1)
    int32 CurrentTargetIndex;                                                         // 0x0234 (size: 0x4)
    uint8 bShowHitBoxDebugInfo;                                                       // 0x0238 (size: 0x1)
    uint8 bShowOverlays;                                                              // 0x0238 (size: 0x1)
    uint8 bEnableDebugTextShadow;                                                     // 0x0238 (size: 0x1)
    TArray<class AActor*> PostRenderedActors;                                         // 0x0240 (size: 0x10)
    TArray<FName> DebugDisplay;                                                       // 0x0258 (size: 0x10)
    TArray<FName> ToggledDebugCategories;                                             // 0x0268 (size: 0x10)
    class UCanvas* Canvas;                                                            // 0x0278 (size: 0x8)
    class UCanvas* DebugCanvas;                                                       // 0x0280 (size: 0x8)
    TArray<FDebugTextInfo> DebugTextList;                                             // 0x0288 (size: 0x10)
    TSubclassOf<class AActor> ShowDebugTargetDesiredClass;                            // 0x0298 (size: 0x8)
    class AActor* ShowDebugTargetActor;                                               // 0x02A0 (size: 0x8)

    void ShowHUD();
    void ShowDebugToggleSubCategory(FName Category);
    void ShowDebugForReticleTargetToggle(TSubclassOf<class AActor> DesiredClass);
    void ShowDebug(FName DebugType);
    void RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText);
    void RemoveAllDebugStrings();
    void ReceiveHitBoxRelease(const FName BoxName);
    void ReceiveHitBoxEndCursorOver(const FName BoxName);
    void ReceiveHitBoxClick(const FName BoxName);
    void ReceiveHitBoxBeginCursorOver(const FName BoxName);
    void ReceiveDrawHUD(int32 SizeX, int32 SizeY);
    FVector Project(FVector Location);
    void PreviousDebugTarget();
    void NextDebugTarget();
    void GetTextSize(FString Text, float& OutWidth, float& OutHeight, class UFont* Font, float Scale);
    class APlayerController* GetOwningPlayerController();
    class APawn* GetOwningPawn();
    void GetActorsInSelectionRectangle(TSubclassOf<class AActor> ClassFilter, const FVector2D& FirstPoint, const FVector2D& SecondPoint, TArray<class AActor*>& OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed);
    void DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition);
    void DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, FLinearColor TintColor, TEnumAsByte<EBlendMode> BlendMode, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawText(FString Text, FLinearColor TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition);
    void DrawRect(FLinearColor RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH);
    void DrawMaterialTriangle(class UMaterialInterface* Material, FVector2D V0_Pos, FVector2D V1_Pos, FVector2D V2_Pos, FVector2D V0_UV, FVector2D V1_UV, FVector2D V2_UV, FLinearColor V0_Color, FLinearColor V1_Color, FLinearColor V2_Color);
    void DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition);
    void DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, FLinearColor LineColor, float LineThickness);
    void Deproject(float ScreenX, float ScreenY, FVector& WorldPosition, FVector& WorldDirection);
    void AddHitBox(FVector2D Position, FVector2D Size, FName InName, bool bConsumesInput, int32 Priority);
    void AddDebugText(FString DebugText, class AActor* SrcActor, float Duration, FVector Offset, FVector DesiredOffset, FColor TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow);
}; // Size: 0x318

struct FCollisionProfileName
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSoundConcurrencySettings
{
    int32 MaxCount;                                                                   // 0x0000 (size: 0x4)
    uint8 bLimitToOwner;                                                              // 0x0004 (size: 0x1)
    TEnumAsByte<EMaxConcurrentResolutionRule::Type> ResolutionRule;                   // 0x0008 (size: 0x1)
    float RetriggerTime;                                                              // 0x000C (size: 0x4)
    float VolumeScale;                                                                // 0x0010 (size: 0x4)
    EConcurrencyVolumeScaleMode VolumeScaleMode;                                      // 0x0014 (size: 0x4)
    float VolumeScaleAttackTime;                                                      // 0x0018 (size: 0x4)
    uint8 bVolumeScaleCanRelease;                                                     // 0x001C (size: 0x1)
    float VolumeScaleReleaseTime;                                                     // 0x0020 (size: 0x4)
    float VoiceStealReleaseTime;                                                      // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FSoundSubmixSendInfo
{
    ESendLevelControlMethod SendLevelControlMethod;                                   // 0x0000 (size: 0x1)
    ESubmixSendStage SendStage;                                                       // 0x0001 (size: 0x1)
    class USoundSubmixBase* SoundSubmix;                                              // 0x0008 (size: 0x8)
    float SendLevel;                                                                  // 0x0010 (size: 0x4)
    float MinSendLevel;                                                               // 0x0014 (size: 0x4)
    float MaxSendLevel;                                                               // 0x0018 (size: 0x4)
    float MinSendDistance;                                                            // 0x001C (size: 0x4)
    float MaxSendDistance;                                                            // 0x0020 (size: 0x4)
    FRuntimeFloatCurve CustomSendLevelCurve;                                          // 0x0028 (size: 0x88)

}; // Size: 0xB0

struct FSoundSourceBusSendInfo
{
    ESourceBusSendLevelControlMethod SourceBusSendLevelControlMethod;                 // 0x0000 (size: 0x1)
    class USoundSourceBus* SoundSourceBus;                                            // 0x0008 (size: 0x8)
    class UAudioBus* AudioBus;                                                        // 0x0010 (size: 0x8)
    float SendLevel;                                                                  // 0x0018 (size: 0x4)
    float MinSendLevel;                                                               // 0x001C (size: 0x4)
    float MaxSendLevel;                                                               // 0x0020 (size: 0x4)
    float MinSendDistance;                                                            // 0x0024 (size: 0x4)
    float MaxSendDistance;                                                            // 0x0028 (size: 0x4)
    FRuntimeFloatCurve CustomSendLevelCurve;                                          // 0x0030 (size: 0x88)

}; // Size: 0xB8

class USoundBase : public UObject
{
    class USoundClass* SoundClassObject;                                              // 0x0030 (size: 0x8)
    uint8 bDebug;                                                                     // 0x0038 (size: 0x1)
    uint8 bOverrideConcurrency;                                                       // 0x0038 (size: 0x1)
    uint8 bEnableBusSends;                                                            // 0x0038 (size: 0x1)
    uint8 bEnableBaseSubmix;                                                          // 0x0038 (size: 0x1)
    uint8 bEnableSubmixSends;                                                         // 0x0038 (size: 0x1)
    uint8 bHasDelayNode;                                                              // 0x0038 (size: 0x1)
    uint8 bHasConcatenatorNode;                                                       // 0x0038 (size: 0x1)
    uint8 bBypassVolumeScaleForPriority;                                              // 0x0038 (size: 0x1)
    EVirtualizationMode VirtualizationMode;                                           // 0x0039 (size: 0x1)
    TSet<USoundConcurrency*> ConcurrencySet;                                          // 0x0090 (size: 0x50)
    FSoundConcurrencySettings ConcurrencyOverrides;                                   // 0x00E0 (size: 0x28)
    float Duration;                                                                   // 0x0108 (size: 0x4)
    float MaxDistance;                                                                // 0x010C (size: 0x4)
    float TotalSamples;                                                               // 0x0110 (size: 0x4)
    float Priority;                                                                   // 0x0114 (size: 0x4)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0118 (size: 0x8)
    class USoundSubmixBase* SoundSubmixObject;                                        // 0x0120 (size: 0x8)
    TArray<FSoundSubmixSendInfo> SoundSubmixSends;                                    // 0x0128 (size: 0x10)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0138 (size: 0x8)
    TArray<FSoundSourceBusSendInfo> BusSends;                                         // 0x0140 (size: 0x10)
    TArray<FSoundSourceBusSendInfo> PreEffectBusSends;                                // 0x0150 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0160 (size: 0x10)

}; // Size: 0x170

struct FTableRowBase
{
}; // Size: 0x8

struct FBaseAttenuationSettings
{
    EAttenuationDistanceModel DistanceAlgorithm;                                      // 0x0008 (size: 0x1)
    TEnumAsByte<EAttenuationShape::Type> AttenuationShape;                            // 0x0009 (size: 0x1)
    float dBAttenuationAtMax;                                                         // 0x000C (size: 0x4)
    ENaturalSoundFalloffMode FalloffMode;                                             // 0x0010 (size: 0x1)
    FVector AttenuationShapeExtents;                                                  // 0x0014 (size: 0xC)
    float ConeOffset;                                                                 // 0x0020 (size: 0x4)
    float FalloffDistance;                                                            // 0x0024 (size: 0x4)
    FRuntimeFloatCurve CustomAttenuationCurve;                                        // 0x0028 (size: 0x88)

}; // Size: 0xB0

struct FAttenuationSubmixSendSettings
{
    class USoundSubmixBase* Submix;                                                   // 0x0000 (size: 0x8)
    ESubmixSendMethod SubmixSendMethod;                                               // 0x0008 (size: 0x1)
    float SubmixSendLevelMin;                                                         // 0x000C (size: 0x4)
    float SubmixSendLevelMax;                                                         // 0x0010 (size: 0x4)
    float SubmixSendDistanceMin;                                                      // 0x0014 (size: 0x4)
    float SubmixSendDistanceMax;                                                      // 0x0018 (size: 0x4)
    float ManualSubmixSendLevel;                                                      // 0x001C (size: 0x4)
    FRuntimeFloatCurve CustomSubmixSendCurve;                                         // 0x0020 (size: 0x88)

}; // Size: 0xA8

struct FSoundAttenuationPluginSettings
{
    TArray<class USpatializationPluginSourceSettingsBase*> SpatializationPluginSettingsArray; // 0x0000 (size: 0x10)
    TArray<class UOcclusionPluginSourceSettingsBase*> OcclusionPluginSettingsArray;   // 0x0010 (size: 0x10)
    TArray<class UReverbPluginSourceSettingsBase*> ReverbPluginSettingsArray;         // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSoundAttenuationSettings : public FBaseAttenuationSettings
{
    uint8 bAttenuate;                                                                 // 0x00B0 (size: 0x1)
    uint8 bSpatialize;                                                                // 0x00B0 (size: 0x1)
    uint8 bAttenuateWithLPF;                                                          // 0x00B0 (size: 0x1)
    uint8 bEnableListenerFocus;                                                       // 0x00B0 (size: 0x1)
    uint8 bEnableFocusInterpolation;                                                  // 0x00B0 (size: 0x1)
    uint8 bEnableOcclusion;                                                           // 0x00B0 (size: 0x1)
    uint8 bUseComplexCollisionForOcclusion;                                           // 0x00B0 (size: 0x1)
    uint8 bEnableReverbSend;                                                          // 0x00B0 (size: 0x1)
    uint8 bEnablePriorityAttenuation;                                                 // 0x00B1 (size: 0x1)
    uint8 bApplyNormalizationToStereoSounds;                                          // 0x00B1 (size: 0x1)
    uint8 bEnableLogFrequencyScaling;                                                 // 0x00B1 (size: 0x1)
    uint8 bEnableSubmixSends;                                                         // 0x00B1 (size: 0x1)
    TEnumAsByte<ESoundSpatializationAlgorithm> SpatializationAlgorithm;               // 0x00B2 (size: 0x1)
    float BinauralRadius;                                                             // 0x00B4 (size: 0x4)
    EAirAbsorptionMethod AbsorptionMethod;                                            // 0x00B8 (size: 0x1)
    TEnumAsByte<ECollisionChannel> OcclusionTraceChannel;                             // 0x00B9 (size: 0x1)
    EReverbSendMethod ReverbSendMethod;                                               // 0x00BA (size: 0x1)
    EPriorityAttenuationMethod PriorityAttenuationMethod;                             // 0x00BB (size: 0x1)
    float OmniRadius;                                                                 // 0x00BC (size: 0x4)
    float StereoSpread;                                                               // 0x00C0 (size: 0x4)
    float LPFRadiusMin;                                                               // 0x00C4 (size: 0x4)
    float LPFRadiusMax;                                                               // 0x00C8 (size: 0x4)
    FRuntimeFloatCurve CustomLowpassAirAbsorptionCurve;                               // 0x00D0 (size: 0x88)
    FRuntimeFloatCurve CustomHighpassAirAbsorptionCurve;                              // 0x0158 (size: 0x88)
    float LPFFrequencyAtMin;                                                          // 0x01E0 (size: 0x4)
    float LPFFrequencyAtMax;                                                          // 0x01E4 (size: 0x4)
    float HPFFrequencyAtMin;                                                          // 0x01E8 (size: 0x4)
    float HPFFrequencyAtMax;                                                          // 0x01EC (size: 0x4)
    float FocusAzimuth;                                                               // 0x01F0 (size: 0x4)
    float NonFocusAzimuth;                                                            // 0x01F4 (size: 0x4)
    float FocusDistanceScale;                                                         // 0x01F8 (size: 0x4)
    float NonFocusDistanceScale;                                                      // 0x01FC (size: 0x4)
    float FocusPriorityScale;                                                         // 0x0200 (size: 0x4)
    float NonFocusPriorityScale;                                                      // 0x0204 (size: 0x4)
    float FocusVolumeAttenuation;                                                     // 0x0208 (size: 0x4)
    float NonFocusVolumeAttenuation;                                                  // 0x020C (size: 0x4)
    float FocusAttackInterpSpeed;                                                     // 0x0210 (size: 0x4)
    float FocusReleaseInterpSpeed;                                                    // 0x0214 (size: 0x4)
    float OcclusionLowPassFilterFrequency;                                            // 0x0218 (size: 0x4)
    float OcclusionVolumeAttenuation;                                                 // 0x021C (size: 0x4)
    float OcclusionInterpolationTime;                                                 // 0x0220 (size: 0x4)
    float ReverbWetLevelMin;                                                          // 0x0224 (size: 0x4)
    float ReverbWetLevelMax;                                                          // 0x0228 (size: 0x4)
    float ReverbDistanceMin;                                                          // 0x022C (size: 0x4)
    float ReverbDistanceMax;                                                          // 0x0230 (size: 0x4)
    float ManualReverbSendLevel;                                                      // 0x0234 (size: 0x4)
    FRuntimeFloatCurve CustomReverbSendCurve;                                         // 0x0238 (size: 0x88)
    TArray<FAttenuationSubmixSendSettings> SubmixSendSettings;                        // 0x02C0 (size: 0x10)
    float PriorityAttenuationMin;                                                     // 0x02D0 (size: 0x4)
    float PriorityAttenuationMax;                                                     // 0x02D4 (size: 0x4)
    float PriorityAttenuationDistanceMin;                                             // 0x02D8 (size: 0x4)
    float PriorityAttenuationDistanceMax;                                             // 0x02DC (size: 0x4)
    float ManualPriorityAttenuation;                                                  // 0x02E0 (size: 0x4)
    FRuntimeFloatCurve CustomPriorityAttenuationCurve;                                // 0x02E8 (size: 0x88)
    FSoundAttenuationPluginSettings PluginSettings;                                   // 0x0370 (size: 0x30)

}; // Size: 0x3A0

class USoundEffectPreset : public UObject
{
}; // Size: 0x68

class USoundEffectSourcePreset : public USoundEffectPreset
{
}; // Size: 0x68

struct FSoundModulationDestinationSettings
{
    float Value;                                                                      // 0x0000 (size: 0x4)
    class USoundModulatorBase* Modulator;                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

class USoundEffectSubmixPreset : public USoundEffectPreset
{
}; // Size: 0x68

class UExporter : public UObject
{
    UClass* SupportedClass;                                                           // 0x0028 (size: 0x8)
    class UObject* ExportRootScope;                                                   // 0x0030 (size: 0x8)
    TArray<FString> FormatExtension;                                                  // 0x0038 (size: 0x10)
    TArray<FString> FormatDescription;                                                // 0x0048 (size: 0x10)
    int32 PreferredFormatIndex;                                                       // 0x0058 (size: 0x4)
    int32 TextIndent;                                                                 // 0x005C (size: 0x4)
    uint8 bText;                                                                      // 0x0060 (size: 0x1)
    uint8 bSelectedOnly;                                                              // 0x0060 (size: 0x1)
    uint8 bForceFileOperations;                                                       // 0x0060 (size: 0x1)
    class UAssetExportTask* ExportTask;                                               // 0x0068 (size: 0x8)

    bool ScriptRunAssetExportTask(class UAssetExportTask* Task);
    bool RunAssetExportTasks(const TArray<class UAssetExportTask*>& ExportTasks);
    bool RunAssetExportTask(class UAssetExportTask* Task);
}; // Size: 0x78

class UPlayer : public UObject
{
    class APlayerController* PlayerController;                                        // 0x0030 (size: 0x8)
    int32 CurrentNetSpeed;                                                            // 0x0038 (size: 0x4)
    int32 ConfiguredInternetSpeed;                                                    // 0x003C (size: 0x4)
    int32 ConfiguredLanSpeed;                                                         // 0x0040 (size: 0x4)

}; // Size: 0x48

class UNetConnection : public UPlayer
{
    TArray<class UChildConnection*> Children;                                         // 0x0048 (size: 0x10)
    class UNetDriver* Driver;                                                         // 0x0058 (size: 0x8)
    TSubclassOf<class UPackageMap> PackageMapClass;                                   // 0x0060 (size: 0x8)
    class UPackageMap* PackageMap;                                                    // 0x0068 (size: 0x8)
    TArray<class UChannel*> OpenChannels;                                             // 0x0070 (size: 0x10)
    TArray<class AActor*> SentTemporaries;                                            // 0x0080 (size: 0x10)
    class AActor* ViewTarget;                                                         // 0x0090 (size: 0x8)
    class AActor* OwningActor;                                                        // 0x0098 (size: 0x8)
    int32 MaxPacket;                                                                  // 0x00A0 (size: 0x4)
    uint8 InternalAck;                                                                // 0x00A4 (size: 0x1)
    FUniqueNetIdRepl PlayerId;                                                        // 0x0160 (size: 0x28)
    double LastReceiveTime;                                                           // 0x01D0 (size: 0x8)
    TArray<class UChannel*> ChannelsToTick;                                           // 0x1510 (size: 0x10)

}; // Size: 0x1BA8

struct FChannelDefinition
{
    FName ChannelName;                                                                // 0x0000 (size: 0x8)
    FName ClassName;                                                                  // 0x0008 (size: 0x8)
    UClass* ChannelClass;                                                             // 0x0010 (size: 0x8)
    int32 StaticChannelIndex;                                                         // 0x0018 (size: 0x4)
    bool bTickOnCreate;                                                               // 0x001C (size: 0x1)
    bool bServerOpen;                                                                 // 0x001D (size: 0x1)
    bool bClientOpen;                                                                 // 0x001E (size: 0x1)
    bool bInitialServer;                                                              // 0x001F (size: 0x1)
    bool bInitialClient;                                                              // 0x0020 (size: 0x1)

}; // Size: 0x28

class UNetDriver : public UObject
{
    FString NetConnectionClassName;                                                   // 0x0030 (size: 0x10)
    FString ReplicationDriverClassName;                                               // 0x0040 (size: 0x10)
    int32 MaxDownloadSize;                                                            // 0x0050 (size: 0x4)
    uint8 bClampListenServerTickRate;                                                 // 0x0054 (size: 0x1)
    int32 NetServerMaxTickRate;                                                       // 0x0058 (size: 0x4)
    int32 MaxNetTickRate;                                                             // 0x005C (size: 0x4)
    int32 MaxInternetClientRate;                                                      // 0x0060 (size: 0x4)
    int32 MaxClientRate;                                                              // 0x0064 (size: 0x4)
    float ServerTravelPause;                                                          // 0x0068 (size: 0x4)
    float SpawnPrioritySeconds;                                                       // 0x006C (size: 0x4)
    float RelevantTimeout;                                                            // 0x0070 (size: 0x4)
    float KeepAliveTime;                                                              // 0x0074 (size: 0x4)
    float InitialConnectTimeout;                                                      // 0x0078 (size: 0x4)
    float ConnectionTimeout;                                                          // 0x007C (size: 0x4)
    float TimeoutMultiplierForUnoptimizedBuilds;                                      // 0x0080 (size: 0x4)
    bool bNoTimeouts;                                                                 // 0x0084 (size: 0x1)
    bool bNeverApplyNetworkEmulationSettings;                                         // 0x0085 (size: 0x1)
    class UNetConnection* ServerConnection;                                           // 0x0088 (size: 0x8)
    TArray<class UNetConnection*> ClientConnections;                                  // 0x0090 (size: 0x10)
    int32 RecentlyDisconnectedTrackingTime;                                           // 0x0100 (size: 0x4)
    class UWorld* World;                                                              // 0x0140 (size: 0x8)
    class UPackage* WorldPackage;                                                     // 0x0148 (size: 0x8)
    UClass* NetConnectionClass;                                                       // 0x0170 (size: 0x8)
    UClass* ReplicationDriverClass;                                                   // 0x0178 (size: 0x8)
    FName NetDriverName;                                                              // 0x0190 (size: 0x8)
    TArray<FChannelDefinition> ChannelDefinitions;                                    // 0x0198 (size: 0x10)
    TMap<class FName, class FChannelDefinition> ChannelDefinitionMap;                 // 0x01A8 (size: 0x50)
    TArray<class UChannel*> ActorChannelPool;                                         // 0x01F8 (size: 0x10)
    float Time;                                                                       // 0x0210 (size: 0x4)
    class UReplicationDriver* ReplicationDriver;                                      // 0x0700 (size: 0x8)

}; // Size: 0x760

class UOnlineBlueprintCallProxyBase : public UBlueprintAsyncActionBase
{
}; // Size: 0x30

class UOnlineEngineInterface : public UObject
{
}; // Size: 0x28

class UOnlineSession : public UObject
{
}; // Size: 0x28

class UTexture : public UStreamableRenderAsset
{
    FGuid LightingGuid;                                                               // 0x0068 (size: 0x10)
    int32 LODBias;                                                                    // 0x0078 (size: 0x4)
    TEnumAsByte<TextureCompressionSettings> CompressionSettings;                      // 0x007C (size: 0x1)
    TEnumAsByte<TextureFilter> Filter;                                                // 0x007D (size: 0x1)
    ETextureMipLoadOptions MipLoadOptions;                                            // 0x007E (size: 0x1)
    TEnumAsByte<TextureGroup> LODGroup;                                               // 0x007F (size: 0x1)
    FPerPlatformFloat Downscale;                                                      // 0x0080 (size: 0x4)
    ETextureDownscaleOptions DownscaleOptions;                                        // 0x0084 (size: 0x1)
    uint8 sRGB;                                                                       // 0x0085 (size: 0x1)
    uint8 bNoTiling;                                                                  // 0x0085 (size: 0x1)
    uint8 VirtualTextureStreaming;                                                    // 0x0085 (size: 0x1)
    uint8 CompressionYCoCg;                                                           // 0x0085 (size: 0x1)
    uint8 bNotOfflineProcessed;                                                       // 0x0085 (size: 0x1)
    uint8 bAsyncResourceReleaseHasBeenStarted;                                        // 0x0085 (size: 0x1)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0088 (size: 0x10)

}; // Size: 0x180

struct FKShapeElem
{
    float RestOffset;                                                                 // 0x0008 (size: 0x4)
    FName Name;                                                                       // 0x000C (size: 0x8)
    uint8 bContributeToMass;                                                          // 0x0018 (size: 0x1)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0019 (size: 0x1)

}; // Size: 0x30

struct FKConvexElem : public FKShapeElem
{
    TArray<FVector> VertexData;                                                       // 0x0030 (size: 0x10)
    TArray<int32> IndexData;                                                          // 0x0040 (size: 0x10)
    FBox ElemBox;                                                                     // 0x0050 (size: 0x1C)
    FTransform Transform;                                                             // 0x0070 (size: 0x30)

}; // Size: 0xB0

struct FSingleAnimationPlayData
{
    class UAnimationAsset* AnimToPlay;                                                // 0x0000 (size: 0x8)
    uint8 bSavedLooping;                                                              // 0x0008 (size: 0x1)
    uint8 bSavedPlaying;                                                              // 0x0008 (size: 0x1)
    float SavedPosition;                                                              // 0x000C (size: 0x4)
    float SavedPlayRate;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FPoseSnapshot
{
    TArray<FTransform> LocalTransforms;                                               // 0x0000 (size: 0x10)
    TArray<FName> BoneNames;                                                          // 0x0010 (size: 0x10)
    FName SkeletalMeshName;                                                           // 0x0020 (size: 0x8)
    FName SnapshotName;                                                               // 0x0028 (size: 0x8)
    bool bIsValid;                                                                    // 0x0030 (size: 0x1)

}; // Size: 0x38

class USkeletalMeshComponent : public USkinnedMeshComponent
{
    UClass* AnimBlueprintGeneratedClass;                                              // 0x06A0 (size: 0x8)
    TSubclassOf<class UAnimInstance> AnimClass;                                       // 0x06A8 (size: 0x8)
    class UAnimInstance* AnimScriptInstance;                                          // 0x06B0 (size: 0x8)
    class UAnimInstance* PostProcessAnimInstance;                                     // 0x06B8 (size: 0x8)
    FSingleAnimationPlayData AnimationData;                                           // 0x06C0 (size: 0x18)
    FVector RootBoneTranslation;                                                      // 0x06E8 (size: 0xC)
    FVector LineCheckBoundsScale;                                                     // 0x06F4 (size: 0xC)
    TArray<class UAnimInstance*> LinkedInstances;                                     // 0x0730 (size: 0x10)
    TArray<FTransform> CachedBoneSpaceTransforms;                                     // 0x0740 (size: 0x10)
    TArray<FTransform> CachedComponentSpaceTransforms;                                // 0x0750 (size: 0x10)
    float GlobalAnimRateScale;                                                        // 0x08B0 (size: 0x4)
    TEnumAsByte<EKinematicBonesUpdateToPhysics::Type> KinematicBonesUpdateType;       // 0x08B4 (size: 0x1)
    TEnumAsByte<EPhysicsTransformUpdateMode::Type> PhysicsTransformUpdateMode;        // 0x08B5 (size: 0x1)
    TEnumAsByte<EAnimationMode::Type> AnimationMode;                                  // 0x08B7 (size: 0x1)
    uint8 bDisablePostProcessBlueprint;                                               // 0x08B9 (size: 0x1)
    uint8 bUpdateOverlapsOnAnimationFinalize;                                         // 0x08B9 (size: 0x1)
    uint8 bHasValidBodies;                                                            // 0x08B9 (size: 0x1)
    uint8 bBlendPhysics;                                                              // 0x08B9 (size: 0x1)
    uint8 bEnablePhysicsOnDedicatedServer;                                            // 0x08B9 (size: 0x1)
    uint8 bUpdateJointsFromAnimation;                                                 // 0x08B9 (size: 0x1)
    uint8 bDisableClothSimulation;                                                    // 0x08BA (size: 0x1)
    uint8 bDisableRigidBodyAnimNode;                                                  // 0x08C0 (size: 0x1)
    uint8 bAllowAnimCurveEvaluation;                                                  // 0x08C0 (size: 0x1)
    uint8 bDisableAnimCurves;                                                         // 0x08C0 (size: 0x1)
    uint8 bCollideWithEnvironment;                                                    // 0x08C0 (size: 0x1)
    uint8 bCollideWithAttachedChildren;                                               // 0x08C1 (size: 0x1)
    uint8 bLocalSpaceSimulation;                                                      // 0x08C1 (size: 0x1)
    uint8 bResetAfterTeleport;                                                        // 0x08C1 (size: 0x1)
    uint8 bDeferKinematicBoneUpdate;                                                  // 0x08C1 (size: 0x1)
    uint8 bNoSkeletonUpdate;                                                          // 0x08C1 (size: 0x1)
    uint8 bPauseAnims;                                                                // 0x08C1 (size: 0x1)
    uint8 bUseRefPoseOnInitAnim;                                                      // 0x08C1 (size: 0x1)
    uint8 bEnablePerPolyCollision;                                                    // 0x08C2 (size: 0x1)
    uint8 bForceRefpose;                                                              // 0x08C2 (size: 0x1)
    uint8 bOnlyAllowAutonomousTickPose;                                               // 0x08C2 (size: 0x1)
    uint8 bIsAutonomousTickPose;                                                      // 0x08C2 (size: 0x1)
    uint8 bOldForceRefPose;                                                           // 0x08C2 (size: 0x1)
    uint8 bShowPrePhysBones;                                                          // 0x08C2 (size: 0x1)
    uint8 bRequiredBonesUpToDate;                                                     // 0x08C2 (size: 0x1)
    uint8 bAnimTreeInitialised;                                                       // 0x08C2 (size: 0x1)
    uint8 bIncludeComponentLocationIntoBounds;                                        // 0x08C3 (size: 0x1)
    uint8 bEnableLineCheckWithBounds;                                                 // 0x08C3 (size: 0x1)
    uint8 bPropagateCurvesToSlaves;                                                   // 0x08C3 (size: 0x1)
    uint8 bSkipKinematicUpdateWhenInterpolating;                                      // 0x08C3 (size: 0x1)
    uint8 bSkipBoundsUpdateWhenInterpolating;                                         // 0x08C3 (size: 0x1)
    uint8 bNeedsQueuedAnimEventsDispatched;                                           // 0x08C3 (size: 0x1)
    uint16 CachedAnimCurveUidVersion;                                                 // 0x08C6 (size: 0x2)
    float ClothBlendWeight;                                                           // 0x08C8 (size: 0x4)
    bool bWaitForParallelClothTask;                                                   // 0x08CC (size: 0x1)
    TArray<FName> DisallowedAnimCurves;                                               // 0x08D0 (size: 0x10)
    class UBodySetup* BodySetup;                                                      // 0x08E0 (size: 0x8)
    FSkeletalMeshComponentOnConstraintBroken OnConstraintBroken;                      // 0x08F0 (size: 0x10)
    void ConstraintBrokenSignature(int32 ConstraintIndex);
    TSubclassOf<class UClothingSimulationFactory> ClothingSimulationFactory;          // 0x0900 (size: 0x8)
    float TeleportDistanceThreshold;                                                  // 0x09D8 (size: 0x4)
    float TeleportRotationThreshold;                                                  // 0x09DC (size: 0x4)
    uint32 LastPoseTickFrame;                                                         // 0x09E8 (size: 0x4)
    class UClothingSimulationInteractor* ClothingInteractor;                          // 0x0A40 (size: 0x8)
    FSkeletalMeshComponentOnAnimInitialized OnAnimInitialized;                        // 0x0B10 (size: 0x10)
    void OnAnimInitialized();

    void UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    void UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace);
    void ToggleDisablePostProcessBlueprint();
    void TermBodiesBelow(FName ParentBoneName);
    void SuspendClothingSimulation();
    void Stop();
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void SetUpdateClothInEditor(const bool NewUpdateState);
    void SetUpdateAnimationInEditor(const bool NewUpdateState);
    void SetTeleportRotationThreshold(float Threshold);
    void SetTeleportDistanceThreshold(float Threshold);
    void SetPosition(float InPos, bool bFireNotifies);
    void SetPlayRate(float Rate);
    void SetPhysicsBlendWeight(float PhysicsBlendWeight);
    void SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, FName BoneName, bool bIncludeSelf);
    void SetMorphTarget(FName MorphTargetName, float Value, bool bRemoveZeroWeight);
    void SetEnablePhysicsBlending(bool bNewBlendPhysics);
    void SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, FName BoneName, bool bIncludeSelf);
    void SetEnableBodyGravity(bool bEnableGravity, FName BoneName);
    void SetDisablePostProcessBlueprint(bool bInDisablePostProcess);
    void SetDisableAnimCurves(bool bInDisableAnimCurves);
    void SetConstraintProfileForAll(FName ProfileName, bool bDefaultIfNotFound);
    void SetConstraintProfile(FName JointName, FName ProfileName, bool bDefaultIfNotFound);
    void SetClothMaxDistanceScale(float Scale);
    void SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, FName BoneName);
    void SetAnimClass(UClass* NewClass);
    void SetAnimationMode(TEnumAsByte<EAnimationMode::Type> InAnimationMode);
    void SetAnimation(class UAnimationAsset* NewAnimToPlay);
    void SetAngularLimits(FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle);
    void SetAllowRigidBodyAnimNode(bool bInAllow, bool bReinitAnim);
    void SetAllowedAnimCurvesEvaluation(const TArray<FName>& List, bool bAllow);
    void SetAllowAnimCurveEvaluation(bool bInAllow);
    void SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType);
    void SetAllBodiesSimulatePhysics(bool bNewSimulate);
    void SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType);
    void SetAllBodiesBelowSimulatePhysics(const FName& InBoneName, bool bNewSimulate, bool bIncludeSelf);
    void SetAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf);
    void ResumeClothingSimulation();
    void ResetClothTeleportMode();
    void ResetAnimInstanceDynamics(ETeleportType InTeleportType);
    void ResetAllowedAnimCurveEvaluation();
    void ResetAllBodiesSimulatePhysics();
    void PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping);
    void Play(bool bLooping);
    void OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate);
    void LinkAnimGraphByTag(FName InTag, TSubclassOf<class UAnimInstance> InClass);
    void LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    bool K2_GetClosestPointOnPhysicsAsset(const FVector& WorldPosition, FVector& ClosestWorldPosition, FVector& Normal, FName& BoneName, float& Distance);
    bool IsPlaying();
    bool IsClothingSimulationSuspended();
    bool IsBodyGravityEnabled(FName BoneName);
    bool HasValidAnimationInstance();
    float GetTeleportRotationThreshold();
    float GetTeleportDistanceThreshold();
    bool GetStringAttribute_Ref(const FName& BoneName, const FName& AttributeName, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetStringAttribute(const FName& BoneName, const FName& AttributeName, FString DefaultValue, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    FVector GetSkeletalCenterOfMass();
    class UAnimInstance* GetPostProcessInstance();
    float GetPosition();
    float GetPlayRate();
    float GetMorphTarget(FName MorphTargetName);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup);
    class UAnimInstance* GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass);
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag);
    bool GetIntegerAttribute_Ref(const FName& BoneName, const FName& AttributeName, int32& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetIntegerAttribute(const FName& BoneName, const FName& AttributeName, int32 DefaultValue, int32& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetFloatAttribute_Ref(const FName& BoneName, const FName& AttributeName, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetFloatAttribute(const FName& BoneName, const FName& AttributeName, float DefaultValue, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetDisablePostProcessBlueprint();
    bool GetDisableAnimCurves();
    void GetCurrentJointAngles(FName InBoneName, float& Swing1Angle, float& TwistAngle, float& Swing2Angle);
    float GetClothMaxDistanceScale();
    class UClothingSimulationInteractor* GetClothingSimulationInteractor();
    float GetBoneMass(FName BoneName, bool bScaleMass);
    class UAnimInstance* GetAnimInstance();
    UClass* GetAnimClass();
    TEnumAsByte<EAnimationMode::Type> GetAnimationMode();
    bool GetAllowRigidBodyAnimNode();
    bool GetAllowedAnimCurveEvaluate();
    void ForceClothNextUpdateTeleportAndReset();
    void ForceClothNextUpdateTeleport();
    FName FindConstraintBoneName(int32 ConstraintIndex);
    void ClearMorphTargets();
    void BreakConstraint(FVector Impulse, FVector HitLocation, FName InBoneName);
    void BindClothToMasterPoseComponent();
    void AllowAnimCurveEvaluation(FName NameOfCurve, bool bAllow);
    void AddImpulseToAllBodiesBelow(FVector Impulse, FName BoneName, bool bVelChange, bool bIncludeSelf);
    void AddForceToAllBodiesBelow(FVector Force, FName BoneName, bool bAccelChange, bool bIncludeSelf);
    void AccumulateAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType);
}; // Size: 0xED0

struct FAnimNotifyEventReference
{
    class UObject* NotifySource;                                                      // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAnimNotifyArray
{
    TArray<FAnimNotifyEventReference> Notifies;                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnimNotifyQueue
{
    TArray<FAnimNotifyEventReference> AnimNotifies;                                   // 0x0010 (size: 0x10)
    TMap<class FName, class FAnimNotifyArray> UnfilteredMontageAnimNotifies;          // 0x0020 (size: 0x50)

}; // Size: 0x70

struct FAnimLinkableElement
{
    class UAnimMontage* LinkedMontage;                                                // 0x0008 (size: 0x8)
    int32 SlotIndex;                                                                  // 0x0010 (size: 0x4)
    int32 SegmentIndex;                                                               // 0x0014 (size: 0x4)
    TEnumAsByte<EAnimLinkMethod::Type> LinkMethod;                                    // 0x0018 (size: 0x1)
    TEnumAsByte<EAnimLinkMethod::Type> CachedLinkMethod;                              // 0x0019 (size: 0x1)
    float SegmentBeginTime;                                                           // 0x001C (size: 0x4)
    float SegmentLength;                                                              // 0x0020 (size: 0x4)
    float LinkValue;                                                                  // 0x0024 (size: 0x4)
    class UAnimSequenceBase* LinkedSequence;                                          // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FAnimNotifyEvent : public FAnimLinkableElement
{
    float DisplayTime;                                                                // 0x0030 (size: 0x4)
    float TriggerTimeOffset;                                                          // 0x0034 (size: 0x4)
    float EndTriggerTimeOffset;                                                       // 0x0038 (size: 0x4)
    float TriggerWeightThreshold;                                                     // 0x003C (size: 0x4)
    FName NotifyName;                                                                 // 0x0040 (size: 0x8)
    class UAnimNotify* Notify;                                                        // 0x0048 (size: 0x8)
    class UAnimNotifyState* NotifyStateClass;                                         // 0x0050 (size: 0x8)
    float Duration;                                                                   // 0x0058 (size: 0x4)
    FAnimLinkableElement EndLink;                                                     // 0x0060 (size: 0x30)
    bool bConvertedFromBranchingPoint;                                                // 0x0090 (size: 0x1)
    TEnumAsByte<EMontageNotifyTickType::Type> MontageTickType;                        // 0x0091 (size: 0x1)
    float NotifyTriggerChance;                                                        // 0x0094 (size: 0x4)
    TEnumAsByte<ENotifyFilterType::Type> NotifyFilterType;                            // 0x0098 (size: 0x1)
    int32 NotifyFilterLOD;                                                            // 0x009C (size: 0x4)
    bool bTriggerOnDedicatedServer;                                                   // 0x00A0 (size: 0x1)
    bool bTriggerOnFollower;                                                          // 0x00A1 (size: 0x1)
    int32 TrackIndex;                                                                 // 0x00A4 (size: 0x4)

}; // Size: 0xB8

struct FMarkerSyncAnimPosition
{
    FName PreviousMarkerName;                                                         // 0x0000 (size: 0x8)
    FName NextMarkerName;                                                             // 0x0008 (size: 0x8)
    float PositionBetweenMarkers;                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

class UAnimInstance : public UObject
{
    class USkeleton* CurrentSkeleton;                                                 // 0x0028 (size: 0x8)
    TEnumAsByte<ERootMotionMode::Type> RootMotionMode;                                // 0x0030 (size: 0x1)
    uint8 bUseMultiThreadedAnimationUpdate;                                           // 0x0031 (size: 0x1)
    uint8 bUsingCopyPoseFromMesh;                                                     // 0x0031 (size: 0x1)
    uint8 bReceiveNotifiesFromLinkedInstances;                                        // 0x0031 (size: 0x1)
    uint8 bPropagateNotifiesToLinkedInstances;                                        // 0x0031 (size: 0x1)
    uint8 bQueueMontageEvents;                                                        // 0x0031 (size: 0x1)
    FAnimInstanceOnMontageBlendingOut OnMontageBlendingOut;                           // 0x0038 (size: 0x10)
    void OnMontageBlendingOutStartedMCDelegate(class UAnimMontage* Montage, bool bInterrupted);
    FAnimInstanceOnMontageStarted OnMontageStarted;                                   // 0x0048 (size: 0x10)
    void OnMontageStartedMCDelegate(class UAnimMontage* Montage);
    FAnimInstanceOnMontageEnded OnMontageEnded;                                       // 0x0058 (size: 0x10)
    void OnMontageEndedMCDelegate(class UAnimMontage* Montage, bool bInterrupted);
    FAnimInstanceOnAllMontageInstancesEnded OnAllMontageInstancesEnded;               // 0x0068 (size: 0x10)
    void OnAllMontageInstancesEndedMCDelegate();
    FAnimNotifyQueue NotifyQueue;                                                     // 0x0100 (size: 0x70)
    TArray<FAnimNotifyEvent> ActiveAnimNotifyState;                                   // 0x0170 (size: 0x10)

    void UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic);
    void UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    class APawn* TryGetPawnOwner();
    void StopSlotAnimation(float InBlendOutTime, FName SlotNodeName);
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void SetRootMotionMode(TEnumAsByte<ERootMotionMode::Type> Value);
    void SetReceiveNotifiesFromLinkedInstances(bool bSet);
    void SetPropagateNotifiesToLinkedInstances(bool bSet);
    void SetMorphTarget(FName MorphTargetName, float Value);
    void SavePoseSnapshot(FName SnapshotName);
    void ResetDynamics(ETeleportType InTeleportType);
    class UAnimMontage* PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, FName SlotNodeName, float blendInTime, float blendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
    float PlaySlotAnimation(class UAnimSequenceBase* Asset, FName SlotNodeName, float blendInTime, float blendOutTime, float InPlayRate, int32 LoopCount);
    void Montage_StopGroupByName(float InBlendOutTime, FName GroupName);
    void Montage_Stop(float InBlendOutTime, const class UAnimMontage* Montage);
    void Montage_SetPosition(const class UAnimMontage* Montage, float newPosition);
    void Montage_SetPlayRate(const class UAnimMontage* Montage, float NewPlayRate);
    void Montage_SetNextSection(FName SectionNameToChange, FName NextSection, const class UAnimMontage* Montage);
    void Montage_Resume(const class UAnimMontage* Montage);
    float Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
    void Montage_Pause(const class UAnimMontage* Montage);
    void Montage_JumpToSectionsEnd(FName SectionName, const class UAnimMontage* Montage);
    void Montage_JumpToSection(FName SectionName, const class UAnimMontage* Montage);
    bool Montage_IsPlaying(const class UAnimMontage* Montage);
    bool Montage_IsActive(const class UAnimMontage* Montage);
    float Montage_GetPosition(const class UAnimMontage* Montage);
    float Montage_GetPlayRate(const class UAnimMontage* Montage);
    bool Montage_GetIsStopped(const class UAnimMontage* Montage);
    FName Montage_GetCurrentSection(const class UAnimMontage* Montage);
    float Montage_GetBlendTime(const class UAnimMontage* Montage);
    void LockAIResources(bool bLockMovement, bool LockAILogic);
    void LinkAnimGraphByTag(FName InTag, TSubclassOf<class UAnimInstance> InClass);
    void LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    bool IsSyncGroupBetweenMarkers(FName InSyncGroupName, FName PreviousMarker, FName NextMarker, bool bRespectMarkerOrder);
    bool IsPlayingSlotAnimation(const class UAnimSequenceBase* Asset, FName SlotNodeName);
    bool IsAnyMontagePlaying();
    bool HasMarkerBeenHitThisFrame(FName SyncGroup, FName MarkerName);
    bool GetTimeToClosestMarker(FName SyncGroup, FName MarkerName, float& OutMarkerTime);
    FMarkerSyncAnimPosition GetSyncGroupPosition(FName InSyncGroupName);
    float GetRelevantAnimTimeRemainingFraction(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTimeRemaining(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTimeFraction(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTime(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimLength(int32 MachineIndex, int32 StateIndex);
    bool GetReceiveNotifiesFromLinkedInstances();
    bool GetPropagateNotifiesToLinkedInstances();
    class USkeletalMeshComponent* GetOwningComponent();
    class AActor* GetOwningActor();
    void GetLinkedAnimLayerInstancesByGroup(FName InGroup, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroupAndClass(FName InGroup, TSubclassOf<class UAnimInstance> InClass);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup);
    class UAnimInstance* GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass);
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag);
    float GetInstanceTransitionTimeElapsedFraction(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceTransitionCrossfadeDuration(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex);
    float GetInstanceMachineWeight(int32 MachineIndex);
    float GetInstanceCurrentStateElapsedTime(int32 MachineIndex);
    float GetInstanceAssetPlayerTimeFromEndFraction(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFromEnd(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFraction(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTime(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerLength(int32 AssetPlayerIndex);
    float GetCurveValue(FName CurveName);
    FName GetCurrentStateName(int32 MachineIndex);
    class UAnimMontage* GetCurrentActiveMontage();
    void GetAllCurveNames(TArray<FName>& OutNames);
    void GetActiveCurveNames(EAnimCurveType CurveType, TArray<FName>& OutNames);
    void ClearMorphTargets();
    float CalculateDirection(const FVector& Velocity, const FRotator& BaseRotation);
    void BlueprintUpdateAnimation(float DeltaTimeX);
    void BlueprintPostEvaluateAnimation();
    void BlueprintLinkedAnimationLayersInitialized();
    void BlueprintInitializeAnimation();
    void BlueprintBeginPlay();
}; // Size: 0x2C0

struct FStaticMeshComponentLODInfo
{
}; // Size: 0x90

struct FStreamingTextureBuildInfo
{
    uint32 PackedRelativeBox;                                                         // 0x0000 (size: 0x4)
    int32 TextureLevelIndex;                                                          // 0x0004 (size: 0x4)
    float TexelFactor;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FLightmassPrimitiveSettings
{
    uint8 bUseTwoSidedLighting;                                                       // 0x0000 (size: 0x1)
    uint8 bShadowIndirectOnly;                                                        // 0x0000 (size: 0x1)
    uint8 bUseEmissiveForStaticLighting;                                              // 0x0000 (size: 0x1)
    uint8 bUseVertexNormalForHemisphereGather;                                        // 0x0000 (size: 0x1)
    float EmissiveLightFalloffExponent;                                               // 0x0004 (size: 0x4)
    float EmissiveLightExplicitInfluenceRadius;                                       // 0x0008 (size: 0x4)
    float EmissiveBoost;                                                              // 0x000C (size: 0x4)
    float DiffuseBoost;                                                               // 0x0010 (size: 0x4)
    float FullyOccludedSamplesFraction;                                               // 0x0014 (size: 0x4)

}; // Size: 0x18

class UStaticMeshComponent : public UMeshComponent
{
    int32 ForcedLodModel;                                                             // 0x0478 (size: 0x4)
    int32 PreviousLODLevel;                                                           // 0x047C (size: 0x4)
    int32 MinLOD;                                                                     // 0x0480 (size: 0x4)
    int32 SubDivisionStepSize;                                                        // 0x0484 (size: 0x4)
    class UStaticMesh* StaticMesh;                                                    // 0x0488 (size: 0x8)
    FColor WireframeColorOverride;                                                    // 0x0490 (size: 0x4)
    uint8 bEvaluateWorldPositionOffset;                                               // 0x0494 (size: 0x1)
    uint8 bOverrideWireframeColor;                                                    // 0x0494 (size: 0x1)
    uint8 bOverrideMinLod;                                                            // 0x0494 (size: 0x1)
    uint8 bOverrideNavigationExport;                                                  // 0x0494 (size: 0x1)
    uint8 bForceNavigationObstacle;                                                   // 0x0494 (size: 0x1)
    uint8 bDisallowMeshPaintPerInstance;                                              // 0x0494 (size: 0x1)
    uint8 bIgnoreInstanceForTextureStreaming;                                         // 0x0494 (size: 0x1)
    uint8 bOverrideLightMapRes;                                                       // 0x0494 (size: 0x1)
    uint8 bCastDistanceFieldIndirectShadow;                                           // 0x0495 (size: 0x1)
    uint8 bOverrideDistanceFieldSelfShadowBias;                                       // 0x0495 (size: 0x1)
    uint8 bUseSubDivisions;                                                           // 0x0495 (size: 0x1)
    uint8 bUseDefaultCollision;                                                       // 0x0495 (size: 0x1)
    uint8 bReverseCulling;                                                            // 0x0495 (size: 0x1)
    int32 OverriddenLightMapRes;                                                      // 0x0498 (size: 0x4)
    float DistanceFieldIndirectShadowMinVisibility;                                   // 0x049C (size: 0x4)
    float DistanceFieldSelfShadowBias;                                                // 0x04A0 (size: 0x4)
    float StreamingDistanceMultiplier;                                                // 0x04A4 (size: 0x4)
    TArray<FStaticMeshComponentLODInfo> LODData;                                      // 0x04A8 (size: 0x10)
    TArray<FStreamingTextureBuildInfo> StreamingTextureData;                          // 0x04B8 (size: 0x10)
    FLightmassPrimitiveSettings LightmassSettings;                                    // 0x04C8 (size: 0x18)

    bool SetStaticMesh(class UStaticMesh* NewMesh);
    void SetReverseCulling(bool ReverseCulling);
    void SetForcedLodModel(int32 NewForcedLodModel);
    void SetEvaluateWorldPositionOffsetInRayTracing(bool newValue);
    void SetDistanceFieldSelfShadowBias(float newValue);
    void OnRep_StaticMesh(class UStaticMesh* OldStaticMesh);
    void GetLocalBounds(FVector& Min, FVector& Max);
}; // Size: 0x4E0

struct FSplineCurves
{
    FInterpCurveVector Position;                                                      // 0x0000 (size: 0x18)
    FInterpCurveQuat Rotation;                                                        // 0x0018 (size: 0x18)
    FInterpCurveVector Scale;                                                         // 0x0030 (size: 0x18)
    FInterpCurveFloat ReparamTable;                                                   // 0x0048 (size: 0x18)
    class USplineMetadata* MetaData;                                                  // 0x0060 (size: 0x8)
    uint32 Version;                                                                   // 0x0068 (size: 0x4)

}; // Size: 0x70

struct FSplinePoint
{
    float InputKey;                                                                   // 0x0000 (size: 0x4)
    FVector Position;                                                                 // 0x0004 (size: 0xC)
    FVector ArriveTangent;                                                            // 0x0010 (size: 0xC)
    FVector LeaveTangent;                                                             // 0x001C (size: 0xC)
    FRotator Rotation;                                                                // 0x0028 (size: 0xC)
    FVector Scale;                                                                    // 0x0034 (size: 0xC)
    TEnumAsByte<ESplinePointType::Type> Type;                                         // 0x0040 (size: 0x1)

}; // Size: 0x44

class USplineComponent : public UPrimitiveComponent
{
    FSplineCurves SplineCurves;                                                       // 0x0450 (size: 0x70)
    FInterpCurveVector SplineInfo;                                                    // 0x04C0 (size: 0x18)
    FInterpCurveQuat SplineRotInfo;                                                   // 0x04D8 (size: 0x18)
    FInterpCurveVector SplineScaleInfo;                                               // 0x04F0 (size: 0x18)
    FInterpCurveFloat SplineReparamTable;                                             // 0x0508 (size: 0x18)
    bool bAllowSplineEditingPerInstance;                                              // 0x0520 (size: 0x1)
    int32 ReparamStepsPerSegment;                                                     // 0x0524 (size: 0x4)
    float Duration;                                                                   // 0x0528 (size: 0x4)
    bool bStationaryEndpoints;                                                        // 0x052C (size: 0x1)
    bool bSplineHasBeenEdited;                                                        // 0x052D (size: 0x1)
    bool bModifiedByConstructionScript;                                               // 0x052E (size: 0x1)
    bool bInputSplinePointsToConstructionScript;                                      // 0x052F (size: 0x1)
    bool bDrawDebug;                                                                  // 0x0530 (size: 0x1)
    bool bClosedLoop;                                                                 // 0x0531 (size: 0x1)
    bool bLoopPositionOverride;                                                       // 0x0532 (size: 0x1)
    float LoopPosition;                                                               // 0x0534 (size: 0x4)
    FVector DefaultUpVector;                                                          // 0x0538 (size: 0xC)

    void UpdateSpline();
    void SetWorldLocationAtSplinePoint(int32 PointIndex, const FVector& InLocation);
    void SetUpVectorAtSplinePoint(int32 PointIndex, const FVector& InUpVector, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetUnselectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetTangentsAtSplinePoint(int32 PointIndex, const FVector& InArriveTangent, const FVector& InLeaveTangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetTangentColor(const FLinearColor& TangentColor);
    void SetTangentAtSplinePoint(int32 PointIndex, const FVector& InTangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetSplineWorldPoints(const TArray<FVector>& Points);
    void SetSplinePointType(int32 PointIndex, TEnumAsByte<ESplinePointType::Type> Type, bool bUpdateSpline);
    void SetSplinePoints(const TArray<FVector>& Points, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetSplineLocalPoints(const TArray<FVector>& Points);
    void SetSelectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetScaleAtSplinePoint(int32 PointIndex, const FVector& InScaleVector, bool bUpdateSpline);
    void SetRotationAtSplinePoint(int32 PointIndex, const FRotator& InRotation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetLocationAtSplinePoint(int32 PointIndex, const FVector& InLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetDrawDebug(bool bShow);
    void SetDefaultUpVector(const FVector& UpVector, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline);
    void SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline);
    void RemoveSplinePoint(int32 Index, bool bUpdateSpline);
    bool IsClosedLoop();
    FVector GetWorldTangentAtDistanceAlongSpline(float Distance);
    FRotator GetWorldRotationAtTime(float Time, bool bUseConstantVelocity);
    FRotator GetWorldRotationAtDistanceAlongSpline(float Distance);
    FVector GetWorldLocationAtTime(float Time, bool bUseConstantVelocity);
    FVector GetWorldLocationAtSplinePoint(int32 PointIndex);
    FVector GetWorldLocationAtDistanceAlongSpline(float Distance);
    FVector GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity);
    FVector GetWorldDirectionAtDistanceAlongSpline(float Distance);
    FVector GetVectorPropertyAtSplinePoint(int32 Index, FName PropertyName);
    FVector GetVectorPropertyAtSplineInputKey(float InKey, FName PropertyName);
    FVector GetUpVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetUpVectorAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetUpVectorAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetUpVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FTransform GetTransformAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity, bool bUseScale);
    FTransform GetTransformAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FTransform GetTransformAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FTransform GetTransformAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FVector GetTangentAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetTangentAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetTangentAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    TEnumAsByte<ESplinePointType::Type> GetSplinePointType(int32 PointIndex);
    float GetSplineLength();
    FVector GetScaleAtTime(float Time, bool bUseConstantVelocity);
    FVector GetScaleAtSplinePoint(int32 PointIndex);
    FVector GetScaleAtSplineInputKey(float InKey);
    FVector GetScaleAtDistanceAlongSpline(float Distance);
    FRotator GetRotationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FRotator GetRotationAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FRotator GetRotationAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FRotator GetRotationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    float GetRollAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetRightVectorAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    int32 GetNumberOfSplineSegments();
    int32 GetNumberOfSplinePoints();
    FVector GetLocationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetLocationAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetLocationAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetLocationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void GetLocationAndTangentAtSplinePoint(int32 PointIndex, FVector& Location, FVector& Tangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void GetLocalLocationAndTangentAtSplinePoint(int32 PointIndex, FVector& LocalLocation, FVector& LocalTangent);
    FVector GetLeaveTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetInputKeyAtDistanceAlongSpline(float Distance);
    float GetFloatPropertyAtSplinePoint(int32 Index, FName PropertyName);
    float GetFloatPropertyAtSplineInputKey(float InKey, FName PropertyName);
    float GetDistanceAlongSplineAtSplinePoint(int32 PointIndex);
    float GetDistanceAlongSplineAtSplineInputKey(float InKey);
    FVector GetDirectionAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetDirectionAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDirectionAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDirectionAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDefaultUpVector(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetArriveTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindUpVectorClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FTransform FindTransformClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FVector FindTangentClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindScaleClosestToWorldLocation(const FVector& WorldLocation);
    FRotator FindRotationClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float FindRollClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindRightVectorClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindLocationClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float FindInputKeyClosestToWorldLocation(const FVector& WorldLocation);
    FVector FindDirectionClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void ClearSplinePoints(bool bUpdateSpline);
    void AddSplineWorldPoint(const FVector& Position);
    void AddSplinePointAtIndex(const FVector& Position, int32 Index, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void AddSplinePoint(const FVector& Position, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void AddSplineLocalPoint(const FVector& Position);
    void AddPoints(const TArray<FSplinePoint>& Points, bool bUpdateSpline);
    void AddPoint(const FSplinePoint& Point, bool bUpdateSpline);
}; // Size: 0x550

struct FSplineMeshParams
{
    FVector StartPos;                                                                 // 0x0000 (size: 0xC)
    FVector StartTangent;                                                             // 0x000C (size: 0xC)
    FVector2D StartScale;                                                             // 0x0018 (size: 0x8)
    float StartRoll;                                                                  // 0x0020 (size: 0x4)
    FVector2D StartOffset;                                                            // 0x0024 (size: 0x8)
    FVector EndPos;                                                                   // 0x002C (size: 0xC)
    FVector2D EndScale;                                                               // 0x0038 (size: 0x8)
    FVector EndTangent;                                                               // 0x0040 (size: 0xC)
    float EndRoll;                                                                    // 0x004C (size: 0x4)
    FVector2D EndOffset;                                                              // 0x0050 (size: 0x8)

}; // Size: 0x58

class USplineMeshComponent : public UStaticMeshComponent
{
    FSplineMeshParams SplineParams;                                                   // 0x04E8 (size: 0x58)
    FVector SplineUpDir;                                                              // 0x0540 (size: 0xC)
    float SplineBoundaryMin;                                                          // 0x054C (size: 0x4)
    FGuid CachedMeshBodySetupGuid;                                                    // 0x0550 (size: 0x10)
    class UBodySetup* BodySetup;                                                      // 0x0560 (size: 0x8)
    float SplineBoundaryMax;                                                          // 0x0568 (size: 0x4)
    uint8 bAllowSplineEditingPerInstance;                                             // 0x056C (size: 0x1)
    uint8 bSmoothInterpRollScale;                                                     // 0x056C (size: 0x1)
    uint8 bMeshDirty;                                                                 // 0x056C (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> ForwardAxis;                                   // 0x056D (size: 0x1)
    float VirtualTextureMainPassMaxDrawDistance;                                      // 0x0570 (size: 0x4)

    void UpdateMesh();
    void SetStartTangent(FVector StartTangent, bool bUpdateMesh);
    void SetStartScale(FVector2D StartScale, bool bUpdateMesh);
    void SetStartRoll(float StartRoll, bool bUpdateMesh);
    void SetStartPosition(FVector StartPos, bool bUpdateMesh);
    void SetStartOffset(FVector2D StartOffset, bool bUpdateMesh);
    void SetStartAndEnd(FVector StartPos, FVector StartTangent, FVector EndPos, FVector EndTangent, bool bUpdateMesh);
    void SetSplineUpDir(const FVector& InSplineUpDir, bool bUpdateMesh);
    void SetForwardAxis(TEnumAsByte<ESplineMeshAxis::Type> InForwardAxis, bool bUpdateMesh);
    void SetEndTangent(FVector EndTangent, bool bUpdateMesh);
    void SetEndScale(FVector2D EndScale, bool bUpdateMesh);
    void SetEndRoll(float EndRoll, bool bUpdateMesh);
    void SetEndPosition(FVector EndPos, bool bUpdateMesh);
    void SetEndOffset(FVector2D EndOffset, bool bUpdateMesh);
    void SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh);
    void SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh);
    FVector GetStartTangent();
    FVector2D GetStartScale();
    float GetStartRoll();
    FVector GetStartPosition();
    FVector2D GetStartOffset();
    FVector GetSplineUpDir();
    TEnumAsByte<ESplineMeshAxis::Type> GetForwardAxis();
    FVector GetEndTangent();
    FVector2D GetEndScale();
    float GetEndRoll();
    FVector GetEndPosition();
    FVector2D GetEndOffset();
    float GetBoundaryMin();
    float GetBoundaryMax();
}; // Size: 0x580

class UCameraShakeBase : public UObject
{
    bool bSingleInstance;                                                             // 0x0028 (size: 0x1)
    float ShakeScale;                                                                 // 0x002C (size: 0x4)
    class UCameraShakePattern* RootShakePattern;                                      // 0x0030 (size: 0x8)
    class APlayerCameraManager* CameraManager;                                        // 0x0038 (size: 0x8)

    void SetRootShakePattern(class UCameraShakePattern* InPattern);
    class UCameraShakePattern* GetRootShakePattern();
}; // Size: 0xB0

class UCameraShakePattern : public UObject
{
}; // Size: 0x28

struct FWeightedBlendable
{
    float Weight;                                                                     // 0x0000 (size: 0x4)
    class UObject* Object;                                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FWeightedBlendables
{
    TArray<FWeightedBlendable> Array;                                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPostProcessSettings
{
    uint8 bOverride_TemperatureType;                                                  // 0x0000 (size: 0x1)
    uint8 bOverride_WhiteTemp;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_WhiteTint;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ColorSaturation;                                                  // 0x0000 (size: 0x1)
    uint8 bOverride_ColorContrast;                                                    // 0x0000 (size: 0x1)
    uint8 bOverride_ColorGamma;                                                       // 0x0000 (size: 0x1)
    uint8 bOverride_ColorGain;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ColorOffset;                                                      // 0x0000 (size: 0x1)
    uint8 bOverride_ColorSaturationShadows;                                           // 0x0001 (size: 0x1)
    uint8 bOverride_ColorContrastShadows;                                             // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGammaShadows;                                                // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGainShadows;                                                 // 0x0001 (size: 0x1)
    uint8 bOverride_ColorOffsetShadows;                                               // 0x0001 (size: 0x1)
    uint8 bOverride_ColorSaturationMidtones;                                          // 0x0001 (size: 0x1)
    uint8 bOverride_ColorContrastMidtones;                                            // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGammaMidtones;                                               // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGainMidtones;                                                // 0x0002 (size: 0x1)
    uint8 bOverride_ColorOffsetMidtones;                                              // 0x0002 (size: 0x1)
    uint8 bOverride_ColorSaturationHighlights;                                        // 0x0002 (size: 0x1)
    uint8 bOverride_ColorContrastHighlights;                                          // 0x0002 (size: 0x1)
    uint8 bOverride_ColorGammaHighlights;                                             // 0x0002 (size: 0x1)
    uint8 bOverride_ColorGainHighlights;                                              // 0x0002 (size: 0x1)
    uint8 bOverride_ColorOffsetHighlights;                                            // 0x0002 (size: 0x1)
    uint8 bOverride_ColorCorrectionShadowsMax;                                        // 0x0002 (size: 0x1)
    uint8 bOverride_ColorCorrectionHighlightsMin;                                     // 0x0003 (size: 0x1)
    uint8 bOverride_BlueCorrection;                                                   // 0x0003 (size: 0x1)
    uint8 bOverride_ExpandGamut;                                                      // 0x0003 (size: 0x1)
    uint8 bOverride_ToneCurveAmount;                                                  // 0x0003 (size: 0x1)
    uint8 bOverride_FilmWhitePoint;                                                   // 0x0003 (size: 0x1)
    uint8 bOverride_FilmSaturation;                                                   // 0x0003 (size: 0x1)
    uint8 bOverride_FilmChannelMixerRed;                                              // 0x0003 (size: 0x1)
    uint8 bOverride_FilmChannelMixerGreen;                                            // 0x0003 (size: 0x1)
    uint8 bOverride_FilmChannelMixerBlue;                                             // 0x0004 (size: 0x1)
    uint8 bOverride_FilmContrast;                                                     // 0x0004 (size: 0x1)
    uint8 bOverride_FilmDynamicRange;                                                 // 0x0004 (size: 0x1)
    uint8 bOverride_FilmHealAmount;                                                   // 0x0004 (size: 0x1)
    uint8 bOverride_FilmToeAmount;                                                    // 0x0004 (size: 0x1)
    uint8 bOverride_FilmShadowTint;                                                   // 0x0004 (size: 0x1)
    uint8 bOverride_FilmShadowTintBlend;                                              // 0x0004 (size: 0x1)
    uint8 bOverride_FilmShadowTintAmount;                                             // 0x0004 (size: 0x1)
    uint8 bOverride_FilmSlope;                                                        // 0x0005 (size: 0x1)
    uint8 bOverride_FilmToe;                                                          // 0x0005 (size: 0x1)
    uint8 bOverride_FilmShoulder;                                                     // 0x0005 (size: 0x1)
    uint8 bOverride_FilmBlackClip;                                                    // 0x0005 (size: 0x1)
    uint8 bOverride_FilmWhiteClip;                                                    // 0x0005 (size: 0x1)
    uint8 bOverride_SceneColorTint;                                                   // 0x0005 (size: 0x1)
    uint8 bOverride_SceneFringeIntensity;                                             // 0x0005 (size: 0x1)
    uint8 bOverride_ChromaticAberrationStartOffset;                                   // 0x0005 (size: 0x1)
    uint8 bOverride_AmbientCubemapTint;                                               // 0x0006 (size: 0x1)
    uint8 bOverride_AmbientCubemapIntensity;                                          // 0x0006 (size: 0x1)
    uint8 bOverride_BloomMethod;                                                      // 0x0006 (size: 0x1)
    uint8 bOverride_BloomIntensity;                                                   // 0x0006 (size: 0x1)
    uint8 bOverride_BloomThreshold;                                                   // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom1Tint;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom1Size;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom2Size;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom2Tint;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom3Tint;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom3Size;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom4Tint;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom4Size;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom5Tint;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom5Size;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom6Tint;                                                       // 0x0007 (size: 0x1)
    uint8 bOverride_Bloom6Size;                                                       // 0x0008 (size: 0x1)
    uint8 bOverride_BloomSizeScale;                                                   // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionTexture;                                          // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionSize;                                             // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionCenterUV;                                         // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilter;                                        // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMin;                                     // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMax;                                     // 0x0008 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMult;                                    // 0x0009 (size: 0x1)
    uint8 bOverride_BloomConvolutionBufferScale;                                      // 0x0009 (size: 0x1)
    uint8 bOverride_BloomDirtMaskIntensity;                                           // 0x0009 (size: 0x1)
    uint8 bOverride_BloomDirtMaskTint;                                                // 0x0009 (size: 0x1)
    uint8 bOverride_BloomDirtMask;                                                    // 0x0009 (size: 0x1)
    uint8 bOverride_CameraShutterSpeed;                                               // 0x0009 (size: 0x1)
    uint8 bOverride_CameraISO;                                                        // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureMethod;                                               // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureLowPercent;                                           // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureHighPercent;                                          // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureMinBrightness;                                        // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureMaxBrightness;                                        // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureCalibrationConstant;                                  // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureSpeedUp;                                              // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureSpeedDown;                                            // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureBias;                                                 // 0x000A (size: 0x1)
    uint8 bOverride_AutoExposureBiasCurve;                                            // 0x000B (size: 0x1)
    uint8 bOverride_AutoExposureMeterMask;                                            // 0x000B (size: 0x1)
    uint8 bOverride_AutoExposureApplyPhysicalCameraExposure;                          // 0x000B (size: 0x1)
    uint8 bOverride_HistogramLogMin;                                                  // 0x000B (size: 0x1)
    uint8 bOverride_HistogramLogMax;                                                  // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareIntensity;                                               // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareTint;                                                    // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareTints;                                                   // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareBokehSize;                                               // 0x000C (size: 0x1)
    uint8 bOverride_LensFlareBokehShape;                                              // 0x000C (size: 0x1)
    uint8 bOverride_LensFlareThreshold;                                               // 0x000C (size: 0x1)
    uint8 bOverride_VignetteIntensity;                                                // 0x000C (size: 0x1)
    uint8 bOverride_GrainIntensity;                                                   // 0x000C (size: 0x1)
    uint8 bOverride_GrainJitter;                                                      // 0x000C (size: 0x1)
    uint8 bOverride_AmbientOcclusionIntensity;                                        // 0x000C (size: 0x1)
    uint8 bOverride_AmbientOcclusionStaticFraction;                                   // 0x000C (size: 0x1)
    uint8 bOverride_AmbientOcclusionRadius;                                           // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionFadeDistance;                                     // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionFadeRadius;                                       // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionDistance;                                         // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionRadiusInWS;                                       // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionPower;                                            // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionBias;                                             // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionQuality;                                          // 0x000D (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipBlend;                                         // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipScale;                                         // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipThreshold;                                     // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionTemporalBlendWeight;                              // 0x000E (size: 0x1)
    uint8 bOverride_RayTracingAO;                                                     // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAOSamplesPerPixel;                                      // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAOIntensity;                                            // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAORadius;                                               // 0x0010 (size: 0x1)
    uint8 bOverride_LPVIntensity;                                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionIntensity;                                 // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionRadius;                                    // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDiffuseOcclusionExponent;                                      // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSpecularOcclusionExponent;                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDiffuseOcclusionIntensity;                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSpecularOcclusionIntensity;                                    // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSize;                                                          // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSecondaryOcclusionIntensity;                                   // 0x0015 (size: 0x1)
    uint8 bOverride_LPVSecondaryBounceIntensity;                                      // 0x0015 (size: 0x1)
    uint8 bOverride_LPVGeometryVolumeBias;                                            // 0x0015 (size: 0x1)
    uint8 bOverride_LPVVplInjectionBias;                                              // 0x0015 (size: 0x1)
    uint8 bOverride_LPVEmissiveInjectionIntensity;                                    // 0x0015 (size: 0x1)
    uint8 bOverride_LPVFadeRange;                                                     // 0x0015 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionFadeRange;                                 // 0x0015 (size: 0x1)
    uint8 bOverride_IndirectLightingColor;                                            // 0x0015 (size: 0x1)
    uint8 bOverride_IndirectLightingIntensity;                                        // 0x0016 (size: 0x1)
    uint8 bOverride_ColorGradingIntensity;                                            // 0x0016 (size: 0x1)
    uint8 bOverride_ColorGradingLUT;                                                  // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldFocalDistance;                                        // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldFstop;                                                // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldMinFstop;                                             // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldBladeCount;                                           // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldSensorWidth;                                          // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldDepthBlurRadius;                                      // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldDepthBlurAmount;                                      // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldFocalRegion;                                          // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldNearTransitionRegion;                                 // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldFarTransitionRegion;                                  // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldScale;                                                // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldNearBlurSize;                                         // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldFarBlurSize;                                          // 0x0017 (size: 0x1)
    uint8 bOverride_MobileHQGaussian;                                                 // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldOcclusion;                                            // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldSkyFocusDistance;                                     // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldVignetteSize;                                         // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurAmount;                                                 // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurMax;                                                    // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurTargetFPS;                                              // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurPerObjectSize;                                          // 0x0018 (size: 0x1)
    uint8 bOverride_ScreenPercentage;                                                 // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionIntensity;                                   // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionQuality;                                     // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionMaxRoughness;                                // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionRoughnessScale;                              // 0x0019 (size: 0x1)
    uint8 bOverride_ReflectionsType;                                                  // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsMaxRoughness;                                // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsMaxBounces;                                  // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsSamplesPerPixel;                             // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsShadows;                                     // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsTranslucency;                                // 0x001C (size: 0x1)
    uint8 bOverride_TranslucencyType;                                                 // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyMaxRoughness;                               // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyRefractionRays;                             // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencySamplesPerPixel;                            // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyShadows;                                    // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyRefraction;                                 // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingGI;                                                     // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingGIMaxBounces;                                           // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingGISamplesPerPixel;                                      // 0x001D (size: 0x1)
    uint8 bOverride_PathTracingMaxBounces;                                            // 0x001D (size: 0x1)
    uint8 bOverride_PathTracingSamplesPerPixel;                                       // 0x001E (size: 0x1)
    uint8 bOverride_PathTracingFilterWidth;                                           // 0x001E (size: 0x1)
    uint8 bOverride_PathTracingEnableEmissive;                                        // 0x001E (size: 0x1)
    uint8 bOverride_PathTracingMaxPathExposure;                                       // 0x001E (size: 0x1)
    uint8 bOverride_PathTracingEnableDenoiser;                                        // 0x001E (size: 0x1)
    uint8 bMobileHQGaussian;                                                          // 0x0020 (size: 0x1)
    TEnumAsByte<EBloomMethod> BloomMethod;                                            // 0x0021 (size: 0x1)
    TEnumAsByte<EAutoExposureMethod> AutoExposureMethod;                              // 0x0022 (size: 0x1)
    TEnumAsByte<ETemperatureMethod> TemperatureType;                                  // 0x0023 (size: 0x1)
    float WhiteTemp;                                                                  // 0x0024 (size: 0x4)
    float WhiteTint;                                                                  // 0x0028 (size: 0x4)
    FVector4 ColorSaturation;                                                         // 0x0030 (size: 0x10)
    FVector4 ColorContrast;                                                           // 0x0040 (size: 0x10)
    FVector4 ColorGamma;                                                              // 0x0050 (size: 0x10)
    FVector4 ColorGain;                                                               // 0x0060 (size: 0x10)
    FVector4 ColorOffset;                                                             // 0x0070 (size: 0x10)
    FVector4 ColorSaturationShadows;                                                  // 0x0080 (size: 0x10)
    FVector4 ColorContrastShadows;                                                    // 0x0090 (size: 0x10)
    FVector4 ColorGammaShadows;                                                       // 0x00A0 (size: 0x10)
    FVector4 ColorGainShadows;                                                        // 0x00B0 (size: 0x10)
    FVector4 ColorOffsetShadows;                                                      // 0x00C0 (size: 0x10)
    FVector4 ColorSaturationMidtones;                                                 // 0x00D0 (size: 0x10)
    FVector4 ColorContrastMidtones;                                                   // 0x00E0 (size: 0x10)
    FVector4 ColorGammaMidtones;                                                      // 0x00F0 (size: 0x10)
    FVector4 ColorGainMidtones;                                                       // 0x0100 (size: 0x10)
    FVector4 ColorOffsetMidtones;                                                     // 0x0110 (size: 0x10)
    FVector4 ColorSaturationHighlights;                                               // 0x0120 (size: 0x10)
    FVector4 ColorContrastHighlights;                                                 // 0x0130 (size: 0x10)
    FVector4 ColorGammaHighlights;                                                    // 0x0140 (size: 0x10)
    FVector4 ColorGainHighlights;                                                     // 0x0150 (size: 0x10)
    FVector4 ColorOffsetHighlights;                                                   // 0x0160 (size: 0x10)
    float ColorCorrectionHighlightsMin;                                               // 0x0170 (size: 0x4)
    float ColorCorrectionShadowsMax;                                                  // 0x0174 (size: 0x4)
    float BlueCorrection;                                                             // 0x0178 (size: 0x4)
    float ExpandGamut;                                                                // 0x017C (size: 0x4)
    float ToneCurveAmount;                                                            // 0x0180 (size: 0x4)
    float FilmSlope;                                                                  // 0x0184 (size: 0x4)
    float FilmToe;                                                                    // 0x0188 (size: 0x4)
    float FilmShoulder;                                                               // 0x018C (size: 0x4)
    float FilmBlackClip;                                                              // 0x0190 (size: 0x4)
    float FilmWhiteClip;                                                              // 0x0194 (size: 0x4)
    FLinearColor FilmWhitePoint;                                                      // 0x0198 (size: 0x10)
    FLinearColor FilmShadowTint;                                                      // 0x01A8 (size: 0x10)
    float FilmShadowTintBlend;                                                        // 0x01B8 (size: 0x4)
    float FilmShadowTintAmount;                                                       // 0x01BC (size: 0x4)
    float FilmSaturation;                                                             // 0x01C0 (size: 0x4)
    FLinearColor FilmChannelMixerRed;                                                 // 0x01C4 (size: 0x10)
    FLinearColor FilmChannelMixerGreen;                                               // 0x01D4 (size: 0x10)
    FLinearColor FilmChannelMixerBlue;                                                // 0x01E4 (size: 0x10)
    float FilmContrast;                                                               // 0x01F4 (size: 0x4)
    float FilmToeAmount;                                                              // 0x01F8 (size: 0x4)
    float FilmHealAmount;                                                             // 0x01FC (size: 0x4)
    float FilmDynamicRange;                                                           // 0x0200 (size: 0x4)
    FLinearColor SceneColorTint;                                                      // 0x0204 (size: 0x10)
    float SceneFringeIntensity;                                                       // 0x0214 (size: 0x4)
    float ChromaticAberrationStartOffset;                                             // 0x0218 (size: 0x4)
    float BloomIntensity;                                                             // 0x021C (size: 0x4)
    float BloomThreshold;                                                             // 0x0220 (size: 0x4)
    float BloomSizeScale;                                                             // 0x0224 (size: 0x4)
    float Bloom1Size;                                                                 // 0x0228 (size: 0x4)
    float Bloom2Size;                                                                 // 0x022C (size: 0x4)
    float Bloom3Size;                                                                 // 0x0230 (size: 0x4)
    float Bloom4Size;                                                                 // 0x0234 (size: 0x4)
    float Bloom5Size;                                                                 // 0x0238 (size: 0x4)
    float Bloom6Size;                                                                 // 0x023C (size: 0x4)
    FLinearColor Bloom1Tint;                                                          // 0x0240 (size: 0x10)
    FLinearColor Bloom2Tint;                                                          // 0x0250 (size: 0x10)
    FLinearColor Bloom3Tint;                                                          // 0x0260 (size: 0x10)
    FLinearColor Bloom4Tint;                                                          // 0x0270 (size: 0x10)
    FLinearColor Bloom5Tint;                                                          // 0x0280 (size: 0x10)
    FLinearColor Bloom6Tint;                                                          // 0x0290 (size: 0x10)
    float BloomConvolutionSize;                                                       // 0x02A0 (size: 0x4)
    class UTexture2D* BloomConvolutionTexture;                                        // 0x02A8 (size: 0x8)
    FVector2D BloomConvolutionCenterUV;                                               // 0x02B0 (size: 0x8)
    float BloomConvolutionPreFilterMin;                                               // 0x02B8 (size: 0x4)
    float BloomConvolutionPreFilterMax;                                               // 0x02BC (size: 0x4)
    float BloomConvolutionPreFilterMult;                                              // 0x02C0 (size: 0x4)
    float BloomConvolutionBufferScale;                                                // 0x02C4 (size: 0x4)
    class UTexture* BloomDirtMask;                                                    // 0x02C8 (size: 0x8)
    float BloomDirtMaskIntensity;                                                     // 0x02D0 (size: 0x4)
    FLinearColor BloomDirtMaskTint;                                                   // 0x02D4 (size: 0x10)
    FLinearColor AmbientCubemapTint;                                                  // 0x02E4 (size: 0x10)
    float AmbientCubemapIntensity;                                                    // 0x02F4 (size: 0x4)
    class UTextureCube* AmbientCubemap;                                               // 0x02F8 (size: 0x8)
    float CameraShutterSpeed;                                                         // 0x0300 (size: 0x4)
    float CameraISO;                                                                  // 0x0304 (size: 0x4)
    float DepthOfFieldFstop;                                                          // 0x0308 (size: 0x4)
    float DepthOfFieldMinFstop;                                                       // 0x030C (size: 0x4)
    int32 DepthOfFieldBladeCount;                                                     // 0x0310 (size: 0x4)
    float AutoExposureBias;                                                           // 0x0314 (size: 0x4)
    float AutoExposureBiasBackup;                                                     // 0x0318 (size: 0x4)
    uint8 bOverride_AutoExposureBiasBackup;                                           // 0x031C (size: 0x1)
    uint8 AutoExposureApplyPhysicalCameraExposure;                                    // 0x0320 (size: 0x1)
    class UCurveFloat* AutoExposureBiasCurve;                                         // 0x0328 (size: 0x8)
    class UTexture* AutoExposureMeterMask;                                            // 0x0330 (size: 0x8)
    float AutoExposureLowPercent;                                                     // 0x0338 (size: 0x4)
    float AutoExposureHighPercent;                                                    // 0x033C (size: 0x4)
    float AutoExposureMinBrightness;                                                  // 0x0340 (size: 0x4)
    float AutoExposureMaxBrightness;                                                  // 0x0344 (size: 0x4)
    float AutoExposureSpeedUp;                                                        // 0x0348 (size: 0x4)
    float AutoExposureSpeedDown;                                                      // 0x034C (size: 0x4)
    float HistogramLogMin;                                                            // 0x0350 (size: 0x4)
    float HistogramLogMax;                                                            // 0x0354 (size: 0x4)
    float AutoExposureCalibrationConstant;                                            // 0x0358 (size: 0x4)
    float LensFlareIntensity;                                                         // 0x035C (size: 0x4)
    FLinearColor LensFlareTint;                                                       // 0x0360 (size: 0x10)
    float LensFlareBokehSize;                                                         // 0x0370 (size: 0x4)
    float LensFlareThreshold;                                                         // 0x0374 (size: 0x4)
    class UTexture* LensFlareBokehShape;                                              // 0x0378 (size: 0x8)
    FLinearColor LensFlareTints;                                                      // 0x0380 (size: 0x80)
    float VignetteIntensity;                                                          // 0x0400 (size: 0x4)
    float GrainJitter;                                                                // 0x0404 (size: 0x4)
    float GrainIntensity;                                                             // 0x0408 (size: 0x4)
    float AmbientOcclusionIntensity;                                                  // 0x040C (size: 0x4)
    float AmbientOcclusionStaticFraction;                                             // 0x0410 (size: 0x4)
    float AmbientOcclusionRadius;                                                     // 0x0414 (size: 0x4)
    uint8 AmbientOcclusionRadiusInWS;                                                 // 0x0418 (size: 0x1)
    float AmbientOcclusionFadeDistance;                                               // 0x041C (size: 0x4)
    float AmbientOcclusionFadeRadius;                                                 // 0x0420 (size: 0x4)
    float AmbientOcclusionDistance;                                                   // 0x0424 (size: 0x4)
    float AmbientOcclusionPower;                                                      // 0x0428 (size: 0x4)
    float AmbientOcclusionBias;                                                       // 0x042C (size: 0x4)
    float AmbientOcclusionQuality;                                                    // 0x0430 (size: 0x4)
    float AmbientOcclusionMipBlend;                                                   // 0x0434 (size: 0x4)
    float AmbientOcclusionMipScale;                                                   // 0x0438 (size: 0x4)
    float AmbientOcclusionMipThreshold;                                               // 0x043C (size: 0x4)
    float AmbientOcclusionTemporalBlendWeight;                                        // 0x0440 (size: 0x4)
    uint8 RayTracingAO;                                                               // 0x0444 (size: 0x1)
    int32 RayTracingAOSamplesPerPixel;                                                // 0x0448 (size: 0x4)
    float RayTracingAOIntensity;                                                      // 0x044C (size: 0x4)
    float RayTracingAORadius;                                                         // 0x0450 (size: 0x4)
    FLinearColor IndirectLightingColor;                                               // 0x0454 (size: 0x10)
    float IndirectLightingIntensity;                                                  // 0x0464 (size: 0x4)
    ERayTracingGlobalIlluminationType RayTracingGIType;                               // 0x0468 (size: 0x1)
    int32 RayTracingGIMaxBounces;                                                     // 0x046C (size: 0x4)
    int32 RayTracingGISamplesPerPixel;                                                // 0x0470 (size: 0x4)
    float ColorGradingIntensity;                                                      // 0x0474 (size: 0x4)
    class UTexture* ColorGradingLUT;                                                  // 0x0478 (size: 0x8)
    float DepthOfFieldSensorWidth;                                                    // 0x0480 (size: 0x4)
    float DepthOfFieldFocalDistance;                                                  // 0x0484 (size: 0x4)
    float DepthOfFieldDepthBlurAmount;                                                // 0x0488 (size: 0x4)
    float DepthOfFieldDepthBlurRadius;                                                // 0x048C (size: 0x4)
    float DepthOfFieldFocalRegion;                                                    // 0x0490 (size: 0x4)
    float DepthOfFieldNearTransitionRegion;                                           // 0x0494 (size: 0x4)
    float DepthOfFieldFarTransitionRegion;                                            // 0x0498 (size: 0x4)
    float DepthOfFieldScale;                                                          // 0x049C (size: 0x4)
    float DepthOfFieldNearBlurSize;                                                   // 0x04A0 (size: 0x4)
    float DepthOfFieldFarBlurSize;                                                    // 0x04A4 (size: 0x4)
    float DepthOfFieldOcclusion;                                                      // 0x04A8 (size: 0x4)
    float DepthOfFieldSkyFocusDistance;                                               // 0x04AC (size: 0x4)
    float DepthOfFieldVignetteSize;                                                   // 0x04B0 (size: 0x4)
    float MotionBlurAmount;                                                           // 0x04B4 (size: 0x4)
    float MotionBlurMax;                                                              // 0x04B8 (size: 0x4)
    int32 MotionBlurTargetFPS;                                                        // 0x04BC (size: 0x4)
    float MotionBlurPerObjectSize;                                                    // 0x04C0 (size: 0x4)
    float LPVIntensity;                                                               // 0x04C4 (size: 0x4)
    float LPVVplInjectionBias;                                                        // 0x04C8 (size: 0x4)
    float LPVSize;                                                                    // 0x04CC (size: 0x4)
    float LPVSecondaryOcclusionIntensity;                                             // 0x04D0 (size: 0x4)
    float LPVSecondaryBounceIntensity;                                                // 0x04D4 (size: 0x4)
    float LPVGeometryVolumeBias;                                                      // 0x04D8 (size: 0x4)
    float LPVEmissiveInjectionIntensity;                                              // 0x04DC (size: 0x4)
    float LPVDirectionalOcclusionIntensity;                                           // 0x04E0 (size: 0x4)
    float LPVDirectionalOcclusionRadius;                                              // 0x04E4 (size: 0x4)
    float LPVDiffuseOcclusionExponent;                                                // 0x04E8 (size: 0x4)
    float LPVSpecularOcclusionExponent;                                               // 0x04EC (size: 0x4)
    float LPVDiffuseOcclusionIntensity;                                               // 0x04F0 (size: 0x4)
    float LPVSpecularOcclusionIntensity;                                              // 0x04F4 (size: 0x4)
    EReflectionsType ReflectionsType;                                                 // 0x04F8 (size: 0x1)
    float ScreenSpaceReflectionIntensity;                                             // 0x04FC (size: 0x4)
    float ScreenSpaceReflectionQuality;                                               // 0x0500 (size: 0x4)
    float ScreenSpaceReflectionMaxRoughness;                                          // 0x0504 (size: 0x4)
    float RayTracingReflectionsMaxRoughness;                                          // 0x0508 (size: 0x4)
    int32 RayTracingReflectionsMaxBounces;                                            // 0x050C (size: 0x4)
    int32 RayTracingReflectionsSamplesPerPixel;                                       // 0x0510 (size: 0x4)
    EReflectedAndRefractedRayTracedShadows RayTracingReflectionsShadows;              // 0x0514 (size: 0x1)
    uint8 RayTracingReflectionsTranslucency;                                          // 0x0515 (size: 0x1)
    ETranslucencyType TranslucencyType;                                               // 0x0516 (size: 0x1)
    float RayTracingTranslucencyMaxRoughness;                                         // 0x0518 (size: 0x4)
    int32 RayTracingTranslucencyRefractionRays;                                       // 0x051C (size: 0x4)
    int32 RayTracingTranslucencySamplesPerPixel;                                      // 0x0520 (size: 0x4)
    EReflectedAndRefractedRayTracedShadows RayTracingTranslucencyShadows;             // 0x0524 (size: 0x1)
    uint8 RayTracingTranslucencyRefraction;                                           // 0x0525 (size: 0x1)
    int32 PathTracingMaxBounces;                                                      // 0x0528 (size: 0x4)
    int32 PathTracingSamplesPerPixel;                                                 // 0x052C (size: 0x4)
    float PathTracingFilterWidth;                                                     // 0x0530 (size: 0x4)
    uint8 PathTracingEnableEmissive;                                                  // 0x0534 (size: 0x1)
    float PathTracingMaxPathExposure;                                                 // 0x0538 (size: 0x4)
    uint8 PathTracingEnableDenoiser;                                                  // 0x053C (size: 0x1)
    float LPVFadeRange;                                                               // 0x0540 (size: 0x4)
    float LPVDirectionalOcclusionFadeRange;                                           // 0x0544 (size: 0x4)
    float ScreenPercentage;                                                           // 0x0548 (size: 0x4)
    FWeightedBlendables WeightedBlendables;                                           // 0x0550 (size: 0x10)

}; // Size: 0x560

struct FMinimalViewInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FRotator Rotation;                                                                // 0x000C (size: 0xC)
    float FOV;                                                                        // 0x0018 (size: 0x4)
    float DesiredFOV;                                                                 // 0x001C (size: 0x4)
    float OrthoWidth;                                                                 // 0x0020 (size: 0x4)
    float OrthoNearClipPlane;                                                         // 0x0024 (size: 0x4)
    float OrthoFarClipPlane;                                                          // 0x0028 (size: 0x4)
    float AspectRatio;                                                                // 0x002C (size: 0x4)
    uint8 bConstrainAspectRatio;                                                      // 0x0030 (size: 0x1)
    uint8 bUseFieldOfViewForLOD;                                                      // 0x0030 (size: 0x1)
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionMode;                          // 0x0034 (size: 0x1)
    float PostProcessBlendWeight;                                                     // 0x0038 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x0040 (size: 0x560)
    FVector2D OffCenterProjectionOffset;                                              // 0x05A0 (size: 0x8)

}; // Size: 0x5F0

struct FKeyHandleLookupTable
{
}; // Size: 0x60

class UCommandlet : public UObject
{
    FString HelpDescription;                                                          // 0x0028 (size: 0x10)
    FString HelpUsage;                                                                // 0x0038 (size: 0x10)
    FString HelpWebLink;                                                              // 0x0048 (size: 0x10)
    TArray<FString> HelpParamNames;                                                   // 0x0058 (size: 0x10)
    TArray<FString> HelpParamDescriptions;                                            // 0x0068 (size: 0x10)
    uint8 IsServer;                                                                   // 0x0078 (size: 0x1)
    uint8 IsClient;                                                                   // 0x0078 (size: 0x1)
    uint8 IsEditor;                                                                   // 0x0078 (size: 0x1)
    uint8 LogToConsole;                                                               // 0x0078 (size: 0x1)
    uint8 ShowErrorCount;                                                             // 0x0078 (size: 0x1)
    uint8 ShowProgress;                                                               // 0x0078 (size: 0x1)

}; // Size: 0x80

struct FAudioComponentParam
{
    FName ParamName;                                                                  // 0x0000 (size: 0x8)
    float FloatParam;                                                                 // 0x0008 (size: 0x4)
    bool BoolParam;                                                                   // 0x000C (size: 0x1)
    int32 IntParam;                                                                   // 0x0010 (size: 0x4)
    class USoundWave* SoundWaveParam;                                                 // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSoundModulationDefaultSettings
{
    FSoundModulationDestinationSettings VolumeModulationDestination;                  // 0x0000 (size: 0x10)
    FSoundModulationDestinationSettings PitchModulationDestination;                   // 0x0010 (size: 0x10)
    FSoundModulationDestinationSettings HighpassModulationDestination;                // 0x0020 (size: 0x10)
    FSoundModulationDestinationSettings LowpassModulationDestination;                 // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSoundModulationDefaultRoutingSettings : public FSoundModulationDefaultSettings
{
    EModulationRouting VolumeRouting;                                                 // 0x0040 (size: 0x1)
    EModulationRouting PitchRouting;                                                  // 0x0041 (size: 0x1)
    EModulationRouting HighpassRouting;                                               // 0x0042 (size: 0x1)
    EModulationRouting LowpassRouting;                                                // 0x0043 (size: 0x1)

}; // Size: 0x48

struct FQuartzQuantizationBoundary
{
    EQuartzCommandQuantization Quantization;                                          // 0x0000 (size: 0x1)
    float Multiplier;                                                                 // 0x0004 (size: 0x4)
    EQuarztQuantizationReference CountingReferencePoint;                              // 0x0008 (size: 0x1)
    bool bFireOnClockStart;                                                           // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FSoundWaveSpectralData
{
    float FrequencyHz;                                                                // 0x0000 (size: 0x4)
    float Magnitude;                                                                  // 0x0004 (size: 0x4)
    float NormalizedMagnitude;                                                        // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSoundWaveSpectralDataPerSound
{
    TArray<FSoundWaveSpectralData> SpectralData;                                      // 0x0000 (size: 0x10)
    float PlaybackTime;                                                               // 0x0010 (size: 0x4)
    class USoundWave* SoundWave;                                                      // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSoundWaveEnvelopeDataPerSound
{
    float Envelope;                                                                   // 0x0000 (size: 0x4)
    float PlaybackTime;                                                               // 0x0004 (size: 0x4)
    class USoundWave* SoundWave;                                                      // 0x0008 (size: 0x8)

}; // Size: 0x10

class UAudioComponent : public USceneComponent
{
    class USoundBase* Sound;                                                          // 0x01F8 (size: 0x8)
    TArray<FAudioComponentParam> InstanceParameters;                                  // 0x0200 (size: 0x10)
    class USoundClass* SoundClassOverride;                                            // 0x0210 (size: 0x8)
    uint8 bAutoDestroy;                                                               // 0x0218 (size: 0x1)
    uint8 bStopWhenOwnerDestroyed;                                                    // 0x0218 (size: 0x1)
    uint8 bShouldRemainActiveIfDropped;                                               // 0x0218 (size: 0x1)
    uint8 bAllowSpatialization;                                                       // 0x0218 (size: 0x1)
    uint8 bOverrideAttenuation;                                                       // 0x0218 (size: 0x1)
    uint8 bOverrideSubtitlePriority;                                                  // 0x0218 (size: 0x1)
    uint8 bIsUISound;                                                                 // 0x0218 (size: 0x1)
    uint8 bEnableLowPassFilter;                                                       // 0x0218 (size: 0x1)
    uint8 bOverridePriority;                                                          // 0x0219 (size: 0x1)
    uint8 bSuppressSubtitles;                                                         // 0x0219 (size: 0x1)
    uint8 bAutoManageAttachment;                                                      // 0x021A (size: 0x1)
    FName AudioComponentUserID;                                                       // 0x0220 (size: 0x8)
    float PitchModulationMin;                                                         // 0x0228 (size: 0x4)
    float PitchModulationMax;                                                         // 0x022C (size: 0x4)
    float VolumeModulationMin;                                                        // 0x0230 (size: 0x4)
    float VolumeModulationMax;                                                        // 0x0234 (size: 0x4)
    float VolumeMultiplier;                                                           // 0x0238 (size: 0x4)
    int32 EnvelopeFollowerAttackTime;                                                 // 0x023C (size: 0x4)
    int32 EnvelopeFollowerReleaseTime;                                                // 0x0240 (size: 0x4)
    float Priority;                                                                   // 0x0244 (size: 0x4)
    float SubtitlePriority;                                                           // 0x0248 (size: 0x4)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0250 (size: 0x8)
    float PitchMultiplier;                                                            // 0x0258 (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x025C (size: 0x4)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0268 (size: 0x8)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0270 (size: 0x3A0)
    class USoundConcurrency* ConcurrencySettings;                                     // 0x0610 (size: 0x8)
    TSet<USoundConcurrency*> ConcurrencySet;                                          // 0x0618 (size: 0x50)
    EAttachmentRule AutoAttachLocationRule;                                           // 0x0674 (size: 0x1)
    EAttachmentRule AutoAttachRotationRule;                                           // 0x0675 (size: 0x1)
    EAttachmentRule AutoAttachScaleRule;                                              // 0x0676 (size: 0x1)
    FSoundModulationDefaultRoutingSettings ModulationRouting;                         // 0x0678 (size: 0x48)
    FAudioComponentOnAudioPlayStateChanged OnAudioPlayStateChanged;                   // 0x06C0 (size: 0x10)
    void OnAudioPlayStateChanged(EAudioComponentPlayState PlayState);
    FAudioComponentOnAudioVirtualizationChanged OnAudioVirtualizationChanged;         // 0x06E8 (size: 0x10)
    void OnAudioVirtualizationChanged(bool bIsVirtualized);
    FAudioComponentOnAudioFinished OnAudioFinished;                                   // 0x0710 (size: 0x10)
    void OnAudioFinished();
    FAudioComponentOnAudioPlaybackPercent OnAudioPlaybackPercent;                     // 0x0738 (size: 0x10)
    void OnAudioPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent);
    FAudioComponentOnAudioSingleEnvelopeValue OnAudioSingleEnvelopeValue;             // 0x0760 (size: 0x10)
    void OnAudioSingleEnvelopeValue(const class USoundWave* PlayingSoundWave, const float EnvelopeValue);
    FAudioComponentOnAudioMultiEnvelopeValue OnAudioMultiEnvelopeValue;               // 0x0788 (size: 0x10)
    void OnAudioMultiEnvelopeValue(const float AverageEnvelopeValue, const float MaxEnvelope, const int32 NumWaveInstances);
    FAudioComponentOnQueueSubtitles OnQueueSubtitles;                                 // 0x07B0 (size: 0x10)
    void OnQueueSubtitles(const TArray<FSubtitleCue>& Subtitles, float CueDuration);
    TWeakObjectPtr<class USceneComponent> AutoAttachParent;                           // 0x07C0 (size: 0x8)
    FName AutoAttachSocketName;                                                       // 0x07C8 (size: 0x8)

    void StopDelayed(float DelayTime);
    void Stop();
    void SetWaveParameter(FName InName, class USoundWave* InWave);
    void SetVolumeMultiplier(float NewVolumeMultiplier);
    void SetUISound(bool bInUISound);
    void SetSubmixSend(class USoundSubmixBase* Submix, float SendLevel);
    void SetSourceBusSendPreEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSourceBusSendPostEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSound(class USoundBase* NewSound);
    void SetPitchMultiplier(float NewPitchMultiplier);
    void SetPaused(bool bPause);
    void SetOutputToBusOnly(bool bInOutputToBusOnly);
    void SetLowPassFilterFrequency(float InLowPassFilterFrequency);
    void SetLowPassFilterEnabled(bool InLowPassFilterEnabled);
    void SetIntParameter(FName InName, int32 inInt);
    void SetFloatParameter(FName InName, float InFloat);
    void SetBoolParameter(FName InName, bool InBool);
    void SetAudioBusSendPreEffect(class UAudioBus* AudioBus, float AudioBusSendLevel);
    void SetAudioBusSendPostEffect(class UAudioBus* AudioBus, float AudioBusSendLevel);
    void PlayQuantized(const class UObject* WorldContextObject, class UQuartzClockHandle*& InClockHandle, FQuartzQuantizationBoundary& InQuantizationBoundary, const FPlayQuantizedInDelegate& InDelegate, float InStartTime, float InFadeInDuration, float InFadeVolumeLevel, EAudioFaderCurve InFadeCurve);
    void Play(float StartTime);
    bool IsVirtualized();
    bool IsPlaying();
    bool HasCookedFFTData();
    bool HasCookedAmplitudeEnvelopeData();
    EAudioComponentPlayState GetPlayState();
    bool GetCookedFFTDataForAllPlayingSounds(TArray<FSoundWaveSpectralDataPerSound>& OutSoundWaveSpectralData);
    bool GetCookedFFTData(const TArray<float>& FrequenciesToGet, TArray<FSoundWaveSpectralData>& OutSoundWaveSpectralData);
    bool GetCookedEnvelopeDataForAllPlayingSounds(TArray<FSoundWaveEnvelopeDataPerSound>& OutEnvelopeData);
    bool GetCookedEnvelopeData(float& OutEnvelopeData);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel, const EAudioFaderCurve FadeCurve);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, const EAudioFaderCurve FadeCurve);
    bool BP_GetAttenuationSettingsToApply(FSoundAttenuationSettings& OutAttenuationSettings);
    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, const EAudioFaderCurve FadeCurve);
    void AdjustAttenuation(const FSoundAttenuationSettings& InAttenuationSettings);
}; // Size: 0x860

class UAssetImportData : public UObject
{
}; // Size: 0x28

class UAssetUserData : public UObject
{
}; // Size: 0x28

class UFXSystemComponent : public UPrimitiveComponent
{

    void SetVectorParameter(FName ParameterName, FVector Param);
    void SetUseAutoManageAttachment(bool bAutoManage);
    void SetIntParameter(FName ParameterName, int32 Param);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetEmitterEnable(FName EmitterName, bool bNewEnableState);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetBoolParameter(FName ParameterName, bool Param);
    void SetAutoAttachmentParameters(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule);
    void SetActorParameter(FName ParameterName, class AActor* Param);
    void ReleaseToPool();
    class UFXSystemAsset* GetFXSystemAsset();
}; // Size: 0x450

class UFXSystemAsset : public UObject
{
    uint32 MaxPoolSize;                                                               // 0x0028 (size: 0x4)
    uint32 PoolPrimeSize;                                                             // 0x002C (size: 0x4)

}; // Size: 0x30

class UAnimNotify : public UObject
{

    bool Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
    FString GetNotifyName();
}; // Size: 0x38

class UAnimNotifyState : public UObject
{

    bool Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime);
    bool Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
    bool Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration);
    FString GetNotifyName();
}; // Size: 0x30

class USaveGame : public UObject
{
}; // Size: 0x28

class AInfo : public AActor
{
}; // Size: 0x228

class AGameModeBase : public AInfo
{
    FString OptionsString;                                                            // 0x0228 (size: 0x10)
    TSubclassOf<class AGameSession> GameSessionClass;                                 // 0x0238 (size: 0x8)
    TSubclassOf<class AGameStateBase> GameStateClass;                                 // 0x0240 (size: 0x8)
    TSubclassOf<class APlayerController> PlayerControllerClass;                       // 0x0248 (size: 0x8)
    TSubclassOf<class APlayerState> PlayerStateClass;                                 // 0x0250 (size: 0x8)
    TSubclassOf<class AHUD> HUDClass;                                                 // 0x0258 (size: 0x8)
    TSubclassOf<class APawn> DefaultPawnClass;                                        // 0x0260 (size: 0x8)
    TSubclassOf<class ASpectatorPawn> SpectatorClass;                                 // 0x0268 (size: 0x8)
    TSubclassOf<class APlayerController> ReplaySpectatorPlayerControllerClass;        // 0x0270 (size: 0x8)
    TSubclassOf<class AServerStatReplicator> ServerStatReplicatorClass;               // 0x0278 (size: 0x8)
    class AGameSession* GameSession;                                                  // 0x0280 (size: 0x8)
    class AGameStateBase* GameState;                                                  // 0x0288 (size: 0x8)
    class AServerStatReplicator* ServerStatReplicator;                                // 0x0290 (size: 0x8)
    FText DefaultPlayerName;                                                          // 0x0298 (size: 0x18)
    uint8 bUseSeamlessTravel;                                                         // 0x02B0 (size: 0x1)
    uint8 bStartPlayersAsSpectators;                                                  // 0x02B0 (size: 0x1)
    uint8 bPauseable;                                                                 // 0x02B0 (size: 0x1)

    void StartPlay();
    class APawn* SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot);
    class APawn* SpawnDefaultPawnAtTransform(class AController* NewPlayer, const FTransform& SpawnTransform);
    bool ShouldReset(class AActor* ActorToReset);
    void ReturnToMainMenuHost();
    void RestartPlayerAtTransform(class AController* NewPlayer, const FTransform& SpawnTransform);
    void RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot);
    void RestartPlayer(class AController* NewPlayer);
    void ResetLevel();
    bool PlayerCanRestart(class APlayerController* Player);
    bool MustSpectate(class APlayerController* NewPlayerController);
    void K2_PostLogin(class APlayerController* NewPlayer);
    void K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC);
    void K2_OnRestartPlayer(class AController* NewPlayer);
    void K2_OnLogout(class AController* ExitingController);
    void K2_OnChangeName(class AController* Other, FString NewName, bool bNameChange);
    class AActor* K2_FindPlayerStart(class AController* Player, FString IncomingName);
    void InitStartSpot(class AActor* StartSpot, class AController* NewPlayer);
    void InitializeHUDForPlayer(class APlayerController* NewPlayer);
    bool HasMatchStarted();
    bool HasMatchEnded();
    void HandleStartingNewPlayer(class APlayerController* NewPlayer);
    int32 GetNumSpectators();
    int32 GetNumPlayers();
    UClass* GetDefaultPawnClassForController(class AController* InController);
    class AActor* FindPlayerStart(class AController* Player, FString IncomingName);
    class AActor* ChoosePlayerStart(class AController* Player);
    void ChangeName(class AController* Controller, FString NewName, bool bNameChange);
    bool CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget);
}; // Size: 0x2C8

class AGameMode : public AGameModeBase
{
    FName MatchState;                                                                 // 0x02C8 (size: 0x8)
    uint8 bDelayedStart;                                                              // 0x02D0 (size: 0x1)
    int32 NumSpectators;                                                              // 0x02D4 (size: 0x4)
    int32 NumPlayers;                                                                 // 0x02D8 (size: 0x4)
    int32 NumBots;                                                                    // 0x02DC (size: 0x4)
    float MinRespawnDelay;                                                            // 0x02E0 (size: 0x4)
    int32 NumTravellingPlayers;                                                       // 0x02E4 (size: 0x4)
    TSubclassOf<class ULocalMessage> EngineMessageClass;                              // 0x02E8 (size: 0x8)
    TArray<class APlayerState*> InactivePlayerArray;                                  // 0x02F0 (size: 0x10)
    float InactivePlayerStateLifeSpan;                                                // 0x0300 (size: 0x4)
    int32 MaxInactivePlayers;                                                         // 0x0304 (size: 0x4)
    bool bHandleDedicatedServerReplays;                                               // 0x0308 (size: 0x1)

    void StartMatch();
    void SetBandwidthLimit(float AsyncIOBandwidthLimit);
    void Say(FString Msg);
    void RestartGame();
    bool ReadyToStartMatch();
    bool ReadyToEndMatch();
    void K2_OnSetMatchState(FName NewState);
    bool IsMatchInProgress();
    FName GetMatchState();
    void EndMatch();
    void AbortMatch();
}; // Size: 0x310

class AGameStateBase : public AInfo
{
    TSubclassOf<class AGameModeBase> GameModeClass;                                   // 0x0228 (size: 0x8)
    class AGameModeBase* AuthorityGameMode;                                           // 0x0230 (size: 0x8)
    TSubclassOf<class ASpectatorPawn> SpectatorClass;                                 // 0x0238 (size: 0x8)
    TArray<class APlayerState*> PlayerArray;                                          // 0x0240 (size: 0x10)
    bool bReplicatedHasBegunPlay;                                                     // 0x0250 (size: 0x1)
    float ReplicatedWorldTimeSeconds;                                                 // 0x0254 (size: 0x4)
    float ServerWorldTimeSecondsDelta;                                                // 0x0258 (size: 0x4)
    float ServerWorldTimeSecondsUpdateFrequency;                                      // 0x025C (size: 0x4)

    void OnRep_SpectatorClass();
    void OnRep_ReplicatedWorldTimeSeconds();
    void OnRep_ReplicatedHasBegunPlay();
    void OnRep_GameModeClass();
    bool HasMatchStarted();
    bool HasMatchEnded();
    bool HasBegunPlay();
    float GetServerWorldTimeSeconds();
    float GetPlayerStartTime(class AController* Controller);
    float GetPlayerRespawnDelay(class AController* Controller);
}; // Size: 0x278

class AGameState : public AGameStateBase
{
    FName MatchState;                                                                 // 0x0278 (size: 0x8)
    FName PreviousMatchState;                                                         // 0x0280 (size: 0x8)
    int32 ElapsedTime;                                                                // 0x0288 (size: 0x4)

    void OnRep_MatchState();
    void OnRep_ElapsedTime();
}; // Size: 0x298

class UApplicationLifecycleComponent : public UActorComponent
{
    FApplicationLifecycleComponentApplicationWillDeactivateDelegate ApplicationWillDeactivateDelegate; // 0x00B0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationHasReactivatedDelegate ApplicationHasReactivatedDelegate; // 0x00C0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationWillEnterBackgroundDelegate ApplicationWillEnterBackgroundDelegate; // 0x00D0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationHasEnteredForegroundDelegate ApplicationHasEnteredForegroundDelegate; // 0x00E0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationWillTerminateDelegate ApplicationWillTerminateDelegate; // 0x00F0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationShouldUnloadResourcesDelegate ApplicationShouldUnloadResourcesDelegate; // 0x0100 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationReceivedStartupArgumentsDelegate ApplicationReceivedStartupArgumentsDelegate; // 0x0110 (size: 0x10)
    void ApplicationStartupArgumentsDelegate(const TArray<FString>& StartupArguments);
    FApplicationLifecycleComponentOnTemperatureChangeDelegate OnTemperatureChangeDelegate; // 0x0120 (size: 0x10)
    void OnTemperatureChangeDelegate(ETemperatureSeverityType Severity);
    FApplicationLifecycleComponentOnLowPowerModeDelegate OnLowPowerModeDelegate;      // 0x0130 (size: 0x10)
    void OnLowPowerModeDelegate(bool bInLowPowerMode);

}; // Size: 0x140

class UDataAsset : public UObject
{
    TSubclassOf<class UDataAsset> NativeClass;                                        // 0x0028 (size: 0x8)

}; // Size: 0x30

class APawn : public AActor
{
    uint8 bUseControllerRotationPitch;                                                // 0x0230 (size: 0x1)
    uint8 bUseControllerRotationYaw;                                                  // 0x0230 (size: 0x1)
    uint8 bUseControllerRotationRoll;                                                 // 0x0230 (size: 0x1)
    uint8 bCanAffectNavigationGeneration;                                             // 0x0230 (size: 0x1)
    float BaseEyeHeight;                                                              // 0x0234 (size: 0x4)
    TEnumAsByte<EAutoReceiveInput::Type> AutoPossessPlayer;                           // 0x0238 (size: 0x1)
    EAutoPossessAI AutoPossessAI;                                                     // 0x0239 (size: 0x1)
    uint8 RemoteViewPitch;                                                            // 0x023A (size: 0x1)
    TSubclassOf<class AController> AIControllerClass;                                 // 0x0240 (size: 0x8)
    class APlayerState* PlayerState;                                                  // 0x0248 (size: 0x8)
    class AController* LastHitBy;                                                     // 0x0258 (size: 0x8)
    class AController* Controller;                                                    // 0x0260 (size: 0x8)
    FVector ControlInputVector;                                                       // 0x026C (size: 0xC)
    FVector LastControlInputVector;                                                   // 0x0278 (size: 0xC)

    void SpawnDefaultController();
    void SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate);
    void ReceiveUnpossessed(class AController* OldController);
    void ReceivePossessed(class AController* NewController);
    void PawnMakeNoise(float Loudness, FVector NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker);
    void OnRep_PlayerState();
    void OnRep_Controller();
    void LaunchPawn(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    FVector K2_GetMovementInputVector();
    bool IsPlayerControlled();
    bool IsPawnControlled();
    bool IsMoveInputIgnored();
    bool IsLocallyControlled();
    bool IsControlled();
    bool IsBotControlled();
    FVector GetPendingMovementInputVector();
    FVector GetNavAgentLocation();
    class UPawnMovementComponent* GetMovementComponent();
    class AActor* GetMovementBaseActor(const class APawn* Pawn);
    FVector GetLastMovementInputVector();
    FRotator GetControlRotation();
    class AController* GetController();
    FRotator GetBaseAimRotation();
    void DetachFromControllerPendingDestroy();
    FVector ConsumeMovementInputVector();
    void AddMovementInput(FVector WorldDirection, float ScaleValue, bool bForce);
    void AddControllerYawInput(float Val);
    void AddControllerRollInput(float Val);
    void AddControllerPitchInput(float Val);
}; // Size: 0x288

struct FBasedMovementInfo
{
    class UPrimitiveComponent* MovementBase;                                          // 0x0000 (size: 0x8)
    FName BoneName;                                                                   // 0x0008 (size: 0x8)
    FVector_NetQuantize100 Location;                                                  // 0x0010 (size: 0xC)
    FRotator Rotation;                                                                // 0x001C (size: 0xC)
    bool bServerHasBaseComponent;                                                     // 0x0028 (size: 0x1)
    bool bRelativeRotation;                                                           // 0x0029 (size: 0x1)
    bool bServerHasVelocity;                                                          // 0x002A (size: 0x1)

}; // Size: 0x30

struct FRootMotionSourceSettings
{
    uint8 Flags;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FVector_NetQuantize10 : public FVector
{
}; // Size: 0xC

struct FRootMotionSourceGroup
{
    uint8 bHasAdditiveSources;                                                        // 0x0028 (size: 0x1)
    uint8 bHasOverrideSources;                                                        // 0x0028 (size: 0x1)
    uint8 bHasOverrideSourcesWithIgnoreZAccumulate;                                   // 0x0028 (size: 0x1)
    uint8 bIsAdditiveVelocityApplied;                                                 // 0x0028 (size: 0x1)
    FRootMotionSourceSettings LastAccumulatedSettings;                                // 0x0029 (size: 0x1)
    FVector_NetQuantize10 LastPreAdditiveVelocity;                                    // 0x002C (size: 0xC)

}; // Size: 0x38

struct FRootMotionMovementParams
{
    bool bHasRootMotion;                                                              // 0x0000 (size: 0x1)
    float BlendWeight;                                                                // 0x0004 (size: 0x4)
    FTransform RootMotionTransform;                                                   // 0x0010 (size: 0x30)

}; // Size: 0x40

struct FRepRootMotionMontage
{
    bool bIsActive;                                                                   // 0x0000 (size: 0x1)
    class UAnimMontage* AnimMontage;                                                  // 0x0008 (size: 0x8)
    float Position;                                                                   // 0x0010 (size: 0x4)
    FVector_NetQuantize100 Location;                                                  // 0x0014 (size: 0xC)
    FRotator Rotation;                                                                // 0x0020 (size: 0xC)
    class UPrimitiveComponent* MovementBase;                                          // 0x0030 (size: 0x8)
    FName MovementBaseBoneName;                                                       // 0x0038 (size: 0x8)
    bool bRelativePosition;                                                           // 0x0040 (size: 0x1)
    bool bRelativeRotation;                                                           // 0x0041 (size: 0x1)
    FRootMotionSourceGroup AuthoritativeRootMotion;                                   // 0x0048 (size: 0x38)
    FVector_NetQuantize10 Acceleration;                                               // 0x0080 (size: 0xC)
    FVector_NetQuantize10 LinearVelocity;                                             // 0x008C (size: 0xC)

}; // Size: 0x98

struct FSimulatedRootMotionReplicatedMove
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FRepRootMotionMontage RootMotion;                                                 // 0x0008 (size: 0x98)

}; // Size: 0xA0

struct FCharacterNetworkSerializationPackedBits
{
}; // Size: 0x98

struct FCharacterServerMovePackedBits : public FCharacterNetworkSerializationPackedBits
{
}; // Size: 0x98

struct FCharacterMoveResponsePackedBits : public FCharacterNetworkSerializationPackedBits
{
}; // Size: 0x98

class ACharacter : public APawn
{
    class USkeletalMeshComponent* Mesh;                                               // 0x0288 (size: 0x8)
    class UCharacterMovementComponent* CharacterMovement;                             // 0x0290 (size: 0x8)
    class UCapsuleComponent* CapsuleComponent;                                        // 0x0298 (size: 0x8)
    FBasedMovementInfo BasedMovement;                                                 // 0x02A0 (size: 0x30)
    FBasedMovementInfo ReplicatedBasedMovement;                                       // 0x02D0 (size: 0x30)
    float AnimRootMotionTranslationScale;                                             // 0x0300 (size: 0x4)
    FVector BaseTranslationOffset;                                                    // 0x0304 (size: 0xC)
    FQuat BaseRotationOffset;                                                         // 0x0310 (size: 0x10)
    float ReplicatedServerLastTransformUpdateTimeStamp;                               // 0x0320 (size: 0x4)
    float ReplayLastTransformUpdateTimeStamp;                                         // 0x0324 (size: 0x4)
    uint8 ReplicatedMovementMode;                                                     // 0x0328 (size: 0x1)
    bool bInBaseReplication;                                                          // 0x0329 (size: 0x1)
    float CrouchedEyeHeight;                                                          // 0x032C (size: 0x4)
    uint8 bIsCrouched;                                                                // 0x0330 (size: 0x1)
    uint8 bProxyIsJumpForceApplied;                                                   // 0x0330 (size: 0x1)
    uint8 bPressedJump;                                                               // 0x0330 (size: 0x1)
    uint8 bClientUpdating;                                                            // 0x0330 (size: 0x1)
    uint8 bClientWasFalling;                                                          // 0x0330 (size: 0x1)
    uint8 bClientResimulateRootMotion;                                                // 0x0330 (size: 0x1)
    uint8 bClientResimulateRootMotionSources;                                         // 0x0330 (size: 0x1)
    uint8 bSimGravityDisabled;                                                        // 0x0330 (size: 0x1)
    uint8 bClientCheckEncroachmentOnNetUpdate;                                        // 0x0331 (size: 0x1)
    uint8 bServerMoveIgnoreRootMotion;                                                // 0x0331 (size: 0x1)
    uint8 bWasJumping;                                                                // 0x0331 (size: 0x1)
    float JumpKeyHoldTime;                                                            // 0x0334 (size: 0x4)
    float JumpForceTimeRemaining;                                                     // 0x0338 (size: 0x4)
    float ProxyJumpForceStartedTime;                                                  // 0x033C (size: 0x4)
    float JumpMaxHoldTime;                                                            // 0x0340 (size: 0x4)
    int32 JumpMaxCount;                                                               // 0x0344 (size: 0x4)
    int32 JumpCurrentCount;                                                           // 0x0348 (size: 0x4)
    int32 JumpCurrentCountPreJump;                                                    // 0x034C (size: 0x4)
    FCharacterOnReachedJumpApex OnReachedJumpApex;                                    // 0x0358 (size: 0x10)
    void CharacterReachedApexSignature();
    FCharacterMovementModeChangedDelegate MovementModeChangedDelegate;                // 0x0378 (size: 0x10)
    void MovementModeChangedSignature(class ACharacter* Character, TEnumAsByte<EMovementMode> PrevMovementMode, uint8 PreviousCustomMode);
    FCharacterOnCharacterMovementUpdated OnCharacterMovementUpdated;                  // 0x0388 (size: 0x10)
    void CharacterMovementUpdatedSignature(float DeltaSeconds, FVector OldLocation, FVector OldVelocity);
    FRootMotionSourceGroup SavedRootMotion;                                           // 0x0398 (size: 0x38)
    FRootMotionMovementParams ClientRootMotionParams;                                 // 0x03D0 (size: 0x40)
    TArray<FSimulatedRootMotionReplicatedMove> RootMotionRepMoves;                    // 0x0410 (size: 0x10)
    FRepRootMotionMontage RepRootMotion;                                              // 0x0420 (size: 0x98)

    void UnCrouch(bool bClientSimulation);
    void StopJumping();
    void StopAnimMontage(class UAnimMontage* AnimMontage);
    void ServerMovePacked(const FCharacterServerMovePackedBits& PackedBits);
    void ServerMoveOld(float OldTimeStamp, FVector_NetQuantize10 OldAccel, uint8 OldMoveFlags);
    void ServerMoveNoBase(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode);
    void ServerMoveDualNoBase(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode);
    void ServerMoveDualHybridRootMotion(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void ServerMoveDual(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void ServerMove(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void RootMotionDebugClientPrintOnScreen(FString inString);
    float PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, FName StartSectionName);
    void OnWalkingOffLedge(const FVector& PreviousFloorImpactNormal, const FVector& PreviousFloorContactNormal, const FVector& PreviousLocation, float TimeDelta);
    void OnRep_RootMotion();
    void OnRep_ReplicatedBasedMovement();
    void OnRep_ReplayLastTransformUpdateTimeStamp();
    void OnRep_IsCrouched();
    void OnLaunched(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void OnLanded(const FHitResult& Hit);
    void OnJumped();
    void LaunchCharacter(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void K2_UpdateCustomMovement(float DeltaTime);
    void K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void K2_OnMovementModeChanged(TEnumAsByte<EMovementMode> PrevMovementMode, TEnumAsByte<EMovementMode> NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode);
    void K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void Jump();
    bool IsPlayingRootMotion();
    bool IsPlayingNetworkedRootMotionMontage();
    bool IsJumpProvidingForce();
    bool HasAnyRootMotion();
    class UAnimMontage* GetCurrentMontage();
    FVector GetBaseTranslationOffset();
    FRotator GetBaseRotationOffsetRotator();
    float GetAnimRootMotionTranslationScale();
    void Crouch(bool bClientSimulation);
    void ClientVeryShortAdjustPosition(float Timestamp, FVector NewLoc, class UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientMoveResponsePacked(const FCharacterMoveResponsePackedBits& PackedBits);
    void ClientCheatWalk();
    void ClientCheatGhost();
    void ClientCheatFly();
    void ClientAdjustRootMotionSourcePosition(float Timestamp, FRootMotionSourceGroup ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAdjustPosition(float Timestamp, FVector NewLoc, FVector NewVel, class UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAckGoodMove(float Timestamp);
    bool CanJumpInternal();
    bool CanJump();
    bool CanCrouch();
    void CacheInitialMeshOffset(FVector MeshRelativeLocation, FRotator MeshRelativeRotation);
}; // Size: 0x4C0

class UMovementComponent : public UActorComponent
{
    class USceneComponent* UpdatedComponent;                                          // 0x00B0 (size: 0x8)
    class UPrimitiveComponent* UpdatedPrimitive;                                      // 0x00B8 (size: 0x8)
    FVector Velocity;                                                                 // 0x00C4 (size: 0xC)
    FVector PlaneConstraintNormal;                                                    // 0x00D0 (size: 0xC)
    FVector PlaneConstraintOrigin;                                                    // 0x00DC (size: 0xC)
    uint8 bUpdateOnlyIfRendered;                                                      // 0x00E8 (size: 0x1)
    uint8 bAutoUpdateTickRegistration;                                                // 0x00E8 (size: 0x1)
    uint8 bTickBeforeOwner;                                                           // 0x00E8 (size: 0x1)
    uint8 bAutoRegisterUpdatedComponent;                                              // 0x00E8 (size: 0x1)
    uint8 bConstrainToPlane;                                                          // 0x00E8 (size: 0x1)
    uint8 bSnapToPlaneAtStart;                                                        // 0x00E8 (size: 0x1)
    uint8 bAutoRegisterPhysicsVolumeUpdates;                                          // 0x00E8 (size: 0x1)
    uint8 bComponentShouldUpdatePhysicsVolume;                                        // 0x00E8 (size: 0x1)
    EPlaneConstraintAxisSetting PlaneConstraintAxisSetting;                           // 0x00EB (size: 0x1)

    void StopMovementImmediately();
    void SnapUpdatedComponentToPlane();
    void SetUpdatedComponent(class USceneComponent* NewUpdatedComponent);
    void SetPlaneConstraintOrigin(FVector PlaneOrigin);
    void SetPlaneConstraintNormal(FVector PlaneNormal);
    void SetPlaneConstraintFromVectors(FVector Forward, FVector Up);
    void SetPlaneConstraintEnabled(bool bEnabled);
    void SetPlaneConstraintAxisSetting(EPlaneConstraintAxisSetting NewAxisSetting);
    void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);
    bool K2_MoveUpdatedComponent(FVector Delta, FRotator NewRotation, FHitResult& OutHit, bool bSweep, bool bTeleport);
    float K2_GetModifiedMaxSpeed();
    float K2_GetMaxSpeedModifier();
    bool IsExceedingMaxSpeed(float MaxSpeed);
    FVector GetPlaneConstraintOrigin();
    FVector GetPlaneConstraintNormal();
    EPlaneConstraintAxisSetting GetPlaneConstraintAxisSetting();
    class APhysicsVolume* GetPhysicsVolume();
    float GetMaxSpeed();
    float GetGravityZ();
    FVector ConstrainNormalToPlane(FVector Normal);
    FVector ConstrainLocationToPlane(FVector Location);
    FVector ConstrainDirectionToPlane(FVector Direction);
}; // Size: 0xF0

struct FMovementProperties
{
    uint8 bCanCrouch;                                                                 // 0x0000 (size: 0x1)
    uint8 bCanJump;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanWalk;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanSwim;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanFly;                                                                    // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FNavAgentProperties : public FMovementProperties
{
    float AgentRadius;                                                                // 0x0004 (size: 0x4)
    float AgentHeight;                                                                // 0x0008 (size: 0x4)
    float AgentStepHeight;                                                            // 0x000C (size: 0x4)
    float NavWalkingSearchHeightScale;                                                // 0x0010 (size: 0x4)
    FSoftClassPath PreferredNavData;                                                  // 0x0018 (size: 0x18)

}; // Size: 0x30

class UNavMovementComponent : public UMovementComponent
{
    FNavAgentProperties NavAgentProps;                                                // 0x00F0 (size: 0x30)
    float FixedPathBrakingDistance;                                                   // 0x0120 (size: 0x4)
    uint8 bUpdateNavAgentWithOwnersCollision;                                         // 0x0124 (size: 0x1)
    uint8 bUseAccelerationForPaths;                                                   // 0x0124 (size: 0x1)
    uint8 bUseFixedBrakingDistanceForPaths;                                           // 0x0124 (size: 0x1)
    FMovementProperties MovementState;                                                // 0x0125 (size: 0x1)
    class UObject* PathFollowingComp;                                                 // 0x0128 (size: 0x8)

    void StopMovementKeepPathing();
    void StopActiveMovement();
    bool IsSwimming();
    bool IsMovingOnGround();
    bool IsFlying();
    bool IsFalling();
    bool IsCrouching();
}; // Size: 0x130

class UPawnMovementComponent : public UNavMovementComponent
{
    class APawn* PawnOwner;                                                           // 0x0130 (size: 0x8)

    FVector K2_GetInputVector();
    bool IsMoveInputIgnored();
    FVector GetPendingInputVector();
    class APawn* GetPawnOwner();
    FVector GetLastInputVector();
    FVector ConsumeInputVector();
    void AddInputVector(FVector WorldVector, bool bForce);
}; // Size: 0x138

struct FFindFloorResult
{
    uint8 bBlockingHit;                                                               // 0x0000 (size: 0x1)
    uint8 bWalkableFloor;                                                             // 0x0000 (size: 0x1)
    uint8 bLineTrace;                                                                 // 0x0000 (size: 0x1)
    float FloorDist;                                                                  // 0x0004 (size: 0x4)
    float LineDist;                                                                   // 0x0008 (size: 0x4)
    FHitResult HitResult;                                                             // 0x000C (size: 0x88)

}; // Size: 0x94

struct FNavAvoidanceMask
{
    uint8 bGroup0;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup1;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup2;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup3;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup4;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup5;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup6;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup7;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup8;                                                                    // 0x0001 (size: 0x1)
    uint8 bGroup9;                                                                    // 0x0001 (size: 0x1)
    uint8 bGroup10;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup11;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup12;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup13;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup14;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup15;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup16;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup17;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup18;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup19;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup20;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup21;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup22;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup23;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup24;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup25;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup26;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup27;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup28;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup29;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup30;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup31;                                                                   // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FCharacterMovementComponentPostPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

class UCharacterMovementComponent : public UPawnMovementComponent
{
    class ACharacter* CharacterOwner;                                                 // 0x0148 (size: 0x8)
    float GravityScale;                                                               // 0x0150 (size: 0x4)
    float MaxStepHeight;                                                              // 0x0154 (size: 0x4)
    float JumpZVelocity;                                                              // 0x0158 (size: 0x4)
    float JumpOffJumpZFactor;                                                         // 0x015C (size: 0x4)
    float WalkableFloorAngle;                                                         // 0x0160 (size: 0x4)
    float WalkableFloorZ;                                                             // 0x0164 (size: 0x4)
    TEnumAsByte<EMovementMode> MovementMode;                                          // 0x0168 (size: 0x1)
    uint8 CustomMovementMode;                                                         // 0x0169 (size: 0x1)
    ENetworkSmoothingMode NetworkSmoothingMode;                                       // 0x016A (size: 0x1)
    float GroundFriction;                                                             // 0x016C (size: 0x4)
    float MaxWalkSpeed;                                                               // 0x018C (size: 0x4)
    float MaxWalkSpeedCrouched;                                                       // 0x0190 (size: 0x4)
    float MaxSwimSpeed;                                                               // 0x0194 (size: 0x4)
    float MaxFlySpeed;                                                                // 0x0198 (size: 0x4)
    float MaxCustomMovementSpeed;                                                     // 0x019C (size: 0x4)
    float MaxAcceleration;                                                            // 0x01A0 (size: 0x4)
    float MinAnalogWalkSpeed;                                                         // 0x01A4 (size: 0x4)
    float BrakingFrictionFactor;                                                      // 0x01A8 (size: 0x4)
    float BrakingFriction;                                                            // 0x01AC (size: 0x4)
    float BrakingSubStepTime;                                                         // 0x01B0 (size: 0x4)
    float BrakingDecelerationWalking;                                                 // 0x01B4 (size: 0x4)
    float BrakingDecelerationFalling;                                                 // 0x01B8 (size: 0x4)
    float BrakingDecelerationSwimming;                                                // 0x01BC (size: 0x4)
    float BrakingDecelerationFlying;                                                  // 0x01C0 (size: 0x4)
    float AirControl;                                                                 // 0x01C4 (size: 0x4)
    float AirControlBoostMultiplier;                                                  // 0x01C8 (size: 0x4)
    float AirControlBoostVelocityThreshold;                                           // 0x01CC (size: 0x4)
    float FallingLateralFriction;                                                     // 0x01D0 (size: 0x4)
    float CrouchedHalfHeight;                                                         // 0x01D4 (size: 0x4)
    float Buoyancy;                                                                   // 0x01D8 (size: 0x4)
    float PerchRadiusThreshold;                                                       // 0x01DC (size: 0x4)
    float PerchAdditionalHeight;                                                      // 0x01E0 (size: 0x4)
    FRotator RotationRate;                                                            // 0x01E4 (size: 0xC)
    uint8 bUseSeparateBrakingFriction;                                                // 0x01F0 (size: 0x1)
    uint8 bApplyGravityWhileJumping;                                                  // 0x01F0 (size: 0x1)
    uint8 bUseControllerDesiredRotation;                                              // 0x01F0 (size: 0x1)
    uint8 bOrientRotationToMovement;                                                  // 0x01F0 (size: 0x1)
    uint8 bSweepWhileNavWalking;                                                      // 0x01F0 (size: 0x1)
    uint8 bMovementInProgress;                                                        // 0x01F0 (size: 0x1)
    uint8 bEnableScopedMovementUpdates;                                               // 0x01F0 (size: 0x1)
    uint8 bEnableServerDualMoveScopedMovementUpdates;                                 // 0x01F1 (size: 0x1)
    uint8 bForceMaxAccel;                                                             // 0x01F1 (size: 0x1)
    uint8 bRunPhysicsWithNoController;                                                // 0x01F1 (size: 0x1)
    uint8 bForceNextFloorCheck;                                                       // 0x01F1 (size: 0x1)
    uint8 bShrinkProxyCapsule;                                                        // 0x01F1 (size: 0x1)
    uint8 bCanWalkOffLedges;                                                          // 0x01F1 (size: 0x1)
    uint8 bCanWalkOffLedgesWhenCrouching;                                             // 0x01F1 (size: 0x1)
    uint8 bNetworkSkipProxyPredictionOnNetUpdate;                                     // 0x01F2 (size: 0x1)
    uint8 bNetworkAlwaysReplicateTransformUpdateTimestamp;                            // 0x01F2 (size: 0x1)
    uint8 bDeferUpdateMoveComponent;                                                  // 0x01F2 (size: 0x1)
    uint8 bEnablePhysicsInteraction;                                                  // 0x01F2 (size: 0x1)
    uint8 bTouchForceScaledToMass;                                                    // 0x01F2 (size: 0x1)
    uint8 bPushForceScaledToMass;                                                     // 0x01F2 (size: 0x1)
    uint8 bPushForceUsingZOffset;                                                     // 0x01F2 (size: 0x1)
    uint8 bScalePushForceToVelocity;                                                  // 0x01F3 (size: 0x1)
    class USceneComponent* DeferredUpdatedMoveComponent;                              // 0x01F8 (size: 0x8)
    float MaxOutOfWaterStepHeight;                                                    // 0x0200 (size: 0x4)
    float OutofWaterZ;                                                                // 0x0204 (size: 0x4)
    float Mass;                                                                       // 0x0208 (size: 0x4)
    float StandingDownwardForceScale;                                                 // 0x020C (size: 0x4)
    float InitialPushForceFactor;                                                     // 0x0210 (size: 0x4)
    float PushForceFactor;                                                            // 0x0214 (size: 0x4)
    float PushForcePointZOffsetFactor;                                                // 0x0218 (size: 0x4)
    float TouchForceFactor;                                                           // 0x021C (size: 0x4)
    float MinTouchForce;                                                              // 0x0220 (size: 0x4)
    float MaxTouchForce;                                                              // 0x0224 (size: 0x4)
    float RepulsionForce;                                                             // 0x0228 (size: 0x4)
    FVector Acceleration;                                                             // 0x022C (size: 0xC)
    FQuat LastUpdateRotation;                                                         // 0x0240 (size: 0x10)
    FVector LastUpdateLocation;                                                       // 0x0250 (size: 0xC)
    FVector LastUpdateVelocity;                                                       // 0x025C (size: 0xC)
    float ServerLastTransformUpdateTimeStamp;                                         // 0x0268 (size: 0x4)
    float ServerLastClientGoodMoveAckTime;                                            // 0x026C (size: 0x4)
    float ServerLastClientAdjustmentTime;                                             // 0x0270 (size: 0x4)
    FVector PendingImpulseToApply;                                                    // 0x0274 (size: 0xC)
    FVector PendingForceToApply;                                                      // 0x0280 (size: 0xC)
    float AnalogInputModifier;                                                        // 0x028C (size: 0x4)
    float MaxSimulationTimeStep;                                                      // 0x029C (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x02A0 (size: 0x4)
    int32 MaxJumpApexAttemptsPerSimulation;                                           // 0x02A4 (size: 0x4)
    float MaxDepenetrationWithGeometry;                                               // 0x02A8 (size: 0x4)
    float MaxDepenetrationWithGeometryAsProxy;                                        // 0x02AC (size: 0x4)
    float MaxDepenetrationWithPawn;                                                   // 0x02B0 (size: 0x4)
    float MaxDepenetrationWithPawnAsProxy;                                            // 0x02B4 (size: 0x4)
    float NetworkSimulatedSmoothLocationTime;                                         // 0x02B8 (size: 0x4)
    float NetworkSimulatedSmoothRotationTime;                                         // 0x02BC (size: 0x4)
    float ListenServerNetworkSimulatedSmoothLocationTime;                             // 0x02C0 (size: 0x4)
    float ListenServerNetworkSimulatedSmoothRotationTime;                             // 0x02C4 (size: 0x4)
    float NetProxyShrinkRadius;                                                       // 0x02C8 (size: 0x4)
    float NetProxyShrinkHalfHeight;                                                   // 0x02CC (size: 0x4)
    float NetworkMaxSmoothUpdateDistance;                                             // 0x02D0 (size: 0x4)
    float NetworkNoSmoothUpdateDistance;                                              // 0x02D4 (size: 0x4)
    float NetworkMinTimeBetweenClientAckGoodMoves;                                    // 0x02D8 (size: 0x4)
    float NetworkMinTimeBetweenClientAdjustments;                                     // 0x02DC (size: 0x4)
    float NetworkMinTimeBetweenClientAdjustmentsLargeCorrection;                      // 0x02E0 (size: 0x4)
    float NetworkLargeClientCorrectionDistance;                                       // 0x02E4 (size: 0x4)
    float LedgeCheckThreshold;                                                        // 0x02E8 (size: 0x4)
    float JumpOutOfWaterPitch;                                                        // 0x02EC (size: 0x4)
    FFindFloorResult CurrentFloor;                                                    // 0x02F0 (size: 0x94)
    TEnumAsByte<EMovementMode> DefaultLandMovementMode;                               // 0x0384 (size: 0x1)
    TEnumAsByte<EMovementMode> DefaultWaterMovementMode;                              // 0x0385 (size: 0x1)
    TEnumAsByte<EMovementMode> GroundMovementMode;                                    // 0x0386 (size: 0x1)
    uint8 bMaintainHorizontalGroundVelocity;                                          // 0x0387 (size: 0x1)
    uint8 bImpartBaseVelocityX;                                                       // 0x0387 (size: 0x1)
    uint8 bImpartBaseVelocityY;                                                       // 0x0387 (size: 0x1)
    uint8 bImpartBaseVelocityZ;                                                       // 0x0387 (size: 0x1)
    uint8 bImpartBaseAngularVelocity;                                                 // 0x0387 (size: 0x1)
    uint8 bJustTeleported;                                                            // 0x0387 (size: 0x1)
    uint8 bNetworkUpdateReceived;                                                     // 0x0387 (size: 0x1)
    uint8 bNetworkMovementModeChanged;                                                // 0x0387 (size: 0x1)
    uint8 bIgnoreClientMovementErrorChecksAndCorrection;                              // 0x0388 (size: 0x1)
    uint8 bServerAcceptClientAuthoritativePosition;                                   // 0x0388 (size: 0x1)
    uint8 bNotifyApex;                                                                // 0x0388 (size: 0x1)
    uint8 bCheatFlying;                                                               // 0x0388 (size: 0x1)
    uint8 bWantsToCrouch;                                                             // 0x0388 (size: 0x1)
    uint8 bCrouchMaintainsBaseLocation;                                               // 0x0388 (size: 0x1)
    uint8 bIgnoreBaseRotation;                                                        // 0x0388 (size: 0x1)
    uint8 bFastAttachedMove;                                                          // 0x0388 (size: 0x1)
    uint8 bAlwaysCheckFloor;                                                          // 0x0389 (size: 0x1)
    uint8 bUseFlatBaseForFloorChecks;                                                 // 0x0389 (size: 0x1)
    uint8 bPerformingJumpOff;                                                         // 0x0389 (size: 0x1)
    uint8 bWantsToLeaveNavWalking;                                                    // 0x0389 (size: 0x1)
    uint8 bUseRVOAvoidance;                                                           // 0x0389 (size: 0x1)
    uint8 bRequestedMoveUseAcceleration;                                              // 0x0389 (size: 0x1)
    uint8 bWasSimulatingRootMotion;                                                   // 0x0389 (size: 0x1)
    uint8 bAllowPhysicsRotationDuringAnimRootMotion;                                  // 0x038A (size: 0x1)
    uint8 bHasRequestedVelocity;                                                      // 0x038A (size: 0x1)
    uint8 bRequestedMoveWithMaxSpeed;                                                 // 0x038A (size: 0x1)
    uint8 bWasAvoidanceUpdated;                                                       // 0x038A (size: 0x1)
    uint8 bProjectNavMeshWalking;                                                     // 0x038A (size: 0x1)
    uint8 bProjectNavMeshOnBothWorldChannels;                                         // 0x038A (size: 0x1)
    float AvoidanceConsiderationRadius;                                               // 0x039C (size: 0x4)
    FVector RequestedVelocity;                                                        // 0x03A0 (size: 0xC)
    int32 AvoidanceUID;                                                               // 0x03AC (size: 0x4)
    FNavAvoidanceMask AvoidanceGroup;                                                 // 0x03B0 (size: 0x4)
    FNavAvoidanceMask GroupsToAvoid;                                                  // 0x03B4 (size: 0x4)
    FNavAvoidanceMask GroupsToIgnore;                                                 // 0x03B8 (size: 0x4)
    float AvoidanceWeight;                                                            // 0x03BC (size: 0x4)
    FVector PendingLaunchVelocity;                                                    // 0x03C0 (size: 0xC)
    float NavMeshProjectionInterval;                                                  // 0x0470 (size: 0x4)
    float NavMeshProjectionTimer;                                                     // 0x0474 (size: 0x4)
    float NavMeshProjectionInterpSpeed;                                               // 0x0478 (size: 0x4)
    float NavMeshProjectionHeightScaleUp;                                             // 0x047C (size: 0x4)
    float NavMeshProjectionHeightScaleDown;                                           // 0x0480 (size: 0x4)
    float NavWalkingFloorDistTolerance;                                               // 0x0484 (size: 0x4)
    FCharacterMovementComponentPostPhysicsTickFunction PostPhysicsTickFunction;       // 0x0488 (size: 0x30)
    float MinTimeBetweenTimeStampResets;                                              // 0x04D0 (size: 0x4)
    FRootMotionSourceGroup CurrentRootMotion;                                         // 0x0980 (size: 0x38)
    FRootMotionSourceGroup ServerCorrectionRootMotion;                                // 0x09B8 (size: 0x38)
    FRootMotionMovementParams RootMotionParams;                                       // 0x0A80 (size: 0x40)
    FVector AnimRootMotionVelocity;                                                   // 0x0AC0 (size: 0xC)

    void SetWalkableFloorZ(float InWalkableFloorZ);
    void SetWalkableFloorAngle(float InWalkableFloorAngle);
    void SetMovementMode(TEnumAsByte<EMovementMode> NewMovementMode, uint8 NewCustomMode);
    void SetGroupsToIgnoreMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToIgnore(int32 GroupFlags);
    void SetGroupsToAvoidMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToAvoid(int32 GroupFlags);
    void SetAvoidanceGroupMask(const FNavAvoidanceMask& GroupMask);
    void SetAvoidanceGroup(int32 GroupFlags);
    void SetAvoidanceEnabled(bool bEnable);
    float K2_GetWalkableFloorZ();
    float K2_GetWalkableFloorAngle();
    float K2_GetModifiedMaxAcceleration();
    void K2_FindFloor(FVector CapsuleLocation, FFindFloorResult& FloorResult);
    void K2_ComputeFloorDist(FVector CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, FFindFloorResult& FloorResult);
    bool IsWalking();
    bool IsWalkable(const FHitResult& Hit);
    float GetValidPerchRadius();
    float GetPerchRadiusThreshold();
    class UPrimitiveComponent* GetMovementBase();
    float GetMinAnalogSpeed();
    float GetMaxJumpHeightWithJumpTime();
    float GetMaxJumpHeight();
    float GetMaxBrakingDeceleration();
    float GetMaxAcceleration();
    FVector GetLastUpdateVelocity();
    FRotator GetLastUpdateRotation();
    FVector GetLastUpdateLocation();
    FVector GetImpartedMovementBaseVelocity();
    FVector GetCurrentAcceleration();
    class ACharacter* GetCharacterOwner();
    float GetAnalogInputModifier();
    void DisableMovement();
    void ClearAccumulatedForces();
    void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
    void AddImpulse(FVector Impulse, bool bVelocityChange);
    void AddForce(FVector Force);
}; // Size: 0xAF0

class USubsystem : public UObject
{
}; // Size: 0x30

class UDynamicSubsystem : public USubsystem
{
}; // Size: 0x30

class UEngineSubsystem : public UDynamicSubsystem
{
}; // Size: 0x30

struct FComponentReference
{
    class AActor* OtherActor;                                                         // 0x0000 (size: 0x8)
    FName ComponentProperty;                                                          // 0x0008 (size: 0x8)
    FString PathToComponent;                                                          // 0x0010 (size: 0x10)

}; // Size: 0x28

class UTimecodeProvider : public UObject
{
    float FrameDelay;                                                                 // 0x0028 (size: 0x4)

    FTimecode GetTimecode();
    ETimecodeProviderSynchronizationState GetSynchronizationState();
    FQualifiedFrameTime GetQualifiedFrameTime();
    FFrameRate GetFrameRate();
    FTimecode GetDelayedTimecode();
    FQualifiedFrameTime GetDelayedQualifiedFrameTime();
    bool FetchTimecode(FQualifiedFrameTime& OutFrameTime);
    void FetchAndUpdate();
}; // Size: 0x30

class UGameInstanceSubsystem : public USubsystem
{
}; // Size: 0x30

class UPrimaryDataAsset : public UDataAsset
{
}; // Size: 0x30

class UShapeComponent : public UPrimitiveComponent
{
    class UBodySetup* ShapeBodySetup;                                                 // 0x0450 (size: 0x8)
    TSubclassOf<class UNavAreaBase> AreaClass;                                        // 0x0458 (size: 0x8)
    FColor ShapeColor;                                                                // 0x0460 (size: 0x4)
    uint8 bDrawOnlyIfSelected;                                                        // 0x0464 (size: 0x1)
    uint8 bShouldCollideWhenPlacing;                                                  // 0x0464 (size: 0x1)
    uint8 bDynamicObstacle;                                                           // 0x0464 (size: 0x1)

}; // Size: 0x470

class USphereComponent : public UShapeComponent
{
    float SphereRadius;                                                               // 0x0468 (size: 0x4)

    void SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps);
    float GetUnscaledSphereRadius();
    float GetShapeScale();
    float GetScaledSphereRadius();
}; // Size: 0x470

class ULightComponentBase : public USceneComponent
{
    FGuid LightGuid;                                                                  // 0x01F8 (size: 0x10)
    float Brightness;                                                                 // 0x0208 (size: 0x4)
    float Intensity;                                                                  // 0x020C (size: 0x4)
    FColor LightColor;                                                                // 0x0210 (size: 0x4)
    uint8 bAffectsWorld;                                                              // 0x0214 (size: 0x1)
    uint8 CastShadows;                                                                // 0x0214 (size: 0x1)
    uint8 CastStaticShadows;                                                          // 0x0214 (size: 0x1)
    uint8 CastDynamicShadows;                                                         // 0x0214 (size: 0x1)
    uint8 bAffectTranslucentLighting;                                                 // 0x0214 (size: 0x1)
    uint8 bTransmission;                                                              // 0x0214 (size: 0x1)
    uint8 bCastVolumetricShadow;                                                      // 0x0214 (size: 0x1)
    uint8 bCastDeepShadow;                                                            // 0x0214 (size: 0x1)
    uint8 bCastRaytracedShadow;                                                       // 0x0215 (size: 0x1)
    uint8 bAffectReflection;                                                          // 0x0215 (size: 0x1)
    uint8 bAffectGlobalIllumination;                                                  // 0x0215 (size: 0x1)
    float DeepShadowLayerDistribution;                                                // 0x0218 (size: 0x4)
    float IndirectLightingIntensity;                                                  // 0x021C (size: 0x4)
    float VolumetricScatteringIntensity;                                              // 0x0220 (size: 0x4)
    int32 SamplesPerPixel;                                                            // 0x0224 (size: 0x4)

    void SetSamplesPerPixel(int32 newValue);
    void SetCastVolumetricShadow(bool bNewValue);
    void SetCastShadows(bool bNewValue);
    void SetCastRaytracedShadow(bool bNewValue);
    void SetCastDeepShadow(bool bNewValue);
    void SetAffectReflection(bool bNewValue);
    void SetAffectGlobalIllumination(bool bNewValue);
    FLinearColor GetLightColor();
}; // Size: 0x230

class ULightComponent : public ULightComponentBase
{
    float Temperature;                                                                // 0x0228 (size: 0x4)
    float MaxDrawDistance;                                                            // 0x022C (size: 0x4)
    float MaxDistanceFadeRange;                                                       // 0x0230 (size: 0x4)
    uint8 bUseTemperature;                                                            // 0x0234 (size: 0x1)
    int32 ShadowMapChannel;                                                           // 0x0238 (size: 0x4)
    float MinRoughness;                                                               // 0x0240 (size: 0x4)
    float SpecularScale;                                                              // 0x0244 (size: 0x4)
    float ShadowResolutionScale;                                                      // 0x0248 (size: 0x4)
    float ShadowBias;                                                                 // 0x024C (size: 0x4)
    float ShadowSlopeBias;                                                            // 0x0250 (size: 0x4)
    float ShadowSharpen;                                                              // 0x0254 (size: 0x4)
    float ContactShadowLength;                                                        // 0x0258 (size: 0x4)
    uint8 ContactShadowLengthInWS;                                                    // 0x025C (size: 0x1)
    uint8 InverseSquaredFalloff;                                                      // 0x025C (size: 0x1)
    uint8 CastTranslucentShadows;                                                     // 0x025C (size: 0x1)
    uint8 bCastShadowsFromCinematicObjectsOnly;                                       // 0x025C (size: 0x1)
    uint8 bAffectDynamicIndirectLighting;                                             // 0x025C (size: 0x1)
    uint8 bForceCachedShadowsForMovablePrimitives;                                    // 0x025C (size: 0x1)
    FLightingChannels LightingChannels;                                               // 0x0260 (size: 0x1)
    class UMaterialInterface* LightFunctionMaterial;                                  // 0x0268 (size: 0x8)
    FVector LightFunctionScale;                                                       // 0x0270 (size: 0xC)
    class UTextureLightProfile* IESTexture;                                           // 0x0280 (size: 0x8)
    uint8 bUseIESBrightness;                                                          // 0x0288 (size: 0x1)
    float IESBrightnessScale;                                                         // 0x028C (size: 0x4)
    float LightFunctionFadeDistance;                                                  // 0x0290 (size: 0x4)
    float DisabledBrightness;                                                         // 0x0294 (size: 0x4)
    uint8 bEnableLightShaftBloom;                                                     // 0x0298 (size: 0x1)
    float BloomScale;                                                                 // 0x029C (size: 0x4)
    float BloomThreshold;                                                             // 0x02A0 (size: 0x4)
    float BloomMaxBrightness;                                                         // 0x02A4 (size: 0x4)
    FColor BloomTint;                                                                 // 0x02A8 (size: 0x4)
    bool bUseRayTracedDistanceFieldShadows;                                           // 0x02AC (size: 0x1)
    float RayStartOffsetDepthScale;                                                   // 0x02B0 (size: 0x4)

    void SetVolumetricScatteringIntensity(float NewIntensity);
    void SetUseTemperature(bool bNewValue);
    void SetUseIESBrightness(bool bNewValue);
    void SetTransmission(bool bNewValue);
    void SetTemperature(float NewTemperature);
    void SetSpecularScale(float newValue);
    void SetShadowSlopeBias(float newValue);
    void SetShadowBias(float newValue);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightFunctionDisabledBrightness(float newValue);
    void SetLightColor(FLinearColor NewLightColor, bool bSRGB);
    void SetIntensity(float NewIntensity);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetIESTexture(class UTextureLightProfile* newValue);
    void SetIESBrightnessScale(float newValue);
    void SetForceCachedShadowsForMovablePrimitives(bool bNewValue);
    void SetEnableLightShaftBloom(bool bNewValue);
    void SetBloomTint(FColor newValue);
    void SetBloomThreshold(float newValue);
    void SetBloomScale(float newValue);
    void SetBloomMaxBrightness(float newValue);
    void SetAffectTranslucentLighting(bool bNewValue);
    void SetAffectDynamicIndirectLighting(bool bNewValue);
}; // Size: 0x330

struct FLightmassLightSettings
{
    float IndirectLightingSaturation;                                                 // 0x0000 (size: 0x4)
    float ShadowExponent;                                                             // 0x0004 (size: 0x4)
    bool bUseAreaShadowsForStationaryLight;                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FLightmassPointLightSettings : public FLightmassLightSettings
{
}; // Size: 0xC

class ULocalLightComponent : public ULightComponent
{
    ELightUnits IntensityUnits;                                                       // 0x0328 (size: 0x1)
    float Radius;                                                                     // 0x032C (size: 0x4)
    float AttenuationRadius;                                                          // 0x0330 (size: 0x4)
    FLightmassPointLightSettings LightmassSettings;                                   // 0x0334 (size: 0xC)

    void SetIntensityUnits(ELightUnits NewIntensityUnits);
    void SetAttenuationRadius(float NewRadius);
    float GetUnitsConversionFactor(ELightUnits SrcUnits, ELightUnits TargetUnits, float CosHalfConeAngle);
}; // Size: 0x340

class UPointLightComponent : public ULocalLightComponent
{
    uint8 bUseInverseSquaredFalloff;                                                  // 0x0340 (size: 0x1)
    float LightFalloffExponent;                                                       // 0x0344 (size: 0x4)
    float SourceRadius;                                                               // 0x0348 (size: 0x4)
    float SoftSourceRadius;                                                           // 0x034C (size: 0x4)
    float SourceLength;                                                               // 0x0350 (size: 0x4)

    void SetSourceRadius(float bNewValue);
    void SetSourceLength(float newValue);
    void SetSoftSourceRadius(float bNewValue);
    void SetLightFalloffExponent(float NewLightFalloffExponent);
}; // Size: 0x360

class USpotLightComponent : public UPointLightComponent
{
    float InnerConeAngle;                                                             // 0x0358 (size: 0x4)
    float OuterConeAngle;                                                             // 0x035C (size: 0x4)

    void SetOuterConeAngle(float NewOuterConeAngle);
    void SetInnerConeAngle(float NewInnerConeAngle);
}; // Size: 0x360

class UBoxComponent : public UShapeComponent
{
    FVector BoxExtent;                                                                // 0x0468 (size: 0xC)
    float LineThickness;                                                              // 0x0474 (size: 0x4)

    void SetBoxExtent(FVector InBoxExtent, bool bUpdateOverlaps);
    FVector GetUnscaledBoxExtent();
    FVector GetScaledBoxExtent();
}; // Size: 0x480

class UCheatManager : public UObject
{
    class ADebugCameraController* DebugCameraControllerRef;                           // 0x0028 (size: 0x8)
    TSubclassOf<class ADebugCameraController> DebugCameraControllerClass;             // 0x0030 (size: 0x8)
    TArray<class UCheatManagerExtension*> CheatManagerExtensions;                     // 0x0078 (size: 0x10)

    void Walk();
    void ViewSelf();
    void ViewPlayer(FString S);
    void ViewClass(TSubclassOf<class AActor> DesiredClass);
    void ViewActor(FName ActorName);
    void UpdateSafeArea();
    void ToggleServerStatReplicatorUpdateStatNet();
    void ToggleServerStatReplicatorClientOverwrite();
    void ToggleDebugCamera();
    void ToggleAILogging();
    void TestCollisionDistance();
    void Teleport();
    void Summon(FString ClassName);
    void StreamLevelOut(FName PackageName);
    void StreamLevelIn(FName PackageName);
    void SpawnServerStatReplicator();
    void Slomo(float NewTimeDilation);
    void SetWorldOrigin();
    void SetMouseSensitivityToDefault();
    void ServerToggleAILogging();
    void ReceiveInitCheatManager();
    void ReceiveEndPlay();
    void PlayersOnly();
    void OnlyLoadLevel(FName PackageName);
    void LogLoc();
    void InvertMouse();
    void God();
    void Ghost();
    void FreezeFrame(float Delay);
    void Fly();
    void FlushLog();
    void EnableDebugCamera();
    void DumpVoiceMutingState();
    void DumpPartyState();
    void DumpOnlineSessionState();
    void DumpChatState();
    void DisableDebugCamera();
    void DestroyTarget();
    void DestroyServerStatReplicator();
    void DestroyPawns(TSubclassOf<class APawn> aClass);
    void DestroyAllPawnsExceptTarget();
    void DestroyAll(TSubclassOf<class AActor> aClass);
    void DebugCapsuleSweepSize(float HalfHeight, float Radius);
    void DebugCapsuleSweepPawn();
    void DebugCapsuleSweepComplex(bool bTraceComplex);
    void DebugCapsuleSweepClear();
    void DebugCapsuleSweepChannel(TEnumAsByte<ECollisionChannel> Channel);
    void DebugCapsuleSweepCapture();
    void DebugCapsuleSweep();
    void DamageTarget(float DamageAmount);
    void CheatScript(FString ScriptName);
    void ChangeSize(float F);
    void BugItStringCreator(FVector ViewLocation, FRotator ViewRotation, FString& GoString, FString& LocString);
    void BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll);
    void BugIt(FString ScreenShotDescription);
}; // Size: 0x88

struct FStatColorMapEntry
{
    float In;                                                                         // 0x0000 (size: 0x4)
    FColor Out;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FStatColorMapping
{
    FString StatName;                                                                 // 0x0000 (size: 0x10)
    TArray<FStatColorMapEntry> ColorMap;                                              // 0x0010 (size: 0x10)
    uint8 DisableBlend;                                                               // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FGameNameRedirect
{
    FName OldGameName;                                                                // 0x0000 (size: 0x8)
    FName NewGameName;                                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FClassRedirect
{
    FName ObjectName;                                                                 // 0x0000 (size: 0x8)
    FName OldClassName;                                                               // 0x0008 (size: 0x8)
    FName NewClassName;                                                               // 0x0010 (size: 0x8)
    FName OldSubobjName;                                                              // 0x0018 (size: 0x8)
    FName NewSubobjName;                                                              // 0x0020 (size: 0x8)
    FName NewClassClass;                                                              // 0x0028 (size: 0x8)
    FName NewClassPackage;                                                            // 0x0030 (size: 0x8)
    bool InstanceOnly;                                                                // 0x0038 (size: 0x1)

}; // Size: 0x3C

struct FPluginRedirect
{
    FString OldPluginName;                                                            // 0x0000 (size: 0x10)
    FString NewPluginName;                                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FStructRedirect
{
    FName OldStructName;                                                              // 0x0000 (size: 0x8)
    FName NewStructName;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDropNoteInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FRotator Rotation;                                                                // 0x000C (size: 0xC)
    FString Comment;                                                                  // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FNetDriverDefinition
{
    FName DefName;                                                                    // 0x0000 (size: 0x8)
    FName DriverClassName;                                                            // 0x0008 (size: 0x8)
    FName DriverClassNameFallback;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

class UEngine : public UObject
{
    class UFont* TinyFont;                                                            // 0x0030 (size: 0x8)
    FSoftObjectPath TinyFontName;                                                     // 0x0038 (size: 0x18)
    class UFont* SmallFont;                                                           // 0x0050 (size: 0x8)
    FSoftObjectPath SmallFontName;                                                    // 0x0058 (size: 0x18)
    class UFont* MediumFont;                                                          // 0x0070 (size: 0x8)
    FSoftObjectPath MediumFontName;                                                   // 0x0078 (size: 0x18)
    class UFont* LargeFont;                                                           // 0x0090 (size: 0x8)
    FSoftObjectPath LargeFontName;                                                    // 0x0098 (size: 0x18)
    class UFont* SubtitleFont;                                                        // 0x00B0 (size: 0x8)
    FSoftObjectPath SubtitleFontName;                                                 // 0x00B8 (size: 0x18)
    TArray<class UFont*> AdditionalFonts;                                             // 0x00D0 (size: 0x10)
    TArray<FString> AdditionalFontNames;                                              // 0x00E0 (size: 0x10)
    TSubclassOf<class UConsole> ConsoleClass;                                         // 0x00F0 (size: 0x8)
    FSoftClassPath ConsoleClassName;                                                  // 0x00F8 (size: 0x18)
    TSubclassOf<class UGameViewportClient> GameViewportClientClass;                   // 0x0110 (size: 0x8)
    FSoftClassPath GameViewportClientClassName;                                       // 0x0118 (size: 0x18)
    TSubclassOf<class ULocalPlayer> LocalPlayerClass;                                 // 0x0130 (size: 0x8)
    FSoftClassPath LocalPlayerClassName;                                              // 0x0138 (size: 0x18)
    TSubclassOf<class AWorldSettings> WorldSettingsClass;                             // 0x0150 (size: 0x8)
    FSoftClassPath WorldSettingsClassName;                                            // 0x0158 (size: 0x18)
    FSoftClassPath NavigationSystemClassName;                                         // 0x0170 (size: 0x18)
    TSubclassOf<class UNavigationSystemBase> NavigationSystemClass;                   // 0x0188 (size: 0x8)
    FSoftClassPath NavigationSystemConfigClassName;                                   // 0x0190 (size: 0x18)
    TSubclassOf<class UNavigationSystemConfig> NavigationSystemConfigClass;           // 0x01A8 (size: 0x8)
    FSoftClassPath AvoidanceManagerClassName;                                         // 0x01B0 (size: 0x18)
    TSubclassOf<class UAvoidanceManager> AvoidanceManagerClass;                       // 0x01C8 (size: 0x8)
    FSoftClassPath AIControllerClassName;                                             // 0x01D0 (size: 0x18)
    TSubclassOf<class UPhysicsCollisionHandler> PhysicsCollisionHandlerClass;         // 0x01E8 (size: 0x8)
    FSoftClassPath PhysicsCollisionHandlerClassName;                                  // 0x01F0 (size: 0x18)
    FSoftClassPath GameUserSettingsClassName;                                         // 0x0208 (size: 0x18)
    TSubclassOf<class UGameUserSettings> GameUserSettingsClass;                       // 0x0220 (size: 0x8)
    class UGameUserSettings* GameUserSettings;                                        // 0x0228 (size: 0x8)
    TSubclassOf<class ALevelScriptActor> LevelScriptActorClass;                       // 0x0230 (size: 0x8)
    FSoftClassPath LevelScriptActorClassName;                                         // 0x0238 (size: 0x18)
    FSoftClassPath DefaultBlueprintBaseClassName;                                     // 0x0250 (size: 0x18)
    FSoftClassPath GameSingletonClassName;                                            // 0x0268 (size: 0x18)
    class UObject* GameSingleton;                                                     // 0x0280 (size: 0x8)
    FSoftClassPath AssetManagerClassName;                                             // 0x0288 (size: 0x18)
    class UAssetManager* AssetManager;                                                // 0x02A0 (size: 0x8)
    class UTexture2D* DefaultTexture;                                                 // 0x02A8 (size: 0x8)
    FSoftObjectPath DefaultTextureName;                                               // 0x02B0 (size: 0x18)
    class UTexture* DefaultDiffuseTexture;                                            // 0x02C8 (size: 0x8)
    FSoftObjectPath DefaultDiffuseTextureName;                                        // 0x02D0 (size: 0x18)
    class UTexture2D* DefaultBSPVertexTexture;                                        // 0x02E8 (size: 0x8)
    FSoftObjectPath DefaultBSPVertexTextureName;                                      // 0x02F0 (size: 0x18)
    class UTexture2D* HighFrequencyNoiseTexture;                                      // 0x0308 (size: 0x8)
    FSoftObjectPath HighFrequencyNoiseTextureName;                                    // 0x0310 (size: 0x18)
    class UTexture2D* DefaultBokehTexture;                                            // 0x0328 (size: 0x8)
    FSoftObjectPath DefaultBokehTextureName;                                          // 0x0330 (size: 0x18)
    class UTexture2D* DefaultBloomKernelTexture;                                      // 0x0348 (size: 0x8)
    FSoftObjectPath DefaultBloomKernelTextureName;                                    // 0x0350 (size: 0x18)
    class UMaterial* WireframeMaterial;                                               // 0x0368 (size: 0x8)
    FString WireframeMaterialName;                                                    // 0x0370 (size: 0x10)
    class UMaterial* DebugMeshMaterial;                                               // 0x0380 (size: 0x8)
    FSoftObjectPath DebugMeshMaterialName;                                            // 0x0388 (size: 0x18)
    class UMaterial* EmissiveMeshMaterial;                                            // 0x03A0 (size: 0x8)
    FSoftObjectPath EmissiveMeshMaterialName;                                         // 0x03A8 (size: 0x18)
    class UMaterial* LevelColorationLitMaterial;                                      // 0x03C0 (size: 0x8)
    FString LevelColorationLitMaterialName;                                           // 0x03C8 (size: 0x10)
    class UMaterial* LevelColorationUnlitMaterial;                                    // 0x03D8 (size: 0x8)
    FString LevelColorationUnlitMaterialName;                                         // 0x03E0 (size: 0x10)
    class UMaterial* LightingTexelDensityMaterial;                                    // 0x03F0 (size: 0x8)
    FString LightingTexelDensityName;                                                 // 0x03F8 (size: 0x10)
    class UMaterial* ShadedLevelColorationLitMaterial;                                // 0x0408 (size: 0x8)
    FString ShadedLevelColorationLitMaterialName;                                     // 0x0410 (size: 0x10)
    class UMaterial* ShadedLevelColorationUnlitMaterial;                              // 0x0420 (size: 0x8)
    FString ShadedLevelColorationUnlitMaterialName;                                   // 0x0428 (size: 0x10)
    class UMaterial* RemoveSurfaceMaterial;                                           // 0x0438 (size: 0x8)
    FSoftObjectPath RemoveSurfaceMaterialName;                                        // 0x0440 (size: 0x18)
    class UMaterial* VertexColorMaterial;                                             // 0x0458 (size: 0x8)
    FString VertexColorMaterialName;                                                  // 0x0460 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_ColorOnly;                           // 0x0470 (size: 0x8)
    FString VertexColorViewModeMaterialName_ColorOnly;                                // 0x0478 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_AlphaAsColor;                        // 0x0488 (size: 0x8)
    FString VertexColorViewModeMaterialName_AlphaAsColor;                             // 0x0490 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_RedOnly;                             // 0x04A0 (size: 0x8)
    FString VertexColorViewModeMaterialName_RedOnly;                                  // 0x04A8 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_GreenOnly;                           // 0x04B8 (size: 0x8)
    FString VertexColorViewModeMaterialName_GreenOnly;                                // 0x04C0 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_BlueOnly;                            // 0x04D0 (size: 0x8)
    FString VertexColorViewModeMaterialName_BlueOnly;                                 // 0x04D8 (size: 0x10)
    FSoftObjectPath DebugEditorMaterialName;                                          // 0x04E8 (size: 0x18)
    class UMaterial* ConstraintLimitMaterial;                                         // 0x0500 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialX;                         // 0x0508 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialXAxis;                     // 0x0510 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialY;                         // 0x0518 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialYAxis;                     // 0x0520 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialZ;                         // 0x0528 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialZAxis;                     // 0x0530 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialPrismatic;                 // 0x0538 (size: 0x8)
    class UMaterial* InvalidLightmapSettingsMaterial;                                 // 0x0540 (size: 0x8)
    FSoftObjectPath InvalidLightmapSettingsMaterialName;                              // 0x0548 (size: 0x18)
    class UMaterial* PreviewShadowsIndicatorMaterial;                                 // 0x0560 (size: 0x8)
    FSoftObjectPath PreviewShadowsIndicatorMaterialName;                              // 0x0568 (size: 0x18)
    class UMaterial* ArrowMaterial;                                                   // 0x0580 (size: 0x8)
    class UMaterialInstanceDynamic* ArrowMaterialYellow;                              // 0x0588 (size: 0x8)
    FSoftObjectPath ArrowMaterialName;                                                // 0x0590 (size: 0x18)
    FLinearColor LightingOnlyBrightness;                                              // 0x05A8 (size: 0x10)
    TArray<FLinearColor> ShaderComplexityColors;                                      // 0x05B8 (size: 0x10)
    TArray<FLinearColor> QuadComplexityColors;                                        // 0x05C8 (size: 0x10)
    TArray<FLinearColor> LightComplexityColors;                                       // 0x05D8 (size: 0x10)
    TArray<FLinearColor> StationaryLightOverlapColors;                                // 0x05E8 (size: 0x10)
    TArray<FLinearColor> LODColorationColors;                                         // 0x05F8 (size: 0x10)
    TArray<FLinearColor> HLODColorationColors;                                        // 0x0608 (size: 0x10)
    TArray<FLinearColor> StreamingAccuracyColors;                                     // 0x0618 (size: 0x10)
    float MaxPixelShaderAdditiveComplexityCount;                                      // 0x0628 (size: 0x4)
    float MaxES3PixelShaderAdditiveComplexityCount;                                   // 0x062C (size: 0x4)
    float MinLightMapDensity;                                                         // 0x0630 (size: 0x4)
    float IdealLightMapDensity;                                                       // 0x0634 (size: 0x4)
    float MaxLightMapDensity;                                                         // 0x0638 (size: 0x4)
    uint8 bRenderLightMapDensityGrayscale;                                            // 0x063C (size: 0x1)
    float RenderLightMapDensityGrayscaleScale;                                        // 0x0640 (size: 0x4)
    float RenderLightMapDensityColorScale;                                            // 0x0644 (size: 0x4)
    FLinearColor LightMapDensityVertexMappedColor;                                    // 0x0648 (size: 0x10)
    FLinearColor LightMapDensitySelectedColor;                                        // 0x0658 (size: 0x10)
    TArray<FStatColorMapping> StatColorMappings;                                      // 0x0668 (size: 0x10)
    class UPhysicalMaterial* DefaultPhysMaterial;                                     // 0x0678 (size: 0x8)
    FSoftObjectPath DefaultPhysMaterialName;                                          // 0x0680 (size: 0x18)
    TArray<FGameNameRedirect> ActiveGameNameRedirects;                                // 0x0698 (size: 0x10)
    TArray<FClassRedirect> ActiveClassRedirects;                                      // 0x06A8 (size: 0x10)
    TArray<FPluginRedirect> ActivePluginRedirects;                                    // 0x06B8 (size: 0x10)
    TArray<FStructRedirect> ActiveStructRedirects;                                    // 0x06C8 (size: 0x10)
    class UTexture2D* PreIntegratedSkinBRDFTexture;                                   // 0x06D8 (size: 0x8)
    FSoftObjectPath PreIntegratedSkinBRDFTextureName;                                 // 0x06E0 (size: 0x18)
    class UTexture2D* BlueNoiseTexture;                                               // 0x06F8 (size: 0x8)
    FSoftObjectPath BlueNoiseTextureName;                                             // 0x0700 (size: 0x18)
    class UTexture2D* MiniFontTexture;                                                // 0x0718 (size: 0x8)
    FSoftObjectPath MiniFontTextureName;                                              // 0x0720 (size: 0x18)
    class UTexture* WeightMapPlaceholderTexture;                                      // 0x0738 (size: 0x8)
    FSoftObjectPath WeightMapPlaceholderTextureName;                                  // 0x0740 (size: 0x18)
    class UTexture2D* LightMapDensityTexture;                                         // 0x0758 (size: 0x8)
    FSoftObjectPath LightMapDensityTextureName;                                       // 0x0760 (size: 0x18)
    class UGameViewportClient* GameViewport;                                          // 0x0780 (size: 0x8)
    TArray<FString> DeferredCommands;                                                 // 0x0788 (size: 0x10)
    float NearClipPlane;                                                              // 0x0798 (size: 0x4)
    uint8 bSubtitlesEnabled;                                                          // 0x079C (size: 0x1)
    uint8 bSubtitlesForcedOff;                                                        // 0x079C (size: 0x1)
    int32 MaximumLoopIterationCount;                                                  // 0x07A0 (size: 0x4)
    uint8 bCanBlueprintsTickByDefault;                                                // 0x07A4 (size: 0x1)
    uint8 bOptimizeAnimBlueprintMemberVariableAccess;                                 // 0x07A4 (size: 0x1)
    uint8 bAllowMultiThreadedAnimationUpdate;                                         // 0x07A4 (size: 0x1)
    uint8 bEnableEditorPSysRealtimeLOD;                                               // 0x07A4 (size: 0x1)
    uint8 bSmoothFrameRate;                                                           // 0x07A4 (size: 0x1)
    uint8 bUseFixedFrameRate;                                                         // 0x07A4 (size: 0x1)
    float FixedFrameRate;                                                             // 0x07A8 (size: 0x4)
    FFloatRange SmoothedFrameRateRange;                                               // 0x07AC (size: 0x10)
    class UEngineCustomTimeStep* CustomTimeStep;                                      // 0x07C0 (size: 0x8)
    FSoftClassPath CustomTimeStepClassName;                                           // 0x07E8 (size: 0x18)
    class UTimecodeProvider* TimecodeProvider;                                        // 0x0800 (size: 0x8)
    FSoftClassPath TimecodeProviderClassName;                                         // 0x0828 (size: 0x18)
    bool bGenerateDefaultTimecode;                                                    // 0x0840 (size: 0x1)
    FFrameRate GenerateDefaultTimecodeFrameRate;                                      // 0x0844 (size: 0x8)
    float GenerateDefaultTimecodeFrameDelay;                                          // 0x084C (size: 0x4)
    uint8 bCheckForMultiplePawnsSpawnedInAFrame;                                      // 0x0850 (size: 0x1)
    int32 NumPawnsAllowedToBeSpawnedInAFrame;                                         // 0x0854 (size: 0x4)
    uint8 bShouldGenerateLowQualityLightmaps;                                         // 0x0858 (size: 0x1)
    FColor C_WorldBox;                                                                // 0x085C (size: 0x4)
    FColor C_BrushWire;                                                               // 0x0860 (size: 0x4)
    FColor C_AddWire;                                                                 // 0x0864 (size: 0x4)
    FColor C_SubtractWire;                                                            // 0x0868 (size: 0x4)
    FColor C_SemiSolidWire;                                                           // 0x086C (size: 0x4)
    FColor C_NonSolidWire;                                                            // 0x0870 (size: 0x4)
    FColor C_WireBackground;                                                          // 0x0874 (size: 0x4)
    FColor C_ScaleBoxHi;                                                              // 0x0878 (size: 0x4)
    FColor C_VolumeCollision;                                                         // 0x087C (size: 0x4)
    FColor C_BSPCollision;                                                            // 0x0880 (size: 0x4)
    FColor C_OrthoBackground;                                                         // 0x0884 (size: 0x4)
    FColor C_Volume;                                                                  // 0x0888 (size: 0x4)
    FColor C_BrushShape;                                                              // 0x088C (size: 0x4)
    float StreamingDistanceFactor;                                                    // 0x0890 (size: 0x4)
    FDirectoryPath GameScreenshotSaveDirectory;                                       // 0x0898 (size: 0x10)
    ETransitionType TransitionType;                                                   // 0x08A8 (size: 0x1)
    FString TransitionDescription;                                                    // 0x08B0 (size: 0x10)
    FString TransitionGameMode;                                                       // 0x08C0 (size: 0x10)
    uint8 bAllowMatureLanguage;                                                       // 0x08D0 (size: 0x1)
    float CameraRotationThreshold;                                                    // 0x08D4 (size: 0x4)
    float CameraTranslationThreshold;                                                 // 0x08D8 (size: 0x4)
    float PrimitiveProbablyVisibleTime;                                               // 0x08DC (size: 0x4)
    float MaxOcclusionPixelsFraction;                                                 // 0x08E0 (size: 0x4)
    uint8 bPauseOnLossOfFocus;                                                        // 0x08E4 (size: 0x1)
    int32 MaxParticleResize;                                                          // 0x08E8 (size: 0x4)
    int32 MaxParticleResizeWarn;                                                      // 0x08EC (size: 0x4)
    TArray<FDropNoteInfo> PendingDroppedNotes;                                        // 0x08F0 (size: 0x10)
    float NetClientTicksPerSecond;                                                    // 0x0900 (size: 0x4)
    float DisplayGamma;                                                               // 0x0904 (size: 0x4)
    float MinDesiredFrameRate;                                                        // 0x0908 (size: 0x4)
    FLinearColor DefaultSelectedMaterialColor;                                        // 0x090C (size: 0x10)
    FLinearColor SelectedMaterialColor;                                               // 0x091C (size: 0x10)
    FLinearColor SelectionOutlineColor;                                               // 0x092C (size: 0x10)
    FLinearColor SubduedSelectionOutlineColor;                                        // 0x093C (size: 0x10)
    FLinearColor SelectedMaterialColorOverride;                                       // 0x094C (size: 0x10)
    bool bIsOverridingSelectedColor;                                                  // 0x095C (size: 0x1)
    uint8 bEnableOnScreenDebugMessages;                                               // 0x0960 (size: 0x1)
    uint8 bEnableOnScreenDebugMessagesDisplay;                                        // 0x0960 (size: 0x1)
    uint8 bSuppressMapWarnings;                                                       // 0x0960 (size: 0x1)
    uint8 bDisableAILogging;                                                          // 0x0960 (size: 0x1)
    uint32 bEnableVisualLogRecordingOnStart;                                          // 0x0964 (size: 0x4)
    int32 ScreenSaverInhibitorSemaphore;                                              // 0x0968 (size: 0x4)
    uint8 bLockReadOnlyLevels;                                                        // 0x096C (size: 0x1)
    FString ParticleEventManagerClassPath;                                            // 0x0970 (size: 0x10)
    float SelectionHighlightIntensity;                                                // 0x0980 (size: 0x4)
    float BSPSelectionHighlightIntensity;                                             // 0x0984 (size: 0x4)
    float SelectionHighlightIntensityBillboards;                                      // 0x0988 (size: 0x4)
    TArray<FNetDriverDefinition> NetDriverDefinitions;                                // 0x0BF8 (size: 0x10)
    TArray<FString> ServerActors;                                                     // 0x0C08 (size: 0x10)
    TArray<FString> RuntimeServerActors;                                              // 0x0C18 (size: 0x10)
    float NetErrorLogInterval;                                                        // 0x0C28 (size: 0x4)
    uint8 bStartedLoadMapMovie;                                                       // 0x0C2C (size: 0x1)
    int32 NextWorldContextHandle;                                                     // 0x0C48 (size: 0x4)

}; // Size: 0xD20

class UGameEngine : public UEngine
{
    float MaxDeltaTime;                                                               // 0x0D20 (size: 0x4)
    float ServerFlushLogInterval;                                                     // 0x0D24 (size: 0x4)
    class UGameInstance* GameInstance;                                                // 0x0D28 (size: 0x8)

}; // Size: 0xD70

struct FShouldEndState
{
}; // Size: 0x1

class UGameUserSettings : public UObject
{
    bool bUseVSync;                                                                   // 0x0028 (size: 0x1)
    bool bUseDynamicResolution;                                                       // 0x0029 (size: 0x1)
    uint32 ResolutionSizeX;                                                           // 0x0080 (size: 0x4)
    uint32 ResolutionSizeY;                                                           // 0x0084 (size: 0x4)
    uint32 LastUserConfirmedResolutionSizeX;                                          // 0x0088 (size: 0x4)
    uint32 LastUserConfirmedResolutionSizeY;                                          // 0x008C (size: 0x4)
    int32 WindowPosX;                                                                 // 0x0090 (size: 0x4)
    int32 WindowPosY;                                                                 // 0x0094 (size: 0x4)
    int32 FullscreenMode;                                                             // 0x0098 (size: 0x4)
    int32 LastConfirmedFullscreenMode;                                                // 0x009C (size: 0x4)
    int32 PreferredFullscreenMode;                                                    // 0x00A0 (size: 0x4)
    uint32 Version;                                                                   // 0x00A4 (size: 0x4)
    int32 AudioQualityLevel;                                                          // 0x00A8 (size: 0x4)
    int32 LastConfirmedAudioQualityLevel;                                             // 0x00AC (size: 0x4)
    float FrameRateLimit;                                                             // 0x00B0 (size: 0x4)
    int32 DesiredScreenWidth;                                                         // 0x00B8 (size: 0x4)
    bool bUseDesiredScreenHeight;                                                     // 0x00BC (size: 0x1)
    int32 DesiredScreenHeight;                                                        // 0x00C0 (size: 0x4)
    int32 LastUserConfirmedDesiredScreenWidth;                                        // 0x00C4 (size: 0x4)
    int32 LastUserConfirmedDesiredScreenHeight;                                       // 0x00C8 (size: 0x4)
    float LastRecommendedScreenWidth;                                                 // 0x00CC (size: 0x4)
    float LastRecommendedScreenHeight;                                                // 0x00D0 (size: 0x4)
    float LastCPUBenchmarkResult;                                                     // 0x00D4 (size: 0x4)
    float LastGPUBenchmarkResult;                                                     // 0x00D8 (size: 0x4)
    TArray<float> LastCPUBenchmarkSteps;                                              // 0x00E0 (size: 0x10)
    TArray<float> LastGPUBenchmarkSteps;                                              // 0x00F0 (size: 0x10)
    float LastGPUBenchmarkMultiplier;                                                 // 0x0100 (size: 0x4)
    bool bUseHDRDisplayOutput;                                                        // 0x0104 (size: 0x1)
    int32 HDRDisplayOutputNits;                                                       // 0x0108 (size: 0x4)
    FGameUserSettingsOnGameUserSettingsUINeedsUpdate OnGameUserSettingsUINeedsUpdate; // 0x0110 (size: 0x10)
    void OnGameUserSettingsUINeedsUpdate();

    void ValidateSettings();
    bool SupportsHDRDisplayOutput();
    void SetVSyncEnabled(bool bEnable);
    void SetVisualEffectQuality(int32 Value);
    void SetViewDistanceQuality(int32 Value);
    void SetToDefaults();
    void SetTextureQuality(int32 Value);
    void SetShadowQuality(int32 Value);
    void SetShadingQuality(int32 Value);
    void SetScreenResolution(FIntPoint Resolution);
    void SetResolutionScaleValueEx(float NewScaleValue);
    void SetResolutionScaleValue(int32 NewScaleValue);
    void SetResolutionScaleNormalized(float NewScaleNormalized);
    void SetPostProcessingQuality(int32 Value);
    void SetOverallScalabilityLevel(int32 Value);
    void SetFullscreenMode(TEnumAsByte<EWindowMode::Type> InFullscreenMode);
    void SetFrameRateLimit(float NewLimit);
    void SetFoliageQuality(int32 Value);
    void SetDynamicResolutionEnabled(bool bEnable);
    void SetBenchmarkFallbackValues();
    void SetAudioQualityLevel(int32 QualityLevel);
    void SetAntiAliasingQuality(int32 Value);
    void SaveSettings();
    void RunHardwareBenchmark(int32 WorkScale, float CPUMultiplier, float GPUMultiplier);
    void RevertVideoMode();
    void ResetToCurrentSettings();
    void LoadSettings(bool bForceReload);
    bool IsVSyncEnabled();
    bool IsVSyncDirty();
    bool IsScreenResolutionDirty();
    bool IsHDREnabled();
    bool IsFullscreenModeDirty();
    bool IsDynamicResolutionEnabled();
    bool IsDynamicResolutionDirty();
    bool IsDirty();
    int32 GetVisualEffectQuality();
    int32 GetViewDistanceQuality();
    int32 GetTextureQuality();
    int32 GetSyncInterval();
    int32 GetShadowQuality();
    int32 GetShadingQuality();
    FIntPoint GetScreenResolution();
    float GetResolutionScaleNormalized();
    void GetResolutionScaleInformationEx(float& CurrentScaleNormalized, float& CurrentScaleValue, float& MinScaleValue, float& MaxScaleValue);
    void GetResolutionScaleInformation(float& CurrentScaleNormalized, int32& CurrentScaleValue, int32& MinScaleValue, int32& MaxScaleValue);
    float GetRecommendedResolutionScale();
    TEnumAsByte<EWindowMode::Type> GetPreferredFullscreenMode();
    int32 GetPostProcessingQuality();
    int32 GetOverallScalabilityLevel();
    FIntPoint GetLastConfirmedScreenResolution();
    TEnumAsByte<EWindowMode::Type> GetLastConfirmedFullscreenMode();
    class UGameUserSettings* GetGameUserSettings();
    TEnumAsByte<EWindowMode::Type> GetFullscreenMode();
    float GetFrameRateLimit();
    int32 GetFramePace();
    int32 GetFoliageQuality();
    FIntPoint GetDesktopResolution();
    FIntPoint GetDefaultWindowPosition();
    TEnumAsByte<EWindowMode::Type> GetDefaultWindowMode();
    float GetDefaultResolutionScale();
    FIntPoint GetDefaultResolution();
    int32 GetCurrentHDRDisplayNits();
    int32 GetAudioQualityLevel();
    int32 GetAntiAliasingQuality();
    void EnableHDRDisplayOutput(bool bEnable, int32 DisplayNits);
    void ConfirmVideoMode();
    void ApplySettings(bool bCheckForCommandLineOverrides);
    void ApplyResolutionSettings(bool bCheckForCommandLineOverrides);
    void ApplyNonResolutionSettings();
    void ApplyHardwareBenchmarkResults();
}; // Size: 0x120

struct FInputActionKeyMapping
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    uint8 bShift;                                                                     // 0x0008 (size: 0x1)
    uint8 bCtrl;                                                                      // 0x0008 (size: 0x1)
    uint8 bAlt;                                                                       // 0x0008 (size: 0x1)
    uint8 bCmd;                                                                       // 0x0008 (size: 0x1)
    FKey Key;                                                                         // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FCameraCacheEntry
{
    float Timestamp;                                                                  // 0x0000 (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x5F0)

}; // Size: 0x600

struct FTViewTarget
{
    class AActor* Target;                                                             // 0x0000 (size: 0x8)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x5F0)
    class APlayerState* PlayerState;                                                  // 0x0600 (size: 0x8)

}; // Size: 0x610

class APlayerCameraManager : public AActor
{
    class APlayerController* PCOwner;                                                 // 0x0228 (size: 0x8)
    class USceneComponent* TransformComponent;                                        // 0x0230 (size: 0x8)
    float DefaultFOV;                                                                 // 0x0240 (size: 0x4)
    float DefaultOrthoWidth;                                                          // 0x0248 (size: 0x4)
    float DefaultAspectRatio;                                                         // 0x0250 (size: 0x4)
    FCameraCacheEntry CameraCache;                                                    // 0x02A0 (size: 0x600)
    FCameraCacheEntry LastFrameCameraCache;                                           // 0x08A0 (size: 0x600)
    FTViewTarget ViewTarget;                                                          // 0x0EA0 (size: 0x610)
    FTViewTarget PendingViewTarget;                                                   // 0x14B0 (size: 0x610)
    FCameraCacheEntry CameraCachePrivate;                                             // 0x1AF0 (size: 0x600)
    FCameraCacheEntry LastFrameCameraCachePrivate;                                    // 0x20F0 (size: 0x600)
    TArray<class UCameraModifier*> ModifierList;                                      // 0x26F0 (size: 0x10)
    TArray<class TSubclassOf<UCameraModifier>> DefaultModifiers;                      // 0x2700 (size: 0x10)
    float FreeCamDistance;                                                            // 0x2710 (size: 0x4)
    FVector FreeCamOffset;                                                            // 0x2714 (size: 0xC)
    FVector ViewTargetOffset;                                                         // 0x2720 (size: 0xC)
    FPlayerCameraManagerOnAudioFadeChangeEvent OnAudioFadeChangeEvent;                // 0x2730 (size: 0x10)
    void OnAudioFadeChangeSignature(bool bFadeOut, float FadeTime);
    TArray<class AEmitterCameraLensEffectBase*> CameraLensEffects;                    // 0x2750 (size: 0x10)
    class UCameraModifier_CameraShake* CachedCameraShakeMod;                          // 0x2760 (size: 0x8)
    class UCameraAnimInst* AnimInstPool;                                              // 0x2768 (size: 0x40)
    TArray<FPostProcessSettings> PostProcessBlendCache;                               // 0x27A8 (size: 0x10)
    TArray<class UCameraAnimInst*> ActiveAnims;                                       // 0x27C8 (size: 0x10)
    TArray<class UCameraAnimInst*> FreeAnims;                                         // 0x27D8 (size: 0x10)
    class ACameraActor* AnimCameraActor;                                              // 0x27E8 (size: 0x8)
    uint8 bIsOrthographic;                                                            // 0x27F0 (size: 0x1)
    uint8 bDefaultConstrainAspectRatio;                                               // 0x27F0 (size: 0x1)
    uint8 bClientSimulatingViewTarget;                                                // 0x27F0 (size: 0x1)
    uint8 bUseClientSideCameraUpdates;                                                // 0x27F0 (size: 0x1)
    uint8 bGameCameraCutThisFrame;                                                    // 0x27F1 (size: 0x1)
    float ViewPitchMin;                                                               // 0x27F4 (size: 0x4)
    float ViewPitchMax;                                                               // 0x27F8 (size: 0x4)
    float ViewYawMin;                                                                 // 0x27FC (size: 0x4)
    float ViewYawMax;                                                                 // 0x2800 (size: 0x4)
    float ViewRollMin;                                                                // 0x2804 (size: 0x4)
    float ViewRollMax;                                                                // 0x2808 (size: 0x4)
    float ServerUpdateCameraTimeout;                                                  // 0x2810 (size: 0x4)

    void SwapPendingViewTargetWhenUsingClientSideCameraUpdates();
    void StopCameraShake(class UCameraShakeBase* ShakeInstance, bool bImmediately);
    void StopCameraFade();
    void StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate);
    void StopAllInstancesOfCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopAllInstancesOfCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately);
    void StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate);
    void StopAllCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopAllCameraShakes(bool bImmediately);
    void StopAllCameraAnims(bool bImmediate);
    class UCameraShakeBase* StartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> ShakeClass, class UCameraShakeSourceComponent* SourceComponent, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    class UCameraShakeBase* StartCameraShake(TSubclassOf<class UCameraShakeBase> ShakeClass, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void StartCameraFade(float FromAlpha, float ToAlpha, float Duration, FLinearColor Color, bool bShouldFadeAudio, bool bHoldWhenFinished);
    void SetManualCameraFade(float InFadeAmount, FLinearColor Color, bool bInFadeAudio);
    void SetGameCameraCutThisFrame();
    bool RemoveCameraModifier(class UCameraModifier* ModifierToRemove);
    void RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter);
    class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float blendInTime, float blendOutTime, bool bLoop, bool bRandomStartTime, float Duration, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void PhotographyCameraModify(const FVector NewCameraLocation, const FVector PreviousCameraLocation, const FVector OriginalCameraLocation, FVector& ResultCameraLocation);
    void OnPhotographySessionStart();
    void OnPhotographySessionEnd();
    void OnPhotographyMultiPartCaptureStart();
    void OnPhotographyMultiPartCaptureEnd();
    class APlayerController* GetOwningPlayerController();
    float GetFOVAngle();
    FRotator GetCameraRotation();
    FVector GetCameraLocation();
    class UCameraModifier* FindCameraModifierByClass(TSubclassOf<class UCameraModifier> ModifierClass);
    void ClearCameraLensEffects();
    bool BlueprintUpdateCamera(class AActor* CameraTarget, FVector& NewCameraLocation, FRotator& NewCameraRotation, float& NewCameraFOV);
    class UCameraModifier* AddNewCameraModifier(TSubclassOf<class UCameraModifier> ModifierClass);
    class AEmitterCameraLensEffectBase* AddCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
}; // Size: 0x2820

struct FKeyBind
{
    FKey Key;                                                                         // 0x0000 (size: 0x18)
    FString Command;                                                                  // 0x0018 (size: 0x10)
    uint8 Control;                                                                    // 0x0028 (size: 0x1)
    uint8 Shift;                                                                      // 0x0028 (size: 0x1)
    uint8 Alt;                                                                        // 0x0028 (size: 0x1)
    uint8 Cmd;                                                                        // 0x0028 (size: 0x1)
    uint8 bIgnoreCtrl;                                                                // 0x0028 (size: 0x1)
    uint8 bIgnoreShift;                                                               // 0x0028 (size: 0x1)
    uint8 bIgnoreAlt;                                                                 // 0x0028 (size: 0x1)
    uint8 bIgnoreCmd;                                                                 // 0x0028 (size: 0x1)
    uint8 bDisabled;                                                                  // 0x0029 (size: 0x1)

}; // Size: 0x30

class UPlayerInput : public UObject
{
    TArray<FKeyBind> DebugExecBindings;                                               // 0x0120 (size: 0x10)
    TArray<FName> InvertedAxis;                                                       // 0x0160 (size: 0x10)

    void SetMouseSensitivity(const float Sensitivity);
    void SetBind(FName BindName, FString Command);
    void InvertAxisKey(const FKey AxisKey);
    void InvertAxis(const FName AxisName);
    void ClearSmoothing();
}; // Size: 0x3A8

class ANavigationObjectBase : public AActor
{
    class UCapsuleComponent* CapsuleComponent;                                        // 0x0230 (size: 0x8)
    class UBillboardComponent* GoodSprite;                                            // 0x0238 (size: 0x8)
    class UBillboardComponent* BadSprite;                                             // 0x0240 (size: 0x8)
    uint8 bIsPIEPlayerStart;                                                          // 0x0248 (size: 0x1)

}; // Size: 0x250

class APlayerStart : public ANavigationObjectBase
{
    FName PlayerStartTag;                                                             // 0x0250 (size: 0x8)

}; // Size: 0x258

class ADefaultPawn : public APawn
{
    float BaseTurnRate;                                                               // 0x0288 (size: 0x4)
    float BaseLookUpRate;                                                             // 0x028C (size: 0x4)
    class UPawnMovementComponent* MovementComponent;                                  // 0x0290 (size: 0x8)
    class USphereComponent* CollisionComponent;                                       // 0x0298 (size: 0x8)
    class UStaticMeshComponent* MeshComponent;                                        // 0x02A0 (size: 0x8)
    uint8 bAddDefaultMovementBindings;                                                // 0x02A8 (size: 0x1)

    void TurnAtRate(float Rate);
    void MoveUp_World(float Val);
    void MoveRight(float Val);
    void MoveForward(float Val);
    void LookUpAtRate(float Rate);
}; // Size: 0x2B0

class ASpectatorPawn : public ADefaultPawn
{
}; // Size: 0x2B0

struct FReverbSettings
{
    bool bApplyReverb;                                                                // 0x0000 (size: 0x1)
    class UReverbEffect* ReverbEffect;                                                // 0x0008 (size: 0x8)
    class USoundEffectSubmixPreset* ReverbPluginEffect;                               // 0x0010 (size: 0x8)
    float Volume;                                                                     // 0x0018 (size: 0x4)
    float FadeTime;                                                                   // 0x001C (size: 0x4)

}; // Size: 0x20

struct FInteriorSettings
{
    bool bIsWorldSettings;                                                            // 0x0000 (size: 0x1)
    float ExteriorVolume;                                                             // 0x0004 (size: 0x4)
    float ExteriorTime;                                                               // 0x0008 (size: 0x4)
    float ExteriorLPF;                                                                // 0x000C (size: 0x4)
    float ExteriorLPFTime;                                                            // 0x0010 (size: 0x4)
    float InteriorVolume;                                                             // 0x0014 (size: 0x4)
    float InteriorTime;                                                               // 0x0018 (size: 0x4)
    float InteriorLPF;                                                                // 0x001C (size: 0x4)
    float InteriorLPFTime;                                                            // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FBroadphaseSettings
{
    bool bUseMBPOnClient;                                                             // 0x0000 (size: 0x1)
    bool bUseMBPOnServer;                                                             // 0x0001 (size: 0x1)
    bool bUseMBPOuterBounds;                                                          // 0x0002 (size: 0x1)
    FBox MBPBounds;                                                                   // 0x0004 (size: 0x1C)
    FBox MBPOuterBounds;                                                              // 0x0020 (size: 0x1C)
    uint32 MBPNumSubdivs;                                                             // 0x003C (size: 0x4)

}; // Size: 0x40

struct FNetViewer
{
    class UNetConnection* Connection;                                                 // 0x0000 (size: 0x8)
    class AActor* InViewer;                                                           // 0x0008 (size: 0x8)
    class AActor* ViewTarget;                                                         // 0x0010 (size: 0x8)
    FVector ViewLocation;                                                             // 0x0018 (size: 0xC)
    FVector ViewDir;                                                                  // 0x0024 (size: 0xC)

}; // Size: 0x30

class AWorldSettings : public AInfo
{
    int32 VisibilityCellSize;                                                         // 0x0230 (size: 0x4)
    TEnumAsByte<EVisibilityAggressiveness> VisibilityAggressiveness;                  // 0x0234 (size: 0x1)
    uint8 bPrecomputeVisibility;                                                      // 0x0235 (size: 0x1)
    uint8 bPlaceCellsOnlyAlongCameraTracks;                                           // 0x0235 (size: 0x1)
    uint8 bEnableWorldBoundsChecks;                                                   // 0x0235 (size: 0x1)
    uint8 bEnableNavigationSystem;                                                    // 0x0235 (size: 0x1)
    uint8 bEnableAISystem;                                                            // 0x0235 (size: 0x1)
    uint8 bEnableWorldComposition;                                                    // 0x0235 (size: 0x1)
    uint8 bUseClientSideLevelStreamingVolumes;                                        // 0x0235 (size: 0x1)
    uint8 bEnableWorldOriginRebasing;                                                 // 0x0235 (size: 0x1)
    uint8 bWorldGravitySet;                                                           // 0x0236 (size: 0x1)
    uint8 bGlobalGravitySet;                                                          // 0x0236 (size: 0x1)
    uint8 bMinimizeBSPSections;                                                       // 0x0236 (size: 0x1)
    uint8 bForceNoPrecomputedLighting;                                                // 0x0236 (size: 0x1)
    uint8 bHighPriorityLoading;                                                       // 0x0236 (size: 0x1)
    uint8 bHighPriorityLoadingLocal;                                                  // 0x0236 (size: 0x1)
    uint8 bOverrideDefaultBroadphaseSettings;                                         // 0x0236 (size: 0x1)
    class UNavigationSystemConfig* NavigationSystemConfig;                            // 0x0238 (size: 0x8)
    class UNavigationSystemConfig* NavigationSystemConfigOverride;                    // 0x0240 (size: 0x8)
    float WorldToMeters;                                                              // 0x0248 (size: 0x4)
    float KillZ;                                                                      // 0x024C (size: 0x4)
    TSubclassOf<class UDamageType> KillZDamageType;                                   // 0x0250 (size: 0x8)
    float WorldGravityZ;                                                              // 0x0258 (size: 0x4)
    float GlobalGravityZ;                                                             // 0x025C (size: 0x4)
    TSubclassOf<class ADefaultPhysicsVolume> DefaultPhysicsVolumeClass;               // 0x0260 (size: 0x8)
    TSubclassOf<class UPhysicsCollisionHandler> PhysicsCollisionHandlerClass;         // 0x0268 (size: 0x8)
    TSubclassOf<class AGameModeBase> DefaultGameMode;                                 // 0x0270 (size: 0x8)
    TSubclassOf<class AGameNetworkManager> GameNetworkManagerClass;                   // 0x0278 (size: 0x8)
    int32 PackedLightAndShadowMapTextureSize;                                         // 0x0280 (size: 0x4)
    FVector DefaultColorScale;                                                        // 0x0284 (size: 0xC)
    float DefaultMaxDistanceFieldOcclusionDistance;                                   // 0x0290 (size: 0x4)
    float GlobalDistanceFieldViewDistance;                                            // 0x0294 (size: 0x4)
    float DynamicIndirectShadowsSelfShadowingIntensity;                               // 0x0298 (size: 0x4)
    FReverbSettings DefaultReverbSettings;                                            // 0x02A0 (size: 0x20)
    FInteriorSettings DefaultAmbientZoneSettings;                                     // 0x02C0 (size: 0x24)
    class USoundMix* DefaultBaseSoundMix;                                             // 0x02E8 (size: 0x8)
    float TimeDilation;                                                               // 0x02F0 (size: 0x4)
    float MatineeTimeDilation;                                                        // 0x02F4 (size: 0x4)
    float DemoPlayTimeDilation;                                                       // 0x02F8 (size: 0x4)
    float MinGlobalTimeDilation;                                                      // 0x02FC (size: 0x4)
    float MaxGlobalTimeDilation;                                                      // 0x0300 (size: 0x4)
    float MinUndilatedFrameTime;                                                      // 0x0304 (size: 0x4)
    float MaxUndilatedFrameTime;                                                      // 0x0308 (size: 0x4)
    FBroadphaseSettings BroadphaseSettings;                                           // 0x030C (size: 0x40)
    class APlayerState* Pauser;                                                       // 0x0350 (size: 0x8)
    TArray<FNetViewer> ReplicationViewers;                                            // 0x0358 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0368 (size: 0x10)
    class APlayerState* PauserPlayerState;                                            // 0x0378 (size: 0x8)
    int32 MaxNumberOfBookmarks;                                                       // 0x0380 (size: 0x4)
    TSubclassOf<class UBookmarkBase> DefaultBookmarkClass;                            // 0x0388 (size: 0x8)
    TArray<class UBookmarkBase*> BookmarkArray;                                       // 0x0390 (size: 0x10)
    TSubclassOf<class UBookmarkBase> LastBookmarkClass;                               // 0x03A0 (size: 0x8)

    void OnRep_WorldGravityZ();
}; // Size: 0x3A8

class ASkyLight : public AInfo
{
    class USkyLightComponent* LightComponent;                                         // 0x0228 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0230 (size: 0x1)

    void OnRep_bEnabled();
}; // Size: 0x238

class UTextureCube : public UTexture
{
}; // Size: 0x1D0

struct FInstancedStaticMeshInstanceData
{
    FMatrix Transform;                                                                // 0x0000 (size: 0x40)

}; // Size: 0x40

struct FInstancedStaticMeshMappingInfo
{
}; // Size: 0x8

class UInstancedStaticMeshComponent : public UStaticMeshComponent
{
    TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;                       // 0x04E0 (size: 0x10)
    int32 NumCustomDataFloats;                                                        // 0x04F0 (size: 0x4)
    TArray<float> PerInstanceSMCustomData;                                            // 0x04F8 (size: 0x10)
    int32 InstancingRandomSeed;                                                       // 0x0508 (size: 0x4)
    int32 InstanceStartCullDistance;                                                  // 0x050C (size: 0x4)
    int32 InstanceEndCullDistance;                                                    // 0x0510 (size: 0x4)
    TArray<int32> InstanceReorderTable;                                               // 0x0518 (size: 0x10)
    int32 NumPendingLightmaps;                                                        // 0x0570 (size: 0x4)
    TArray<FInstancedStaticMeshMappingInfo> CachedMappings;                           // 0x0578 (size: 0x10)

    bool UpdateInstanceTransform(int32 InstanceIndex, const FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    bool SetCustomDataValue(int32 InstanceIndex, int32 CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty);
    void SetCullDistances(int32 StartCullDistance, int32 EndCullDistance);
    bool RemoveInstance(int32 InstanceIndex);
    bool GetInstanceTransform(int32 InstanceIndex, FTransform& OutInstanceTransform, bool bWorldSpace);
    TArray<int32> GetInstancesOverlappingSphere(const FVector& Center, float Radius, bool bSphereInWorldSpace);
    TArray<int32> GetInstancesOverlappingBox(const FBox& Box, bool bBoxInWorldSpace);
    int32 GetInstanceCount();
    void ClearInstances();
    bool BatchUpdateInstancesTransforms(int32 StartInstanceIndex, const TArray<FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    bool BatchUpdateInstancesTransform(int32 StartInstanceIndex, int32 NumInstances, const FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    int32 AddInstanceWorldSpace(const FTransform& WorldTransform);
    TArray<int32> AddInstances(const TArray<FTransform>& InstanceTransforms, bool bShouldReturnIndices);
    int32 AddInstance(const FTransform& InstanceTransform);
}; // Size: 0x590

class UHierarchicalInstancedStaticMeshComponent : public UInstancedStaticMeshComponent
{
    TArray<int32> SortedInstances;                                                    // 0x0598 (size: 0x10)
    int32 NumBuiltInstances;                                                          // 0x05A8 (size: 0x4)
    FBox BuiltInstanceBounds;                                                         // 0x05B0 (size: 0x1C)
    FBox UnbuiltInstanceBounds;                                                       // 0x05CC (size: 0x1C)
    TArray<FBox> UnbuiltInstanceBoundsList;                                           // 0x05E8 (size: 0x10)
    uint8 bEnableDensityScaling;                                                      // 0x05F8 (size: 0x1)
    int32 OcclusionLayerNumNodes;                                                     // 0x0600 (size: 0x4)
    FBoxSphereBounds CacheMeshExtendedBounds;                                         // 0x0604 (size: 0x1C)
    bool bDisableCollision;                                                           // 0x0620 (size: 0x1)
    int32 InstanceCountToRender;                                                      // 0x0624 (size: 0x4)

    bool RemoveInstances(const TArray<int32>& InstancesToRemove);
}; // Size: 0x680

class AStaticMeshActor : public AActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0228 (size: 0x8)
    bool bStaticMeshReplicateMovement;                                                // 0x0230 (size: 0x1)
    ENavDataGatheringMode NavigationGeometryGatheringMode;                            // 0x0231 (size: 0x1)

    void SetMobility(TEnumAsByte<EComponentMobility::Type> InMobility);
}; // Size: 0x238

struct FGeomSelection
{
    int32 Type;                                                                       // 0x0000 (size: 0x4)
    int32 Index;                                                                      // 0x0004 (size: 0x4)
    int32 SelectionIndex;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

class ABrush : public AActor
{
    TEnumAsByte<EBrushType> BrushType;                                                // 0x0228 (size: 0x1)
    FColor BrushColor;                                                                // 0x022C (size: 0x4)
    int32 PolyFlags;                                                                  // 0x0230 (size: 0x4)
    uint8 bColored;                                                                   // 0x0234 (size: 0x1)
    uint8 bSolidWhenSelected;                                                         // 0x0234 (size: 0x1)
    uint8 bPlaceableFromClassBrowser;                                                 // 0x0234 (size: 0x1)
    uint8 bNotForClientOrServer;                                                      // 0x0234 (size: 0x1)
    class UModel* Brush;                                                              // 0x0238 (size: 0x8)
    class UBrushComponent* BrushComponent;                                            // 0x0240 (size: 0x8)
    uint8 bInManipulation;                                                            // 0x0248 (size: 0x1)
    TArray<FGeomSelection> SavedSelections;                                           // 0x0250 (size: 0x10)

}; // Size: 0x260

class AVolume : public ABrush
{
}; // Size: 0x260

struct FLightmassMaterialInterfaceSettings
{
    float EmissiveBoost;                                                              // 0x0000 (size: 0x4)
    float DiffuseBoost;                                                               // 0x0004 (size: 0x4)
    float ExportResolutionScale;                                                      // 0x0008 (size: 0x4)
    uint8 bCastShadowAsMasked;                                                        // 0x000C (size: 0x1)
    uint8 bOverrideCastShadowAsMasked;                                                // 0x000C (size: 0x1)
    uint8 bOverrideEmissiveBoost;                                                     // 0x000C (size: 0x1)
    uint8 bOverrideDiffuseBoost;                                                      // 0x000C (size: 0x1)
    uint8 bOverrideExportResolutionScale;                                             // 0x000C (size: 0x1)

}; // Size: 0x10

struct FMaterialTextureInfo
{
    float SamplingScale;                                                              // 0x0000 (size: 0x4)
    int32 UVChannelIndex;                                                             // 0x0004 (size: 0x4)
    FName TextureName;                                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FMaterialParameterInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<EMaterialParameterAssociation> Association;                           // 0x0008 (size: 0x1)
    int32 Index;                                                                      // 0x000C (size: 0x4)

}; // Size: 0x10

class UMaterialInterface : public UObject
{
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x0038 (size: 0x8)
    FLightmassMaterialInterfaceSettings LightmassSettings;                            // 0x0050 (size: 0x10)
    TArray<FMaterialTextureInfo> TextureStreamingData;                                // 0x0060 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0070 (size: 0x10)

    void SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32 CinematicTextureGroups, bool bFastResponse);
    class UPhysicalMaterialMask* GetPhysicalMaterialMask();
    class UPhysicalMaterial* GetPhysicalMaterialFromMap(int32 Index);
    class UPhysicalMaterial* GetPhysicalMaterial();
    FMaterialParameterInfo GetParameterInfo(TEnumAsByte<EMaterialParameterAssociation> Association, FName ParameterName, class UMaterialFunctionInterface* LayerFunction);
    class UMaterial* GetBaseMaterial();
}; // Size: 0x88

struct FScalarParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    float ParameterValue;                                                             // 0x0010 (size: 0x4)
    FGuid ExpressionGUID;                                                             // 0x0014 (size: 0x10)

}; // Size: 0x24

struct FVectorParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    FLinearColor ParameterValue;                                                      // 0x0010 (size: 0x10)
    FGuid ExpressionGUID;                                                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FTextureParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class UTexture* ParameterValue;                                                   // 0x0010 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FRuntimeVirtualTextureParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class URuntimeVirtualTexture* ParameterValue;                                     // 0x0010 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FFontParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class UFont* FontValue;                                                           // 0x0010 (size: 0x8)
    int32 FontPage;                                                                   // 0x0018 (size: 0x4)
    FGuid ExpressionGUID;                                                             // 0x001C (size: 0x10)

}; // Size: 0x30

struct FMaterialInstanceBasePropertyOverrides
{
    uint8 bOverride_OpacityMaskClipValue;                                             // 0x0000 (size: 0x1)
    uint8 bOverride_BlendMode;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ShadingModel;                                                     // 0x0000 (size: 0x1)
    uint8 bOverride_DitheredLODTransition;                                            // 0x0000 (size: 0x1)
    uint8 bOverride_CastDynamicShadowAsMasked;                                        // 0x0000 (size: 0x1)
    uint8 bOverride_TwoSided;                                                         // 0x0000 (size: 0x1)
    uint8 TwoSided;                                                                   // 0x0000 (size: 0x1)
    uint8 DitheredLODTransition;                                                      // 0x0000 (size: 0x1)
    uint8 bCastDynamicShadowAsMasked;                                                 // 0x0001 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x0002 (size: 0x1)
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x0003 (size: 0x1)
    float OpacityMaskClipValue;                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FStaticParameterBase
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    bool bOverride;                                                                   // 0x0010 (size: 0x1)
    FGuid ExpressionGUID;                                                             // 0x0014 (size: 0x10)

}; // Size: 0x24

struct FStaticSwitchParameter : public FStaticParameterBase
{
    bool Value;                                                                       // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FStaticComponentMaskParameter : public FStaticParameterBase
{
    bool R;                                                                           // 0x0024 (size: 0x1)
    bool G;                                                                           // 0x0025 (size: 0x1)
    bool B;                                                                           // 0x0026 (size: 0x1)
    bool A;                                                                           // 0x0027 (size: 0x1)

}; // Size: 0x28

struct FStaticTerrainLayerWeightParameter : public FStaticParameterBase
{
    int32 WeightmapIndex;                                                             // 0x0024 (size: 0x4)
    bool bWeightBasedBlend;                                                           // 0x0028 (size: 0x1)

}; // Size: 0x2C

struct FMaterialLayersFunctions
{
    TArray<class UMaterialFunctionInterface*> Layers;                                 // 0x0000 (size: 0x10)
    TArray<class UMaterialFunctionInterface*> Blends;                                 // 0x0010 (size: 0x10)
    TArray<bool> LayerStates;                                                         // 0x0020 (size: 0x10)
    FString KeyString;                                                                // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FStaticMaterialLayersParameter : public FStaticParameterBase
{
    FMaterialLayersFunctions Value;                                                   // 0x0028 (size: 0x40)

}; // Size: 0x68

struct FStaticParameterSet
{
    TArray<FStaticSwitchParameter> StaticSwitchParameters;                            // 0x0000 (size: 0x10)
    TArray<FStaticComponentMaskParameter> StaticComponentMaskParameters;              // 0x0010 (size: 0x10)
    TArray<FStaticTerrainLayerWeightParameter> TerrainLayerWeightParameters;          // 0x0020 (size: 0x10)
    TArray<FStaticMaterialLayersParameter> MaterialLayersParameters;                  // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FMaterialCachedParameterEntry
{
    TArray<uint64> NameHashes;                                                        // 0x0000 (size: 0x10)
    TArray<FMaterialParameterInfo> ParameterInfos;                                    // 0x0010 (size: 0x10)
    TArray<FGuid> ExpressionGuids;                                                    // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FMaterialCachedParameters
{
    FMaterialCachedParameterEntry RuntimeEntries;                                     // 0x0000 (size: 0xF0)
    TArray<float> ScalarValues;                                                       // 0x00F0 (size: 0x10)
    TArray<FLinearColor> VectorValues;                                                // 0x0100 (size: 0x10)
    TArray<class UTexture*> TextureValues;                                            // 0x0110 (size: 0x10)
    TArray<class UFont*> FontValues;                                                  // 0x0120 (size: 0x10)
    TArray<int32> FontPageValues;                                                     // 0x0130 (size: 0x10)
    TArray<class URuntimeVirtualTexture*> RuntimeVirtualTextureValues;                // 0x0140 (size: 0x10)

}; // Size: 0x150

class UMaterialInstance : public UMaterialInterface
{
    class UPhysicalMaterial* PhysMaterial;                                            // 0x0088 (size: 0x8)
    class UPhysicalMaterial* PhysicalMaterialMap;                                     // 0x0090 (size: 0x40)
    class UMaterialInterface* Parent;                                                 // 0x00D0 (size: 0x8)
    uint8 bHasStaticPermutationResource;                                              // 0x00D8 (size: 0x1)
    uint8 bOverrideSubsurfaceProfile;                                                 // 0x00D8 (size: 0x1)
    TArray<FScalarParameterValue> ScalarParameterValues;                              // 0x00E0 (size: 0x10)
    TArray<FVectorParameterValue> VectorParameterValues;                              // 0x00F0 (size: 0x10)
    TArray<FTextureParameterValue> TextureParameterValues;                            // 0x0100 (size: 0x10)
    TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues; // 0x0110 (size: 0x10)
    TArray<FFontParameterValue> FontParameterValues;                                  // 0x0120 (size: 0x10)
    FMaterialInstanceBasePropertyOverrides BasePropertyOverrides;                     // 0x0130 (size: 0x8)
    FStaticParameterSet StaticParameters;                                             // 0x0148 (size: 0x40)
    FMaterialCachedParameters CachedLayerParameters;                                  // 0x0188 (size: 0x150)
    TArray<class UObject*> CachedReferencedTextures;                                  // 0x02D8 (size: 0x10)

}; // Size: 0x310

class UMaterialInstanceConstant : public UMaterialInstance
{
    class UPhysicalMaterialMask* PhysMaterialMask;                                    // 0x0310 (size: 0x8)

    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
    class UTexture* K2_GetTextureParameterValue(FName ParameterName);
    float K2_GetScalarParameterValue(FName ParameterName);
}; // Size: 0x318

class UWorldSubsystem : public USubsystem
{
}; // Size: 0x30

class UTickableWorldSubsystem : public UWorldSubsystem
{
}; // Size: 0x40

class UMaterialExpression : public UObject
{
    class UMaterial* Material;                                                        // 0x0028 (size: 0x8)
    class UMaterialFunction* Function;                                                // 0x0030 (size: 0x8)
    uint8 bIsParameterExpression;                                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class UMaterialExpressionCustomOutput : public UMaterialExpression
{
}; // Size: 0x40

struct FExpressionInput
{
    int32 OutputIndex;                                                                // 0x0000 (size: 0x4)
    FName InputName;                                                                  // 0x0004 (size: 0x8)
    FName ExpressionName;                                                             // 0x000C (size: 0x8)

}; // Size: 0x14

class UEngineCustomTimeStep : public UObject
{
}; // Size: 0x28

struct FBranchingPointNotifyPayload
{
}; // Size: 0x20

struct FIntegralKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    int32 Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FIntegralCurve : public FIndexedCurve
{
    TArray<FIntegralKey> Keys;                                                        // 0x0068 (size: 0x10)
    int32 DefaultValue;                                                               // 0x0078 (size: 0x4)
    bool bUseDefaultValueBeforeFirstKey;                                              // 0x007C (size: 0x1)

}; // Size: 0x80

struct FNameCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FName Value;                                                                      // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FNameCurve : public FIndexedCurve
{
    TArray<FNameCurveKey> Keys;                                                       // 0x0068 (size: 0x10)

}; // Size: 0x78

class UDynamicBlueprintBinding : public UObject
{
}; // Size: 0x28

struct FBPComponentClassOverride
{
    FName ComponentName;                                                              // 0x0000 (size: 0x8)
    UClass* ComponentClass;                                                           // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBlueprintComponentChangedPropertyInfo
{
    FName PropertyName;                                                               // 0x0000 (size: 0x8)
    int32 ArrayIndex;                                                                 // 0x0008 (size: 0x4)
    class UStruct* PropertyScope;                                                     // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FBlueprintCookedComponentInstancingData
{
    TArray<FBlueprintComponentChangedPropertyInfo> ChangedPropertyList;               // 0x0000 (size: 0x10)
    bool bHasValidCookedData;                                                         // 0x0021 (size: 0x1)

}; // Size: 0x48

class UBlueprintGeneratedClass : public UClass
{
    int32 NumReplicatedProperties;                                                    // 0x0230 (size: 0x4)
    uint8 bHasNativizedParent;                                                        // 0x0234 (size: 0x1)
    uint8 bHasCookedComponentInstancingData;                                          // 0x0234 (size: 0x1)
    TArray<class UDynamicBlueprintBinding*> DynamicBindingObjects;                    // 0x0238 (size: 0x10)
    TArray<class UActorComponent*> ComponentTemplates;                                // 0x0248 (size: 0x10)
    TArray<class UTimelineTemplate*> Timelines;                                       // 0x0258 (size: 0x10)
    TArray<FBPComponentClassOverride> ComponentClassOverrides;                        // 0x0268 (size: 0x10)
    class USimpleConstructionScript* SimpleConstructionScript;                        // 0x0278 (size: 0x8)
    class UInheritableComponentHandler* InheritableComponentHandler;                  // 0x0280 (size: 0x8)
    class UStructProperty* UberGraphFramePointerProperty;                             // 0x0288 (size: 0x8)
    class UFunction* UberGraphFunction;                                               // 0x0298 (size: 0x8)
    TMap<class FName, class FBlueprintCookedComponentInstancingData> CookedComponentInstancingData; // 0x02A0 (size: 0x50)

}; // Size: 0x328

class ACameraActor : public AActor
{
    TEnumAsByte<EAutoReceiveInput::Type> AutoActivateForPlayer;                       // 0x0228 (size: 0x1)
    class UCameraComponent* CameraComponent;                                          // 0x0230 (size: 0x8)
    class USceneComponent* SceneComponent;                                            // 0x0238 (size: 0x8)
    uint8 bConstrainAspectRatio;                                                      // 0x0248 (size: 0x1)
    float AspectRatio;                                                                // 0x024C (size: 0x4)
    float FOVAngle;                                                                   // 0x0250 (size: 0x4)
    float PostProcessBlendWeight;                                                     // 0x0254 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x0260 (size: 0x560)

    int32 GetAutoActivatePlayerIndex();
}; // Size: 0x7C0

class UCameraComponent : public USceneComponent
{
    float FieldOfView;                                                                // 0x01F8 (size: 0x4)
    float OrthoWidth;                                                                 // 0x01FC (size: 0x4)
    float OrthoNearClipPlane;                                                         // 0x0200 (size: 0x4)
    float OrthoFarClipPlane;                                                          // 0x0204 (size: 0x4)
    float AspectRatio;                                                                // 0x0208 (size: 0x4)
    uint8 bConstrainAspectRatio;                                                      // 0x020C (size: 0x1)
    uint8 bUseFieldOfViewForLOD;                                                      // 0x020C (size: 0x1)
    uint8 bLockToHmd;                                                                 // 0x020C (size: 0x1)
    uint8 bUsePawnControlRotation;                                                    // 0x020C (size: 0x1)
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionMode;                          // 0x020D (size: 0x1)
    float PostProcessBlendWeight;                                                     // 0x0240 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x0270 (size: 0x560)

    void SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD);
    void SetProjectionMode(TEnumAsByte<ECameraProjectionMode::Type> InProjectionMode);
    void SetPostProcessBlendWeight(float InPostProcessBlendWeight);
    void SetOrthoWidth(float InOrthoWidth);
    void SetOrthoNearClipPlane(float InOrthoNearClipPlane);
    void SetOrthoFarClipPlane(float InOrthoFarClipPlane);
    void SetFieldOfView(float InFieldOfView);
    void SetConstraintAspectRatio(bool bInConstrainAspectRatio);
    void SetAspectRatio(float InAspectRatio);
    void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
    void OnCameraMeshHiddenChanged();
    void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView);
    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x7D0

struct FSoundSubmixSpectralAnalysisBandSettings
{
    float BandFrequency;                                                              // 0x0000 (size: 0x4)
    int32 AttackTimeMsec;                                                             // 0x0004 (size: 0x4)
    int32 ReleaseTimeMsec;                                                            // 0x0008 (size: 0x4)
    float QFactor;                                                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSourceEffectChainEntry
{
    class USoundEffectSourcePreset* Preset;                                           // 0x0000 (size: 0x8)
    uint8 bBypass;                                                                    // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FQuartzTransportTimeStamp
{
    int32 Bars;                                                                       // 0x0000 (size: 0x4)
    int32 Beat;                                                                       // 0x0004 (size: 0x4)
    float BeatFraction;                                                               // 0x0008 (size: 0x4)
    float Seconds;                                                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FQuartzPulseOverrideStep
{
    int32 NumberOfPulses;                                                             // 0x0000 (size: 0x4)
    EQuartzCommandQuantization PulseDuration;                                         // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FQuartzTimeSignature
{
    int32 NumBeats;                                                                   // 0x0000 (size: 0x4)
    EQuartzTimeSignatureQuantization BeatType;                                        // 0x0004 (size: 0x1)
    TArray<FQuartzPulseOverrideStep> OptionalPulseOverride;                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FQuartzClockSettings
{
    FQuartzTimeSignature TimeSignature;                                               // 0x0000 (size: 0x18)
    bool bIgnoreLevelChange;                                                          // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSoundWaveSpectralDataEntry
{
    float Magnitude;                                                                  // 0x0000 (size: 0x4)
    float NormalizedMagnitude;                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSoundWaveSpectralTimeData
{
    TArray<FSoundWaveSpectralDataEntry> Data;                                         // 0x0000 (size: 0x10)
    float TimeSec;                                                                    // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSoundWaveEnvelopeTimeData
{
    float Amplitude;                                                                  // 0x0000 (size: 0x4)
    float TimeSec;                                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

class USoundWave : public USoundBase
{
    int32 CompressionQuality;                                                         // 0x0170 (size: 0x4)
    int32 StreamingPriority;                                                          // 0x0174 (size: 0x4)
    ESoundwaveSampleRateSettings SampleRateQuality;                                   // 0x0178 (size: 0x1)
    TEnumAsByte<ESoundGroup> SoundGroup;                                              // 0x017A (size: 0x1)
    uint8 bLooping;                                                                   // 0x017B (size: 0x1)
    uint8 bStreaming;                                                                 // 0x017B (size: 0x1)
    uint8 bSeekableStreaming;                                                         // 0x017B (size: 0x1)
    ESoundWaveLoadingBehavior LoadingBehavior;                                        // 0x017C (size: 0x1)
    uint8 bMature;                                                                    // 0x017D (size: 0x1)
    uint8 bManualWordWrap;                                                            // 0x017D (size: 0x1)
    uint8 bSingleLine;                                                                // 0x017E (size: 0x1)
    uint8 bIsAmbisonics;                                                              // 0x017E (size: 0x1)
    FSoundModulationDefaultRoutingSettings ModulationSettings;                        // 0x0180 (size: 0x48)
    TArray<float> FrequenciesToAnalyze;                                               // 0x01C8 (size: 0x10)
    TArray<FSoundWaveSpectralTimeData> CookedSpectralTimeData;                        // 0x01D8 (size: 0x10)
    TArray<FSoundWaveEnvelopeTimeData> CookedEnvelopeTimeData;                        // 0x01E8 (size: 0x10)
    int32 InitialChunkSize;                                                           // 0x01F8 (size: 0x4)
    FString SpokenText;                                                               // 0x0240 (size: 0x10)
    float SubtitlePriority;                                                           // 0x0250 (size: 0x4)
    float Volume;                                                                     // 0x0254 (size: 0x4)
    float Pitch;                                                                      // 0x0258 (size: 0x4)
    int32 NumChannels;                                                                // 0x025C (size: 0x4)
    int32 SampleRate;                                                                 // 0x0260 (size: 0x4)
    TArray<FSubtitleCue> Subtitles;                                                   // 0x0270 (size: 0x10)
    class UCurveTable* Curves;                                                        // 0x0280 (size: 0x8)
    class UCurveTable* InternalCurves;                                                // 0x0288 (size: 0x8)

}; // Size: 0x370

class USoundWaveProcedural : public USoundWave
{
}; // Size: 0x3C0

class UBlueprintCore : public UObject
{
    UClass* SkeletonGeneratedClass;                                                   // 0x0028 (size: 0x8)
    UClass* GeneratedClass;                                                           // 0x0030 (size: 0x8)
    bool bLegacyNeedToPurgeSkelRefs;                                                  // 0x0038 (size: 0x1)
    FGuid BlueprintGuid;                                                              // 0x003C (size: 0x10)

}; // Size: 0x50

class UBlueprint : public UBlueprintCore
{
    UClass* ParentClass;                                                              // 0x0050 (size: 0x8)
    TEnumAsByte<EBlueprintType> BlueprintType;                                        // 0x0058 (size: 0x1)
    uint8 bRecompileOnLoad;                                                           // 0x0059 (size: 0x1)
    uint8 bHasBeenRegenerated;                                                        // 0x0059 (size: 0x1)
    uint8 bIsRegeneratingOnLoad;                                                      // 0x0059 (size: 0x1)
    int32 BlueprintSystemVersion;                                                     // 0x005C (size: 0x4)
    class USimpleConstructionScript* SimpleConstructionScript;                        // 0x0060 (size: 0x8)
    TArray<class UActorComponent*> ComponentTemplates;                                // 0x0068 (size: 0x10)
    TArray<class UTimelineTemplate*> Timelines;                                       // 0x0078 (size: 0x10)
    TArray<FBPComponentClassOverride> ComponentClassOverrides;                        // 0x0088 (size: 0x10)
    class UInheritableComponentHandler* InheritableComponentHandler;                  // 0x0098 (size: 0x8)

}; // Size: 0xA0

class UModel : public UObject
{
}; // Size: 0x258

class UChannel : public UObject
{
    class UNetConnection* Connection;                                                 // 0x0028 (size: 0x8)

}; // Size: 0x68

class UActorChannel : public UChannel
{
    class AActor* Actor;                                                              // 0x0068 (size: 0x8)
    TArray<class UObject*> CreateSubObjects;                                          // 0x0158 (size: 0x10)

}; // Size: 0x290

class UAnimationAsset : public UObject
{
    class USkeleton* Skeleton;                                                        // 0x0038 (size: 0x8)
    TArray<class UAnimMetaData*> MetaData;                                            // 0x0060 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FInterpolationParameter
{
    float InterpolationTime;                                                          // 0x0000 (size: 0x4)
    TEnumAsByte<EFilterInterpolationType> InterpolationType;                          // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FPerBoneInterpolation
{
    FBoneReference BoneReference;                                                     // 0x0000 (size: 0x10)
    float InterpolationSpeedPerSec;                                                   // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FBlendSample
{
    class UAnimSequence* Animation;                                                   // 0x0000 (size: 0x8)
    FVector SampleValue;                                                              // 0x0008 (size: 0xC)
    float RateScale;                                                                  // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FEditorElement
{
    int32 Indices;                                                                    // 0x0000 (size: 0xC)
    float Weights;                                                                    // 0x000C (size: 0xC)

}; // Size: 0x18

struct FBlendParameter
{
    FString DisplayName;                                                              // 0x0000 (size: 0x10)
    float Min;                                                                        // 0x0010 (size: 0x4)
    float Max;                                                                        // 0x0014 (size: 0x4)
    int32 GridNum;                                                                    // 0x0018 (size: 0x4)

}; // Size: 0x20

class UBlendSpaceBase : public UAnimationAsset
{
    bool bRotationBlendInMeshSpace;                                                   // 0x0088 (size: 0x1)
    float AnimLength;                                                                 // 0x008C (size: 0x4)
    FInterpolationParameter InterpolationParam;                                       // 0x0090 (size: 0x18)
    float TargetWeightInterpolationSpeedPerSec;                                       // 0x00A8 (size: 0x4)
    TEnumAsByte<ENotifyTriggerMode::Type> NotifyTriggerMode;                          // 0x00AC (size: 0x1)
    TArray<FPerBoneInterpolation> PerBoneBlend;                                       // 0x00B0 (size: 0x10)
    int32 SampleIndexWithMarkers;                                                     // 0x00C0 (size: 0x4)
    TArray<FBlendSample> SampleData;                                                  // 0x00C8 (size: 0x10)
    TArray<FEditorElement> GridSamples;                                               // 0x00D8 (size: 0x10)
    FBlendParameter BlendParameters;                                                  // 0x00E8 (size: 0x60)

}; // Size: 0x148

class UBlendSpace : public UBlendSpaceBase
{
    TEnumAsByte<EBlendSpaceAxis> AxisToScaleAnimation;                                // 0x0148 (size: 0x1)

}; // Size: 0x150

class UAimOffsetBlendSpace : public UBlendSpace
{
}; // Size: 0x150

class UBlendSpace1D : public UBlendSpaceBase
{
    bool bScaleAnimation;                                                             // 0x0148 (size: 0x1)

}; // Size: 0x150

class UAimOffsetBlendSpace1D : public UBlendSpace1D
{
}; // Size: 0x150

class UAISystemBase : public UObject
{
    FSoftClassPath AISystemClassName;                                                 // 0x0028 (size: 0x18)
    FName AISystemModuleName;                                                         // 0x0040 (size: 0x8)
    bool bInstantiateAISystemOnClient;                                                // 0x0050 (size: 0x1)

}; // Size: 0x58

class AAmbientSound : public AActor
{
    class UAudioComponent* AudioComponent;                                            // 0x0228 (size: 0x8)

    void Stop();
    void Play(float StartTime);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel);
    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
}; // Size: 0x230

struct FCustomAttributeSetting
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString Meaning;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

class UAnimationSettings : public UDeveloperSettings
{
    int32 CompressCommandletVersion;                                                  // 0x0038 (size: 0x4)
    TArray<FString> KeyEndEffectorsMatchNameArray;                                    // 0x0040 (size: 0x10)
    bool ForceRecompression;                                                          // 0x0050 (size: 0x1)
    bool bForceBelowThreshold;                                                        // 0x0051 (size: 0x1)
    bool bFirstRecompressUsingCurrentOrDefault;                                       // 0x0052 (size: 0x1)
    bool bRaiseMaxErrorToExisting;                                                    // 0x0053 (size: 0x1)
    bool bEnablePerformanceLog;                                                       // 0x0054 (size: 0x1)
    bool bStripAnimationDataOnDedicatedServer;                                        // 0x0055 (size: 0x1)
    bool bTickAnimationOnSkeletalMeshInit;                                            // 0x0056 (size: 0x1)
    TArray<FCustomAttributeSetting> BoneCustomAttributesNames;                        // 0x0058 (size: 0x10)
    TArray<FString> BoneNamesWithCustomAttributes;                                    // 0x0068 (size: 0x10)
    TMap<class FName, class ECustomAttributeBlendType> AttributeBlendModes;           // 0x0078 (size: 0x50)
    ECustomAttributeBlendType DefaultAttributeBlendMode;                              // 0x00C8 (size: 0x1)

}; // Size: 0xD0

struct FAnimGroupInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FLinearColor Color;                                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

class UAnimBlueprint : public UBlueprint
{
    class USkeleton* TargetSkeleton;                                                  // 0x00A8 (size: 0x8)
    TArray<FAnimGroupInfo> Groups;                                                    // 0x00B0 (size: 0x10)
    bool bUseMultiThreadedAnimationUpdate;                                            // 0x00C0 (size: 0x1)
    bool bWarnAboutBlueprintUsage;                                                    // 0x00C1 (size: 0x1)

}; // Size: 0xC8

struct FBakedStateExitTransition
{
    int32 CanTakeDelegateIndex;                                                       // 0x0000 (size: 0x4)
    int32 CustomResultNodeIndex;                                                      // 0x0004 (size: 0x4)
    int32 TransitionIndex;                                                            // 0x0008 (size: 0x4)
    bool bDesiredTransitionReturnValue;                                               // 0x000C (size: 0x1)
    bool bAutomaticRemainingTimeRule;                                                 // 0x000D (size: 0x1)
    TArray<int32> PoseEvaluatorLinks;                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBakedAnimationState
{
    FName StateName;                                                                  // 0x0000 (size: 0x8)
    TArray<FBakedStateExitTransition> Transitions;                                    // 0x0008 (size: 0x10)
    int32 StateRootNodeIndex;                                                         // 0x0018 (size: 0x4)
    int32 StartNotify;                                                                // 0x001C (size: 0x4)
    int32 EndNotify;                                                                  // 0x0020 (size: 0x4)
    int32 FullyBlendedNotify;                                                         // 0x0024 (size: 0x4)
    bool bIsAConduit;                                                                 // 0x0028 (size: 0x1)
    int32 EntryRuleNodeIndex;                                                         // 0x002C (size: 0x4)
    TArray<int32> PlayerNodeIndices;                                                  // 0x0030 (size: 0x10)
    TArray<int32> LayerNodeIndices;                                                   // 0x0040 (size: 0x10)
    bool bAlwaysResetOnEntry;                                                         // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FAnimationStateBase
{
    FName StateName;                                                                  // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAnimationTransitionBetweenStates : public FAnimationStateBase
{
    int32 PreviousState;                                                              // 0x0008 (size: 0x4)
    int32 NextState;                                                                  // 0x000C (size: 0x4)
    float CrossfadeDuration;                                                          // 0x0010 (size: 0x4)
    int32 StartNotify;                                                                // 0x0014 (size: 0x4)
    int32 EndNotify;                                                                  // 0x0018 (size: 0x4)
    int32 InterruptNotify;                                                            // 0x001C (size: 0x4)
    EAlphaBlendOption BlendMode;                                                      // 0x0020 (size: 0x1)
    class UCurveFloat* CustomCurve;                                                   // 0x0028 (size: 0x8)
    class UBlendProfile* BlendProfile;                                                // 0x0030 (size: 0x8)
    TEnumAsByte<ETransitionLogicType::Type> LogicType;                                // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FBakedAnimationStateMachine
{
    FName MachineName;                                                                // 0x0000 (size: 0x8)
    int32 InitialState;                                                               // 0x0008 (size: 0x4)
    TArray<FBakedAnimationState> States;                                              // 0x0010 (size: 0x10)
    TArray<FAnimationTransitionBetweenStates> Transitions;                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FCachedPoseIndices
{
    TArray<int32> OrderedSavedPoseNodeIndices;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FExposedValueCopyRecord
{
    int32 CopyIndex;                                                                  // 0x0000 (size: 0x4)
    EPostCopyOperation PostCopyOperation;                                             // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FExposedValueHandler
{
    FName BoundFunction;                                                              // 0x0000 (size: 0x8)
    TArray<FExposedValueCopyRecord> CopyRecords;                                      // 0x0008 (size: 0x10)
    class UFunction* Function;                                                        // 0x0018 (size: 0x8)
    TFieldPath<FStructProperty> ValueHandlerNodeProperty;                             // 0x0020 (size: 0x20)

}; // Size: 0x50

struct FGraphAssetPlayerInformation
{
    TArray<int32> PlayerNodeIndices;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnimGraphBlendOptions
{
    float blendInTime;                                                                // 0x0000 (size: 0x4)
    float blendOutTime;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

class UAnimBlueprintGeneratedClass : public UBlueprintGeneratedClass
{
    TArray<FBakedAnimationStateMachine> BakedStateMachines;                           // 0x0330 (size: 0x10)
    class USkeleton* TargetSkeleton;                                                  // 0x0340 (size: 0x8)
    TArray<FAnimNotifyEvent> AnimNotifies;                                            // 0x0348 (size: 0x10)
    TMap<class FName, class FCachedPoseIndices> OrderedSavedPoseIndicesMap;           // 0x0358 (size: 0x50)
    TArray<FName> SyncGroupNames;                                                     // 0x0428 (size: 0x10)
    TArray<FExposedValueHandler> EvaluateGraphExposedInputs;                          // 0x0438 (size: 0x10)
    TMap<class FName, class FGraphAssetPlayerInformation> GraphAssetPlayerInformation; // 0x0448 (size: 0x50)
    TMap<class FName, class FAnimGraphBlendOptions> GraphBlendOptions;                // 0x0498 (size: 0x50)
    FPropertyAccessLibrary PropertyAccessLibrary;                                     // 0x04E8 (size: 0xC8)

}; // Size: 0x5B0

class UAnimBoneCompressionCodec : public UObject
{
    FString Description;                                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAnimBoneCompressionSettings : public UObject
{
    TArray<class UAnimBoneCompressionCodec*> Codecs;                                  // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FAnimBlueprintFunction
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FName Group;                                                                      // 0x0008 (size: 0x8)
    int32 OutputPoseNodeIndex;                                                        // 0x0010 (size: 0x4)
    TArray<FName> InputPoseNames;                                                     // 0x0018 (size: 0x10)
    TArray<int32> InputPoseNodeIndices;                                               // 0x0028 (size: 0x10)
    bool bImplemented;                                                                // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FAnimBlueprintFunctionData
{
    TFieldPath<FStructProperty> OutputPoseNodeProperty;                               // 0x0000 (size: 0x20)
    TArray<TFieldPath<FStructProperty>> InputPoseNodeProperties;                      // 0x0020 (size: 0x10)
    TArray<TFieldPath<FProperty>> InputProperties;                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

class UAnimClassData : public UObject
{
    TArray<FBakedAnimationStateMachine> BakedStateMachines;                           // 0x0030 (size: 0x10)
    class USkeleton* TargetSkeleton;                                                  // 0x0040 (size: 0x8)
    TArray<FAnimNotifyEvent> AnimNotifies;                                            // 0x0048 (size: 0x10)
    TMap<class FName, class FCachedPoseIndices> OrderedSavedPoseIndicesMap;           // 0x0058 (size: 0x50)
    TArray<FAnimBlueprintFunction> AnimBlueprintFunctions;                            // 0x00A8 (size: 0x10)
    TArray<FAnimBlueprintFunctionData> AnimBlueprintFunctionData;                     // 0x00B8 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> AnimNodeProperties;                           // 0x00C8 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> LinkedAnimGraphNodeProperties;                // 0x00E8 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> LinkedAnimLayerNodeProperties;                // 0x0108 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> PreUpdateNodeProperties;                      // 0x0128 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> DynamicResetNodeProperties;                   // 0x0148 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> StateMachineNodeProperties;                   // 0x0168 (size: 0x10)
    TArray<TFieldPath<FStructProperty>> InitializationNodeProperties;                 // 0x0188 (size: 0x10)
    TMap<class FName, class FGraphAssetPlayerInformation> GraphNameAssetPlayers;      // 0x01A8 (size: 0x50)
    TArray<FName> SyncGroupNames;                                                     // 0x01F8 (size: 0x10)
    TArray<FExposedValueHandler> EvaluateGraphExposedInputs;                          // 0x0208 (size: 0x10)
    TMap<class FName, class FAnimGraphBlendOptions> GraphBlendOptions;                // 0x0218 (size: 0x50)
    FPropertyAccessLibrary PropertyAccessLibrary;                                     // 0x0268 (size: 0xC8)

}; // Size: 0x330

class IAnimClassInterface : public IInterface
{
}; // Size: 0x28

struct FSmartName
{
    FName DisplayName;                                                                // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FAnimCurveBase
{
    FName LastObservedName;                                                           // 0x0000 (size: 0x8)
    FSmartName Name;                                                                  // 0x0008 (size: 0xC)
    int32 CurveTypeFlags;                                                             // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FFloatCurve : public FAnimCurveBase
{
    FRichCurve FloatCurve;                                                            // 0x0018 (size: 0x80)

}; // Size: 0x98

struct FRawCurveTracks
{
    TArray<FFloatCurve> FloatCurves;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

class UAnimSequenceBase : public UAnimationAsset
{
    TArray<FAnimNotifyEvent> Notifies;                                                // 0x0080 (size: 0x10)
    float SequenceLength;                                                             // 0x0090 (size: 0x4)
    float RateScale;                                                                  // 0x0094 (size: 0x4)
    FRawCurveTracks RawCurveData;                                                     // 0x0098 (size: 0x10)

    float GetPlayLength();
}; // Size: 0xA8

class UAnimCompositeBase : public UAnimSequenceBase
{
}; // Size: 0xA8

struct FAnimSegment
{
    class UAnimSequenceBase* AnimReference;                                           // 0x0000 (size: 0x8)
    float StartPos;                                                                   // 0x0008 (size: 0x4)
    float AnimStartTime;                                                              // 0x000C (size: 0x4)
    float AnimEndTime;                                                                // 0x0010 (size: 0x4)
    float AnimPlayRate;                                                               // 0x0014 (size: 0x4)
    int32 LoopingCount;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FAnimTrack
{
    TArray<FAnimSegment> AnimSegments;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

class UAnimComposite : public UAnimCompositeBase
{
    FAnimTrack AnimationTrack;                                                        // 0x00A8 (size: 0x10)

}; // Size: 0xB8

class UAnimCompress : public UAnimBoneCompressionCodec
{
    uint8 bNeedsSkeleton;                                                             // 0x0038 (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> TranslationCompressionFormat;             // 0x003C (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> RotationCompressionFormat;                // 0x003D (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> ScaleCompressionFormat;                   // 0x003E (size: 0x1)

}; // Size: 0x40

class UAnimCompress_BitwiseCompressOnly : public UAnimCompress
{
}; // Size: 0x40

class UAnimCompress_LeastDestructive : public UAnimCompress_BitwiseCompressOnly
{
}; // Size: 0x40

class UAnimCompress_RemoveLinearKeys : public UAnimCompress
{
    float MaxPosDiff;                                                                 // 0x0040 (size: 0x4)
    float MaxAngleDiff;                                                               // 0x0044 (size: 0x4)
    float MaxScaleDiff;                                                               // 0x0048 (size: 0x4)
    float MaxEffectorDiff;                                                            // 0x004C (size: 0x4)
    float MinEffectorDiff;                                                            // 0x0050 (size: 0x4)
    float EffectorDiffSocket;                                                         // 0x0054 (size: 0x4)
    float ParentKeyScale;                                                             // 0x0058 (size: 0x4)
    uint8 bRetarget;                                                                  // 0x005C (size: 0x1)
    uint8 bActuallyFilterLinearKeys;                                                  // 0x005C (size: 0x1)

}; // Size: 0x60

class UAnimCompress_PerTrackCompression : public UAnimCompress_RemoveLinearKeys
{
    float MaxZeroingThreshold;                                                        // 0x0060 (size: 0x4)
    float MaxPosDiffBitwise;                                                          // 0x0064 (size: 0x4)
    float MaxAngleDiffBitwise;                                                        // 0x0068 (size: 0x4)
    float MaxScaleDiffBitwise;                                                        // 0x006C (size: 0x4)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedRotationFormats;           // 0x0070 (size: 0x10)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedTranslationFormats;        // 0x0080 (size: 0x10)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedScaleFormats;              // 0x0090 (size: 0x10)
    uint8 bResampleAnimation;                                                         // 0x00A0 (size: 0x1)
    float ResampledFramerate;                                                         // 0x00A4 (size: 0x4)
    int32 MinKeysForResampling;                                                       // 0x00A8 (size: 0x4)
    uint8 bUseAdaptiveError;                                                          // 0x00AC (size: 0x1)
    uint8 bUseOverrideForEndEffectors;                                                // 0x00AC (size: 0x1)
    int32 TrackHeightBias;                                                            // 0x00B0 (size: 0x4)
    float ParentingDivisor;                                                           // 0x00B4 (size: 0x4)
    float ParentingDivisorExponent;                                                   // 0x00B8 (size: 0x4)
    uint8 bUseAdaptiveError2;                                                         // 0x00BC (size: 0x1)
    float RotationErrorSourceRatio;                                                   // 0x00C0 (size: 0x4)
    float TranslationErrorSourceRatio;                                                // 0x00C4 (size: 0x4)
    float ScaleErrorSourceRatio;                                                      // 0x00C8 (size: 0x4)
    float MaxErrorPerTrackRatio;                                                      // 0x00CC (size: 0x4)
    float PerturbationProbeSize;                                                      // 0x00D0 (size: 0x4)

}; // Size: 0xD8

class UAnimCompress_RemoveEverySecondKey : public UAnimCompress
{
    int32 MinKeys;                                                                    // 0x0040 (size: 0x4)
    uint8 bStartAtSecondKey;                                                          // 0x0044 (size: 0x1)

}; // Size: 0x48

class UAnimCompress_RemoveTrivialKeys : public UAnimCompress
{
    float MaxPosDiff;                                                                 // 0x0040 (size: 0x4)
    float MaxAngleDiff;                                                               // 0x0044 (size: 0x4)
    float MaxScaleDiff;                                                               // 0x0048 (size: 0x4)

}; // Size: 0x50

class UAnimCurveCompressionCodec : public UObject
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_CompressedRichCurve : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_UniformIndexable : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_UniformlySampled : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionSettings : public UObject
{
    class UAnimCurveCompressionCodec* Codec;                                          // 0x0028 (size: 0x8)

}; // Size: 0x30

class IAnimLayerInterface : public IInterface
{
}; // Size: 0x28

class UAnimMetaData : public UObject
{
}; // Size: 0x28

struct FAlphaBlend
{
    class UCurveFloat* CustomCurve;                                                   // 0x0000 (size: 0x8)
    float BlendTime;                                                                  // 0x0008 (size: 0x4)
    EAlphaBlendOption BlendOption;                                                    // 0x0024 (size: 0x1)

}; // Size: 0x30

struct FAnimSyncMarker
{
    FName MarkerName;                                                                 // 0x0000 (size: 0x8)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FMarkerSyncData
{
    TArray<FAnimSyncMarker> AuthoredSyncMarkers;                                      // 0x0000 (size: 0x10)

}; // Size: 0x20

struct FCompositeSection : public FAnimLinkableElement
{
    FName SectionName;                                                                // 0x0030 (size: 0x8)
    float StartTime;                                                                  // 0x0038 (size: 0x4)
    FName NextSectionName;                                                            // 0x003C (size: 0x8)
    TArray<class UAnimMetaData*> MetaData;                                            // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FSlotAnimationTrack
{
    FName SlotName;                                                                   // 0x0000 (size: 0x8)
    FAnimTrack AnimTrack;                                                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBranchingPoint : public FAnimLinkableElement
{
    FName EventName;                                                                  // 0x0030 (size: 0x8)
    float DisplayTime;                                                                // 0x0038 (size: 0x4)
    float TriggerTimeOffset;                                                          // 0x003C (size: 0x4)

}; // Size: 0x40

struct FBranchingPointMarker
{
    int32 NotifyIndex;                                                                // 0x0000 (size: 0x4)
    float TriggerTime;                                                                // 0x0004 (size: 0x4)
    TEnumAsByte<EAnimNotifyEventType::Type> NotifyEventType;                          // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FTimeStretchCurveMarker
{
    float Time;                                                                       // 0x0000 (size: 0xC)
    float Alpha;                                                                      // 0x000C (size: 0x4)

}; // Size: 0x10

struct FTimeStretchCurve
{
    float SamplingRate;                                                               // 0x0000 (size: 0x4)
    float CurveValueMinPrecision;                                                     // 0x0004 (size: 0x4)
    TArray<FTimeStretchCurveMarker> Markers;                                          // 0x0008 (size: 0x10)
    float Sum_dT_i_by_C_i;                                                            // 0x0018 (size: 0xC)

}; // Size: 0x28

class UAnimMontage : public UAnimCompositeBase
{
    FAlphaBlend BlendIn;                                                              // 0x00A8 (size: 0x30)
    float blendInTime;                                                                // 0x00D8 (size: 0x4)
    FAlphaBlend BlendOut;                                                             // 0x00E0 (size: 0x30)
    float blendOutTime;                                                               // 0x0110 (size: 0x4)
    float BlendOutTriggerTime;                                                        // 0x0114 (size: 0x4)
    FName SyncGroup;                                                                  // 0x0118 (size: 0x8)
    int32 SyncSlotIndex;                                                              // 0x0120 (size: 0x4)
    FMarkerSyncData MarkerData;                                                       // 0x0128 (size: 0x20)
    TArray<FCompositeSection> CompositeSections;                                      // 0x0148 (size: 0x10)
    TArray<FSlotAnimationTrack> SlotAnimTracks;                                       // 0x0158 (size: 0x10)
    TArray<FBranchingPoint> BranchingPoints;                                          // 0x0168 (size: 0x10)
    bool bEnableRootMotionTranslation;                                                // 0x0178 (size: 0x1)
    bool bEnableRootMotionRotation;                                                   // 0x0179 (size: 0x1)
    bool bEnableAutoBlendOut;                                                         // 0x017A (size: 0x1)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x017B (size: 0x1)
    TArray<FBranchingPointMarker> BranchingPointMarkers;                              // 0x0180 (size: 0x10)
    TArray<int32> BranchingPointStateNotifyIndices;                                   // 0x0190 (size: 0x10)
    FTimeStretchCurve TimeStretchCurve;                                               // 0x01A0 (size: 0x28)
    FName TimeStretchCurveName;                                                       // 0x01C8 (size: 0x8)

    float GetDefaultBlendOutTime();
}; // Size: 0x1D0

class UAnimNotify_PauseClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
    class UParticleSystem* PSTemplate;                                                // 0x0038 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0040 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x004C (size: 0xC)
    FVector Scale;                                                                    // 0x0058 (size: 0xC)
    uint8 Attached;                                                                   // 0x0080 (size: 0x1)
    FName SocketName;                                                                 // 0x0084 (size: 0x8)

}; // Size: 0x90

class UAnimNotify_PlaySound : public UAnimNotify
{
    class USoundBase* Sound;                                                          // 0x0038 (size: 0x8)
    float VolumeMultiplier;                                                           // 0x0040 (size: 0x4)
    float PitchMultiplier;                                                            // 0x0044 (size: 0x4)
    uint8 bFollow;                                                                    // 0x0048 (size: 0x1)
    FName AttachName;                                                                 // 0x004C (size: 0x8)

}; // Size: 0x58

class UAnimNotify_ResetClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_ResetDynamics : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_ResumeClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotifyState_DisableRootMotion : public UAnimNotifyState
{
}; // Size: 0x30

class UAnimNotifyState_TimedParticleEffect : public UAnimNotifyState
{
    class UParticleSystem* PSTemplate;                                                // 0x0030 (size: 0x8)
    FName SocketName;                                                                 // 0x0038 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0040 (size: 0xC)
    FRotator RotationOffset;                                                          // 0x004C (size: 0xC)
    bool bDestroyAtEnd;                                                               // 0x0058 (size: 0x1)

}; // Size: 0x60

class UAnimNotifyState_Trail : public UAnimNotifyState
{
    class UParticleSystem* PSTemplate;                                                // 0x0030 (size: 0x8)
    FName FirstSocketName;                                                            // 0x0038 (size: 0x8)
    FName SecondSocketName;                                                           // 0x0040 (size: 0x8)
    TEnumAsByte<ETrailWidthMode> WidthScaleMode;                                      // 0x0048 (size: 0x1)
    FName WidthScaleCurve;                                                            // 0x004C (size: 0x8)
    uint8 bRecycleSpawnedSystems;                                                     // 0x0054 (size: 0x1)

    class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
}; // Size: 0x58

struct FTrackToSkeletonMap
{
    int32 BoneTreeIndex;                                                              // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FStringCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FString Value;                                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FStringCurve : public FIndexedCurve
{
    FString DefaultValue;                                                             // 0x0068 (size: 0x10)
    TArray<FStringCurveKey> Keys;                                                     // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FBakedStringCustomAttribute
{
    FName AttributeName;                                                              // 0x0000 (size: 0x8)
    FStringCurve StringCurve;                                                         // 0x0008 (size: 0x88)

}; // Size: 0x90

struct FBakedIntegerCustomAttribute
{
    FName AttributeName;                                                              // 0x0000 (size: 0x8)
    FIntegralCurve IntCurve;                                                          // 0x0008 (size: 0x80)

}; // Size: 0x88

struct FSimpleCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSimpleCurve : public FRealCurve
{
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x0070 (size: 0x1)
    TArray<FSimpleCurveKey> Keys;                                                     // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FBakedFloatCustomAttribute
{
    FName AttributeName;                                                              // 0x0000 (size: 0x8)
    FSimpleCurve FloatCurve;                                                          // 0x0008 (size: 0x88)

}; // Size: 0x90

struct FBakedCustomAttributePerBoneData
{
    int32 BoneTreeIndex;                                                              // 0x0000 (size: 0x4)
    TArray<FBakedStringCustomAttribute> StringAttributes;                             // 0x0008 (size: 0x10)
    TArray<FBakedIntegerCustomAttribute> IntAttributes;                               // 0x0018 (size: 0x10)
    TArray<FBakedFloatCustomAttribute> FloatAttributes;                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAnimSequence : public UAnimSequenceBase
{
    int32 NumFrames;                                                                  // 0x00A8 (size: 0x4)
    TArray<FTrackToSkeletonMap> TrackToSkeletonMapTable;                              // 0x00B0 (size: 0x10)
    class UAnimBoneCompressionSettings* BoneCompressionSettings;                      // 0x00D0 (size: 0x8)
    class UAnimCurveCompressionSettings* CurveCompressionSettings;                    // 0x00D8 (size: 0x8)
    TEnumAsByte<EAdditiveAnimationType> AdditiveAnimType;                             // 0x0150 (size: 0x1)
    TEnumAsByte<EAdditiveBasePoseType> RefPoseType;                                   // 0x0151 (size: 0x1)
    class UAnimSequence* RefPoseSeq;                                                  // 0x0158 (size: 0x8)
    int32 RefFrameIndex;                                                              // 0x0160 (size: 0x4)
    FName RetargetSource;                                                             // 0x0164 (size: 0x8)
    TArray<FTransform> RetargetSourceAssetReferencePose;                              // 0x0170 (size: 0x10)
    EAnimInterpolationType Interpolation;                                             // 0x0180 (size: 0x1)
    bool bEnableRootMotion;                                                           // 0x0181 (size: 0x1)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x0182 (size: 0x1)
    bool bForceRootLock;                                                              // 0x0183 (size: 0x1)
    bool bUseNormalizedRootMotionScale;                                               // 0x0184 (size: 0x1)
    bool bRootMotionSettingsCopiedFromMontage;                                        // 0x0185 (size: 0x1)
    TArray<FAnimSyncMarker> AuthoredSyncMarkers;                                      // 0x0188 (size: 0x10)
    TArray<FBakedCustomAttributePerBoneData> BakedPerBoneCustomAttributeData;         // 0x01B0 (size: 0x10)

}; // Size: 0x1C0

struct FAnimSetMeshLinkup
{
    TArray<int32> BoneToTrackTable;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

class UAnimSet : public UObject
{
    uint8 bAnimRotationOnly;                                                          // 0x0028 (size: 0x1)
    TArray<FName> TrackBoneNames;                                                     // 0x0030 (size: 0x10)
    TArray<FAnimSetMeshLinkup> LinkupCache;                                           // 0x0040 (size: 0x10)
    TArray<uint8> BoneUseAnimTranslation;                                             // 0x0050 (size: 0x10)
    TArray<uint8> ForceUseMeshTranslation;                                            // 0x0060 (size: 0x10)
    TArray<FName> UseTranslationBoneNames;                                            // 0x0070 (size: 0x10)
    TArray<FName> ForceMeshTranslationBoneNames;                                      // 0x0080 (size: 0x10)
    FName PreviewSkelMeshName;                                                        // 0x0090 (size: 0x8)
    FName BestRatioSkelMeshName;                                                      // 0x0098 (size: 0x8)

}; // Size: 0xF0

class UAnimSingleNodeInstance : public UAnimInstance
{
    class UAnimationAsset* CurrentAsset;                                              // 0x02B8 (size: 0x8)
    FAnimSingleNodeInstancePostEvaluateAnimEvent PostEvaluateAnimEvent;               // 0x02C0 (size: 0x10)
    void PostEvaluateAnimEvent();

    void StopAnim();
    void SetReverse(bool bInReverse);
    void SetPreviewCurveOverride(const FName& PoseName, float Value, bool bRemoveIfZero);
    void SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies);
    void SetPosition(float InPosition, bool bFireNotifies);
    void SetPlayRate(float InPlayRate);
    void SetPlaying(bool bIsPlaying);
    void SetLooping(bool bIsLooping);
    void SetBlendSpaceInput(const FVector& InBlendInput);
    void SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate);
    void PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition);
    float GetLength();
    class UAnimationAsset* GetAnimationAsset();
}; // Size: 0x2D0

class UAnimStateMachineTypes : public UObject
{
}; // Size: 0x28

class UAnimStreamable : public UAnimSequenceBase
{
    int32 NumFrames;                                                                  // 0x00A8 (size: 0x4)
    EAnimInterpolationType Interpolation;                                             // 0x00AC (size: 0x1)
    FName RetargetSource;                                                             // 0x00B0 (size: 0x8)
    class UAnimBoneCompressionSettings* BoneCompressionSettings;                      // 0x00C8 (size: 0x8)
    class UAnimCurveCompressionSettings* CurveCompressionSettings;                    // 0x00D0 (size: 0x8)
    bool bEnableRootMotion;                                                           // 0x00D8 (size: 0x1)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x00D9 (size: 0x1)
    bool bForceRootLock;                                                              // 0x00DA (size: 0x1)
    bool bUseNormalizedRootMotionScale;                                               // 0x00DB (size: 0x1)

}; // Size: 0xE0

class UArrowComponent : public UPrimitiveComponent
{
    FColor ArrowColor;                                                                // 0x0450 (size: 0x4)
    float ArrowSize;                                                                  // 0x0454 (size: 0x4)
    float ArrowLength;                                                                // 0x0458 (size: 0x4)
    float ScreenSize;                                                                 // 0x045C (size: 0x4)
    uint8 bIsScreenSizeScaled;                                                        // 0x0460 (size: 0x1)
    uint8 bTreatAsASprite;                                                            // 0x0460 (size: 0x1)

    void SetArrowColor(FLinearColor NewColor);
}; // Size: 0x470

class UAssetExportTask : public UObject
{
    class UObject* Object;                                                            // 0x0028 (size: 0x8)
    class UExporter* Exporter;                                                        // 0x0030 (size: 0x8)
    FString Filename;                                                                 // 0x0038 (size: 0x10)
    bool bSelected;                                                                   // 0x0048 (size: 0x1)
    bool bReplaceIdentical;                                                           // 0x0049 (size: 0x1)
    bool bPrompt;                                                                     // 0x004A (size: 0x1)
    bool bAutomated;                                                                  // 0x004B (size: 0x1)
    bool bUseFileArchive;                                                             // 0x004C (size: 0x1)
    bool bWriteEmptyFiles;                                                            // 0x004D (size: 0x1)
    TArray<class UObject*> IgnoreObjectList;                                          // 0x0050 (size: 0x10)
    class UObject* Options;                                                           // 0x0060 (size: 0x8)
    TArray<FString> Errors;                                                           // 0x0068 (size: 0x10)

}; // Size: 0x78

class UAssetManager : public UObject
{
    TArray<class UObject*> ObjectReferenceList;                                       // 0x02E0 (size: 0x10)
    bool bIsGlobalAsyncScanEnvironment;                                               // 0x02F0 (size: 0x1)
    bool bShouldGuessTypeAndName;                                                     // 0x02F1 (size: 0x1)
    bool bShouldUseSynchronousLoad;                                                   // 0x02F2 (size: 0x1)
    bool bIsLoadingFromPakFiles;                                                      // 0x02F3 (size: 0x1)
    bool bShouldAcquireMissingChunksOnLoad;                                           // 0x02F4 (size: 0x1)
    bool bOnlyCookProductionAssets;                                                   // 0x02F5 (size: 0x1)
    bool bIsBulkScanning;                                                             // 0x02F6 (size: 0x1)
    bool bIsPrimaryAssetDirectoryCurrent;                                             // 0x02F7 (size: 0x1)
    bool bIsManagementDatabaseCurrent;                                                // 0x02F8 (size: 0x1)
    bool bUpdateManagementDatabaseAfterScan;                                          // 0x02F9 (size: 0x1)
    bool bIncludeOnlyOnDiskAssets;                                                    // 0x02FA (size: 0x1)
    bool bHasCompletedInitialScan;                                                    // 0x02FB (size: 0x1)
    int32 NumberOfSpawnedNotifications;                                               // 0x02FC (size: 0x4)

}; // Size: 0x478

struct FPrimaryAssetRules
{
    int32 Priority;                                                                   // 0x0000 (size: 0x4)
    int32 ChunkId;                                                                    // 0x0004 (size: 0x4)
    bool bApplyRecursively;                                                           // 0x0008 (size: 0x1)
    EPrimaryAssetCookRule CookRule;                                                   // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FPrimaryAssetTypeInfo
{
    FName PrimaryAssetType;                                                           // 0x0000 (size: 0x8)
    TSoftClassPtr<UObject> AssetBaseClass;                                            // 0x0008 (size: 0x28)
    UClass* AssetBaseClassLoaded;                                                     // 0x0030 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0038 (size: 0x1)
    bool bIsEditorOnly;                                                               // 0x0039 (size: 0x1)
    TArray<FDirectoryPath> Directories;                                               // 0x0040 (size: 0x10)
    TArray<FSoftObjectPath> SpecificAssets;                                           // 0x0050 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0060 (size: 0xC)
    TArray<FString> AssetScanPaths;                                                   // 0x0070 (size: 0x10)
    bool bIsDynamicAsset;                                                             // 0x0080 (size: 0x1)
    int32 NumberOfAssets;                                                             // 0x0084 (size: 0x4)

}; // Size: 0x88

struct FPrimaryAssetRulesOverride
{
    FPrimaryAssetId PrimaryAssetId;                                                   // 0x0000 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FPrimaryAssetRulesCustomOverride
{
    FPrimaryAssetType PrimaryAssetType;                                               // 0x0000 (size: 0x8)
    FDirectoryPath FilterDirectory;                                                   // 0x0008 (size: 0x10)
    FString FilterString;                                                             // 0x0018 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0028 (size: 0xC)

}; // Size: 0x38

struct FAssetManagerRedirect
{
    FString Old;                                                                      // 0x0000 (size: 0x10)
    FString New;                                                                      // 0x0010 (size: 0x10)

}; // Size: 0x20

class UAssetManagerSettings : public UDeveloperSettings
{
    TArray<FPrimaryAssetTypeInfo> PrimaryAssetTypesToScan;                            // 0x0038 (size: 0x10)
    TArray<FDirectoryPath> DirectoriesToExclude;                                      // 0x0048 (size: 0x10)
    TArray<FPrimaryAssetRulesOverride> PrimaryAssetRules;                             // 0x0058 (size: 0x10)
    TArray<FPrimaryAssetRulesCustomOverride> CustomPrimaryAssetRules;                 // 0x0068 (size: 0x10)
    bool bOnlyCookProductionAssets;                                                   // 0x0078 (size: 0x1)
    bool bShouldManagerDetermineTypeAndName;                                          // 0x0079 (size: 0x1)
    bool bShouldGuessTypeAndNameInEditor;                                             // 0x007A (size: 0x1)
    bool bShouldAcquireMissingChunksOnLoad;                                           // 0x007B (size: 0x1)
    TArray<FAssetManagerRedirect> PrimaryAssetIdRedirects;                            // 0x0080 (size: 0x10)
    TArray<FAssetManagerRedirect> PrimaryAssetTypeRedirects;                          // 0x0090 (size: 0x10)
    TArray<FAssetManagerRedirect> AssetPathRedirects;                                 // 0x00A0 (size: 0x10)
    TSet<FName> MetaDataTagsForAssetRegistry;                                         // 0x00B0 (size: 0x50)

}; // Size: 0x100

struct FAssetMapping
{
    class UAnimationAsset* SourceAsset;                                               // 0x0000 (size: 0x8)
    class UAnimationAsset* TargetAsset;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

class UAssetMappingTable : public UObject
{
    TArray<FAssetMapping> MappedAssets;                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAsyncActionHandleSaveGame : public UBlueprintAsyncActionBase
{
    FAsyncActionHandleSaveGameCompleted Completed;                                    // 0x0030 (size: 0x10)
    void OnAsyncHandleSaveGame(class USaveGame* SaveGame, bool bSuccess);
    class USaveGame* SaveGameObject;                                                  // 0x0060 (size: 0x8)

    class UAsyncActionHandleSaveGame* AsyncSaveGameToSlot(class UObject* WorldContextObject, class USaveGame* SaveGameObject, FString SlotName, const int32 UserIndex);
    class UAsyncActionHandleSaveGame* AsyncLoadGameFromSlot(class UObject* WorldContextObject, FString SlotName, const int32 UserIndex);
}; // Size: 0x68

class UAsyncActionLoadPrimaryAssetBase : public UBlueprintAsyncActionBase
{
}; // Size: 0x78

class UAsyncActionLoadPrimaryAsset : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetCompleted Completed;                                  // 0x0078 (size: 0x10)
    void OnPrimaryAssetLoaded(class UObject* Loaded);

    class UAsyncActionLoadPrimaryAsset* AsyncLoadPrimaryAsset(class UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetClass : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetClassCompleted Completed;                             // 0x0078 (size: 0x10)
    void OnPrimaryAssetClassLoaded(UClass* Loaded);

    class UAsyncActionLoadPrimaryAssetClass* AsyncLoadPrimaryAssetClass(class UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetList : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetListCompleted Completed;                              // 0x0078 (size: 0x10)
    void OnPrimaryAssetListLoaded(const TArray<class UObject*>& Loaded);

    class UAsyncActionLoadPrimaryAssetList* AsyncLoadPrimaryAssetList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetClassList : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetClassListCompleted Completed;                         // 0x0078 (size: 0x10)
    void OnPrimaryAssetClassListLoaded(const TArray<class UClass*>& Loaded);

    class UAsyncActionLoadPrimaryAssetClassList* AsyncLoadPrimaryAssetClassList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionChangePrimaryAssetBundles : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionChangePrimaryAssetBundlesCompleted Completed;                         // 0x0078 (size: 0x10)
    void OnPrimaryAssetBundlesChanged();

    class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForPrimaryAssetList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& AddBundles, const TArray<FName>& RemoveBundles);
    class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForMatchingPrimaryAssets(class UObject* WorldContextObject, const TArray<FName>& NewBundles, const TArray<FName>& OldBundles);
}; // Size: 0x88

class AAtmosphericFog : public AInfo
{
    class UAtmosphericFogComponent* AtmosphericFogComponent;                          // 0x0228 (size: 0x8)

}; // Size: 0x230

struct FAtmospherePrecomputeParameters
{
    float DensityHeight;                                                              // 0x0000 (size: 0x4)
    float DecayHeight;                                                                // 0x0004 (size: 0x4)
    int32 MaxScatteringOrder;                                                         // 0x0008 (size: 0x4)
    int32 TransmittanceTexWidth;                                                      // 0x000C (size: 0x4)
    int32 TransmittanceTexHeight;                                                     // 0x0010 (size: 0x4)
    int32 IrradianceTexWidth;                                                         // 0x0014 (size: 0x4)
    int32 IrradianceTexHeight;                                                        // 0x0018 (size: 0x4)
    int32 InscatterAltitudeSampleNum;                                                 // 0x001C (size: 0x4)
    int32 InscatterMuNum;                                                             // 0x0020 (size: 0x4)
    int32 InscatterMuSNum;                                                            // 0x0024 (size: 0x4)
    int32 InscatterNuNum;                                                             // 0x0028 (size: 0x4)

}; // Size: 0x2C

class UAtmosphericFogComponent : public USceneComponent
{
    float SunMultiplier;                                                              // 0x01F8 (size: 0x4)
    float FogMultiplier;                                                              // 0x01FC (size: 0x4)
    float DensityMultiplier;                                                          // 0x0200 (size: 0x4)
    float DensityOffset;                                                              // 0x0204 (size: 0x4)
    float DistanceScale;                                                              // 0x0208 (size: 0x4)
    float AltitudeScale;                                                              // 0x020C (size: 0x4)
    float DistanceOffset;                                                             // 0x0210 (size: 0x4)
    float GroundOffset;                                                               // 0x0214 (size: 0x4)
    float StartDistance;                                                              // 0x0218 (size: 0x4)
    float SunDiscScale;                                                               // 0x021C (size: 0x4)
    float DefaultBrightness;                                                          // 0x0220 (size: 0x4)
    FColor DefaultLightColor;                                                         // 0x0224 (size: 0x4)
    uint8 bDisableSunDisk;                                                            // 0x0228 (size: 0x1)
    uint8 bAtmosphereAffectsSunIlluminance;                                           // 0x0228 (size: 0x1)
    uint8 bDisableGroundScattering;                                                   // 0x0228 (size: 0x1)
    FAtmospherePrecomputeParameters PrecomputeParams;                                 // 0x022C (size: 0x2C)
    class UTexture2D* TransmittanceTexture;                                           // 0x0258 (size: 0x8)
    class UTexture2D* IrradianceTexture;                                              // 0x0260 (size: 0x8)

    void StartPrecompute();
    void SetSunMultiplier(float NewSunMultiplier);
    void SetStartDistance(float NewStartDistance);
    void SetPrecomputeParams(float DensityHeight, int32 MaxScatteringOrder, int32 InscatterAltitudeSampleNum);
    void SetFogMultiplier(float NewFogMultiplier);
    void SetDistanceScale(float NewDistanceScale);
    void SetDistanceOffset(float NewDistanceOffset);
    void SetDensityOffset(float NewDensityOffset);
    void SetDensityMultiplier(float NewDensityMultiplier);
    void SetDefaultLightColor(FLinearColor NewLightColor);
    void SetDefaultBrightness(float NewBrightness);
    void SetAltitudeScale(float NewAltitudeScale);
    void DisableSunDisk(bool NewSunDisk);
    void DisableGroundScattering(bool NewGroundScattering);
}; // Size: 0x300

class UAudioBus : public UObject
{
    EAudioBusChannels AudioBusChannels;                                               // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FAudioQualitySettings
{
    FText DisplayName;                                                                // 0x0000 (size: 0x18)
    int32 MaxChannels;                                                                // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSoundDebugEntry
{
    FName DebugName;                                                                  // 0x0000 (size: 0x8)
    FSoftObjectPath Sound;                                                            // 0x0008 (size: 0x18)

}; // Size: 0x20

struct FDefaultAudioBusSettings
{
    FSoftObjectPath AudioBus;                                                         // 0x0000 (size: 0x18)

}; // Size: 0x18

class UAudioSettings : public UDeveloperSettings
{
    FSoftObjectPath DefaultSoundClassName;                                            // 0x0038 (size: 0x18)
    FSoftObjectPath DefaultMediaSoundClassName;                                       // 0x0050 (size: 0x18)
    FSoftObjectPath DefaultSoundConcurrencyName;                                      // 0x0068 (size: 0x18)
    FSoftObjectPath DefaultBaseSoundMix;                                              // 0x0080 (size: 0x18)
    FSoftObjectPath VoiPSoundClass;                                                   // 0x0098 (size: 0x18)
    FSoftObjectPath MasterSubmix;                                                     // 0x00B0 (size: 0x18)
    FSoftObjectPath BaseDefaultSubmix;                                                // 0x00C8 (size: 0x18)
    FSoftObjectPath ReverbSubmix;                                                     // 0x00E0 (size: 0x18)
    FSoftObjectPath EQSubmix;                                                         // 0x00F8 (size: 0x18)
    EVoiceSampleRate VoiPSampleRate;                                                  // 0x0110 (size: 0x4)
    float DefaultReverbSendLevel;                                                     // 0x0114 (size: 0x4)
    int32 MaximumConcurrentStreams;                                                   // 0x0118 (size: 0x4)
    float GlobalMinPitchScale;                                                        // 0x011C (size: 0x4)
    float GlobalMaxPitchScale;                                                        // 0x0120 (size: 0x4)
    TArray<FAudioQualitySettings> QualityLevels;                                      // 0x0128 (size: 0x10)
    uint8 bAllowPlayWhenSilent;                                                       // 0x0138 (size: 0x1)
    uint8 bDisableMasterEQ;                                                           // 0x0138 (size: 0x1)
    uint8 bAllowCenterChannel3DPanning;                                               // 0x0138 (size: 0x1)
    uint32 NumStoppingSources;                                                        // 0x013C (size: 0x4)
    EPanningMethod PanningMethod;                                                     // 0x0140 (size: 0x1)
    EMonoChannelUpmixMethod MonoChannelUpmixMethod;                                   // 0x0141 (size: 0x1)
    FString DialogueFilenameFormat;                                                   // 0x0148 (size: 0x10)
    TArray<FSoundDebugEntry> DebugSounds;                                             // 0x0158 (size: 0x10)
    TArray<FDefaultAudioBusSettings> DefaultAudioBuses;                               // 0x0168 (size: 0x10)
    class USoundClass* DefaultSoundClass;                                             // 0x0178 (size: 0x8)
    class USoundClass* DefaultMediaSoundClass;                                        // 0x0180 (size: 0x8)
    class USoundConcurrency* DefaultSoundConcurrency;                                 // 0x0188 (size: 0x8)

}; // Size: 0x198

struct FAudioVolumeSubmixSendSettings
{
    EAudioVolumeLocationState ListenerLocationState;                                  // 0x0000 (size: 0x1)
    EAudioVolumeLocationState SourceLocationState;                                    // 0x0001 (size: 0x1)
    TArray<FSoundSubmixSendInfo> SubmixSends;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAudioVolumeSubmixOverrideSettings
{
    class USoundSubmix* Submix;                                                       // 0x0000 (size: 0x8)
    TArray<class USoundEffectSubmixPreset*> SubmixEffectChain;                        // 0x0008 (size: 0x10)
    float CrossfadeTime;                                                              // 0x0018 (size: 0x4)

}; // Size: 0x20

class AAudioVolume : public AVolume
{
    float Priority;                                                                   // 0x0260 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x0264 (size: 0x1)
    FReverbSettings Settings;                                                         // 0x0268 (size: 0x20)
    FInteriorSettings AmbientZoneSettings;                                            // 0x0288 (size: 0x24)
    TArray<FAudioVolumeSubmixSendSettings> SubmixSendSettings;                        // 0x02B0 (size: 0x10)
    TArray<FAudioVolumeSubmixOverrideSettings> SubmixOverrideSettings;                // 0x02C0 (size: 0x10)

    void SetSubmixSendSettings(const TArray<FAudioVolumeSubmixSendSettings>& NewSubmixSendSettings);
    void SetSubmixOverrideSettings(const TArray<FAudioVolumeSubmixOverrideSettings>& NewSubmixOverrideSettings);
    void SetReverbSettings(const FReverbSettings& NewReverbSettings);
    void SetPriority(float NewPriority);
    void SetInteriorSettings(const FInteriorSettings& NewInteriorSettings);
    void SetEnabled(bool bNewEnabled);
    void OnRep_bEnabled();
}; // Size: 0x2D0

class UAutoDestroySubsystem : public UTickableWorldSubsystem
{
    TArray<class AActor*> ActorsToPoll;                                               // 0x0040 (size: 0x10)

    void OnActorEndPlay(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
}; // Size: 0x50

struct FEditorMapPerformanceTestDefinition
{
    FSoftObjectPath PerformanceTestmap;                                               // 0x0000 (size: 0x18)
    int32 TestTimer;                                                                  // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FFilePath
{
    FString FilePath;                                                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FImportFactorySettingValues
{
    FString SettingName;                                                              // 0x0000 (size: 0x10)
    FString Value;                                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FEditorImportWorkflowDefinition
{
    FFilePath ImportFilePath;                                                         // 0x0000 (size: 0x10)
    TArray<FImportFactorySettingValues> FactorySettings;                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBuildPromotionImportWorkflowSettings
{
    FEditorImportWorkflowDefinition Diffuse;                                          // 0x0000 (size: 0x20)
    FEditorImportWorkflowDefinition Normal;                                           // 0x0020 (size: 0x20)
    FEditorImportWorkflowDefinition StaticMesh;                                       // 0x0040 (size: 0x20)
    FEditorImportWorkflowDefinition ReimportStaticMesh;                               // 0x0060 (size: 0x20)
    FEditorImportWorkflowDefinition BlendShapeMesh;                                   // 0x0080 (size: 0x20)
    FEditorImportWorkflowDefinition MorphMesh;                                        // 0x00A0 (size: 0x20)
    FEditorImportWorkflowDefinition SkeletalMesh;                                     // 0x00C0 (size: 0x20)
    FEditorImportWorkflowDefinition Animation;                                        // 0x00E0 (size: 0x20)
    FEditorImportWorkflowDefinition Sound;                                            // 0x0100 (size: 0x20)
    FEditorImportWorkflowDefinition SurroundSound;                                    // 0x0120 (size: 0x20)
    TArray<FEditorImportWorkflowDefinition> OtherAssetsToImport;                      // 0x0140 (size: 0x10)

}; // Size: 0x150

struct FBuildPromotionOpenAssetSettings
{
    FFilePath BlueprintAsset;                                                         // 0x0000 (size: 0x10)
    FFilePath MaterialAsset;                                                          // 0x0010 (size: 0x10)
    FFilePath ParticleSystemAsset;                                                    // 0x0020 (size: 0x10)
    FFilePath SkeletalMeshAsset;                                                      // 0x0030 (size: 0x10)
    FFilePath StaticMeshAsset;                                                        // 0x0040 (size: 0x10)
    FFilePath TextureAsset;                                                           // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FBuildPromotionNewProjectSettings
{
    FDirectoryPath NewProjectFolderOverride;                                          // 0x0000 (size: 0x10)
    FString NewProjectNameOverride;                                                   // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBuildPromotionTestSettings
{
    FFilePath DefaultStaticMeshAsset;                                                 // 0x0000 (size: 0x10)
    FBuildPromotionImportWorkflowSettings ImportWorkflow;                             // 0x0010 (size: 0x150)
    FBuildPromotionOpenAssetSettings OpenAssets;                                      // 0x0160 (size: 0x60)
    FBuildPromotionNewProjectSettings NewProjectSettings;                             // 0x01C0 (size: 0x20)
    FFilePath SourceControlMaterial;                                                  // 0x01E0 (size: 0x10)

}; // Size: 0x1F0

struct FMaterialEditorPromotionSettings
{
    FFilePath DefaultMaterialAsset;                                                   // 0x0000 (size: 0x10)
    FFilePath DefaultDiffuseTexture;                                                  // 0x0010 (size: 0x10)
    FFilePath DefaultNormalTexture;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FParticleEditorPromotionSettings
{
    FFilePath DefaultParticleAsset;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FBlueprintEditorPromotionSettings
{
    FFilePath FirstMeshPath;                                                          // 0x0000 (size: 0x10)
    FFilePath SecondMeshPath;                                                         // 0x0010 (size: 0x10)
    FFilePath DefaultParticleAsset;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FExternalToolDefinition
{
    FString ToolName;                                                                 // 0x0000 (size: 0x10)
    FFilePath ExecutablePath;                                                         // 0x0010 (size: 0x10)
    FString CommandLineOptions;                                                       // 0x0020 (size: 0x10)
    FDirectoryPath WorkingDirectory;                                                  // 0x0030 (size: 0x10)
    FString ScriptExtension;                                                          // 0x0040 (size: 0x10)
    FDirectoryPath ScriptDirectory;                                                   // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FEditorImportExportTestDefinition
{
    FFilePath ImportFilePath;                                                         // 0x0000 (size: 0x10)
    FString ExportFileExtension;                                                      // 0x0010 (size: 0x10)
    bool bSkipExport;                                                                 // 0x0020 (size: 0x1)
    TArray<FImportFactorySettingValues> FactorySettings;                              // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FLaunchOnTestSettings
{
    FFilePath LaunchOnTestmap;                                                        // 0x0000 (size: 0x10)
    FString DeviceID;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

class UAutomationTestSettings : public UObject
{
    TArray<FString> EngineTestModules;                                                // 0x0028 (size: 0x10)
    TArray<FString> EditorTestModules;                                                // 0x0038 (size: 0x10)
    FSoftObjectPath AutomationTestmap;                                                // 0x0048 (size: 0x18)
    TArray<FEditorMapPerformanceTestDefinition> EditorPerformanceTestMaps;            // 0x0060 (size: 0x10)
    TArray<FSoftObjectPath> AssetsToOpen;                                             // 0x0070 (size: 0x10)
    TArray<FString> MapsToPIETest;                                                    // 0x0080 (size: 0x10)
    FBuildPromotionTestSettings BuildPromotionTest;                                   // 0x0090 (size: 0x1F0)
    FMaterialEditorPromotionSettings MaterialEditorPromotionTest;                     // 0x0280 (size: 0x30)
    FParticleEditorPromotionSettings ParticleEditorPromotionTest;                     // 0x02B0 (size: 0x10)
    FBlueprintEditorPromotionSettings BlueprintEditorPromotionTest;                   // 0x02C0 (size: 0x30)
    TArray<FString> TestLevelFolders;                                                 // 0x02F0 (size: 0x10)
    TArray<FExternalToolDefinition> ExternalTools;                                    // 0x0300 (size: 0x10)
    TArray<FEditorImportExportTestDefinition> ImportExportTestDefinitions;            // 0x0310 (size: 0x10)
    TArray<FLaunchOnTestSettings> LaunchOnSettings;                                   // 0x0320 (size: 0x10)
    FIntPoint DefaultScreenshotResolution;                                            // 0x0330 (size: 0x8)
    float PIETestDuration;                                                            // 0x0338 (size: 0x4)

}; // Size: 0x340

class UAvoidanceManager : public UObject
{
    float DefaultTimeToLive;                                                          // 0x0030 (size: 0x4)
    float LockTimeAfterAvoid;                                                         // 0x0034 (size: 0x4)
    float LockTimeAfterClean;                                                         // 0x0038 (size: 0x4)
    float DeltaTimeToPredict;                                                         // 0x003C (size: 0x4)
    float ArtificialRadiusExpansion;                                                  // 0x0040 (size: 0x4)
    float TestHeightDifference;                                                       // 0x0044 (size: 0x4)
    float HeightCheckMargin;                                                          // 0x0048 (size: 0x4)

    bool RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight);
    int32 GetObjectCount();
    int32 GetNewAvoidanceUID();
    FVector GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp);
}; // Size: 0xE0

struct FBandwidthTestItem
{
    TArray<uint8> Kilobyte;                                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FBandwidthTestGenerator
{
    TArray<FBandwidthTestItem> ReplicatedBuffers;                                     // 0x0000 (size: 0x10)

}; // Size: 0x20

class ABandwidthTestActor : public AActor
{
    FBandwidthTestGenerator BandwidthGenerator;                                       // 0x0228 (size: 0x20)

}; // Size: 0x248

class UBillboardComponent : public UPrimitiveComponent
{
    class UTexture2D* Sprite;                                                         // 0x0450 (size: 0x8)
    uint8 bIsScreenSizeScaled;                                                        // 0x0458 (size: 0x1)
    float ScreenSize;                                                                 // 0x045C (size: 0x4)
    float U;                                                                          // 0x0460 (size: 0x4)
    float UL;                                                                         // 0x0464 (size: 0x4)
    float V;                                                                          // 0x0468 (size: 0x4)
    float VL;                                                                         // 0x046C (size: 0x4)

    void SetUV(int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);
    void SetSpriteAndUV(class UTexture2D* NewSprite, int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);
    void SetSprite(class UTexture2D* NewSprite);
}; // Size: 0x470

class IBlendableInterface : public IInterface
{
}; // Size: 0x28

struct FBoneNode
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    int32 ParentIndex;                                                                // 0x0008 (size: 0x4)
    TEnumAsByte<EBoneTranslationRetargetingMode::Type> TranslationRetargetingMode;    // 0x000C (size: 0x1)

}; // Size: 0x10

struct FVirtualBone
{
    FName SourceBoneName;                                                             // 0x0000 (size: 0x8)
    FName TargetBoneName;                                                             // 0x0008 (size: 0x8)
    FName VirtualBoneName;                                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FSmartNameContainer
{
}; // Size: 0x50

struct FAnimSlotGroup
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    TArray<FName> SlotNames;                                                          // 0x0008 (size: 0x10)

}; // Size: 0x18

class USkeleton : public UObject
{
    TArray<FBoneNode> BoneTree;                                                       // 0x0038 (size: 0x10)
    TArray<FTransform> RefLocalPoses;                                                 // 0x0048 (size: 0x10)
    FGuid VirtualBoneGuid;                                                            // 0x0170 (size: 0x10)
    TArray<FVirtualBone> VirtualBones;                                                // 0x0180 (size: 0x10)
    TArray<class USkeletalMeshSocket*> Sockets;                                       // 0x0190 (size: 0x10)
    FSmartNameContainer SmartNames;                                                   // 0x01F0 (size: 0x50)
    TArray<class UBlendProfile*> BlendProfiles;                                       // 0x0270 (size: 0x10)
    TArray<FAnimSlotGroup> SlotGroups;                                                // 0x0280 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0380 (size: 0x10)

}; // Size: 0x390

struct FBlendProfileBoneEntry
{
    FBoneReference BoneReference;                                                     // 0x0000 (size: 0x10)
    float BlendScale;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x14

class UBlendProfile : public UObject
{
    class USkeleton* OwningSkeleton;                                                  // 0x0030 (size: 0x8)
    TArray<FBlendProfileBoneEntry> ProfileEntries;                                    // 0x0038 (size: 0x10)

}; // Size: 0x48

class ABlockingVolume : public AVolume
{
}; // Size: 0x260

class UBlueprintExtension : public UObject
{
}; // Size: 0x28

class UBlueprintMapLibrary : public UBlueprintFunctionLibrary
{

    void SetMapPropertyByName(class UObject* Object, FName PropertyName, const TMap<int32, int32>& Value);
    void Map_Values(const TMap<int32, int32>& TargetMap, TArray<int32>& Values);
    bool Map_Remove(const TMap<int32, int32>& TargetMap, const int32& Key);
    int32 Map_Length(const TMap<int32, int32>& TargetMap);
    void Map_Keys(const TMap<int32, int32>& TargetMap, TArray<int32>& Keys);
    bool Map_Find(const TMap<int32, int32>& TargetMap, const int32& Key, int32& Value);
    bool Map_Contains(const TMap<int32, int32>& TargetMap, const int32& Key);
    void Map_Clear(const TMap<int32, int32>& TargetMap);
    void Map_Add(const TMap<int32, int32>& TargetMap, const int32& Key, const int32& Value);
}; // Size: 0x28

class UBlueprintPathsLibrary : public UBlueprintFunctionLibrary
{

    FString VideoCaptureDir();
    void ValidatePath(FString InPath, bool& bDidSucceed, FText& OutReason);
    void Split(FString InPath, FString& PathPart, FString& FilenamePart, FString& ExtensionPart);
    FString SourceConfigDir();
    bool ShouldSaveToUserDir();
    FString ShaderWorkingDir();
    void SetProjectFilePath(FString NewGameProjectFilePath);
    FString SetExtension(FString InPath, FString InNewExtension);
    FString ScreenShotDir();
    FString SandboxesDir();
    FString RootDir();
    void RemoveDuplicateSlashes(FString InPath, FString& OutPath);
    FString ProjectUserDir();
    FString ProjectSavedDir();
    FString ProjectPluginsDir();
    FString ProjectPersistentDownloadDir();
    FString ProjectModsDir();
    FString ProjectLogDir();
    FString ProjectIntermediateDir();
    FString ProjectDir();
    FString ProjectContentDir();
    FString ProjectConfigDir();
    FString ProfilingDir();
    void NormalizeFilename(FString InPath, FString& OutPath);
    void NormalizeDirectoryName(FString InPath, FString& OutPath);
    FString MakeValidFileName(FString inString, FString InReplacementChar);
    void MakeStandardFilename(FString InPath, FString& OutPath);
    void MakePlatformFilename(FString InPath, FString& OutPath);
    bool MakePathRelativeTo(FString InPath, FString InRelativeTo, FString& OutPath);
    FString LaunchDir();
    bool IsSamePath(FString PathA, FString PathB);
    bool IsRestrictedPath(FString InPath);
    bool IsRelative(FString InPath);
    bool IsProjectFilePathSet();
    bool IsDrive(FString InPath);
    bool HasProjectPersistentDownloadDir();
    TArray<FString> GetToolTipLocalizationPaths();
    TArray<FString> GetRestrictedFolderNames();
    FString GetRelativePathToRoot();
    TArray<FString> GetPropertyNameLocalizationPaths();
    FString GetProjectFilePath();
    FString GetPath(FString InPath);
    FString GetInvalidFileSystemChars();
    TArray<FString> GetGameLocalizationPaths();
    FString GetExtension(FString InPath, bool bIncludeDot);
    TArray<FString> GetEngineLocalizationPaths();
    TArray<FString> GetEditorLocalizationPaths();
    FString GetCleanFilename(FString InPath);
    FString GetBaseFilename(FString InPath, bool bRemovePath);
    FString GeneratedConfigDir();
    FString GameUserDeveloperDir();
    FString GameSourceDir();
    FString GameDevelopersDir();
    FString GameAgnosticSavedDir();
    bool FileExists(FString InPath);
    FString FeaturePackDir();
    FString EnterprisePluginsDir();
    FString EnterpriseFeaturePackDir();
    FString EnterpriseDir();
    FString EngineVersionAgnosticUserDir();
    FString EngineUserDir();
    FString EngineSourceDir();
    FString EngineSavedDir();
    FString EnginePluginsDir();
    FString EngineIntermediateDir();
    FString EngineDir();
    FString EngineContentDir();
    FString EngineConfigDir();
    bool DirectoryExists(FString InPath);
    FString DiffDir();
    FString CreateTempFilename(FString Path, FString Prefix, FString Extension);
    FString ConvertToSandboxPath(FString InPath, FString InSandboxName);
    FString ConvertRelativePathToFull(FString InPath, FString InBasePath);
    FString ConvertFromSandboxPath(FString InPath, FString InSandboxName);
    FString Combine(const TArray<FString>& InPaths);
    bool CollapseRelativeDirectories(FString InPath, FString& OutPath);
    FString CloudDir();
    FString ChangeExtension(FString InPath, FString InNewExtension);
    FString BugItDir();
    FString AutomationTransientDir();
    FString AutomationLogDir();
    FString AutomationDir();
}; // Size: 0x28

class UBlueprintPlatformLibrary : public UBlueprintFunctionLibrary
{

    int32 ScheduleLocalNotificationFromNow(int32 inSecondsFromNow, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
    void ScheduleLocalNotificationBadgeFromNow(int32 inSecondsFromNow, FString ActivationEvent);
    int32 ScheduleLocalNotificationBadgeAtTime(const FDateTime& FireDateTime, bool LocalTime, FString ActivationEvent);
    int32 ScheduleLocalNotificationAtTime(const FDateTime& FireDateTime, bool LocalTime, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
    void GetLaunchNotification(bool& NotificationLaunchedApp, FString& ActivationEvent, int32& FireDate);
    TEnumAsByte<EScreenOrientation::Type> GetDeviceOrientation();
    void ClearAllLocalNotifications();
    void CancelLocalNotificationById(int32 NotificationId);
    void CancelLocalNotification(FString ActivationEvent);
}; // Size: 0x28

class UBlueprintSetLibrary : public UBlueprintFunctionLibrary
{

    void SetSetPropertyByName(class UObject* Object, FName PropertyName, const TSet<int32>& Value);
    void Set_Union(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    void Set_ToArray(const TSet<int32>& A, TArray<int32>& Result);
    void Set_RemoveItems(const TSet<int32>& TargetSet, const TArray<int32>& Items);
    bool Set_Remove(const TSet<int32>& TargetSet, const int32& Item);
    int32 Set_Length(const TSet<int32>& TargetSet);
    void Set_Intersection(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    void Set_Difference(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    bool Set_Contains(const TSet<int32>& TargetSet, const int32& ItemToFind);
    void Set_Clear(const TSet<int32>& TargetSet);
    void Set_AddItems(const TSet<int32>& TargetSet, const TArray<int32>& NewItems);
    void Set_Add(const TSet<int32>& TargetSet, const int32& NewItem);
}; // Size: 0x28

struct FKSphereElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0xC)
    float Radius;                                                                     // 0x003C (size: 0x4)

}; // Size: 0x40

struct FKBoxElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0xC)
    FRotator Rotation;                                                                // 0x003C (size: 0xC)
    float X;                                                                          // 0x0048 (size: 0x4)
    float Y;                                                                          // 0x004C (size: 0x4)
    float Z;                                                                          // 0x0050 (size: 0x4)

}; // Size: 0x58

struct FKSphylElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0xC)
    FRotator Rotation;                                                                // 0x003C (size: 0xC)
    float Radius;                                                                     // 0x0048 (size: 0x4)
    float Length;                                                                     // 0x004C (size: 0x4)

}; // Size: 0x50

struct FKTaperedCapsuleElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0xC)
    FRotator Rotation;                                                                // 0x003C (size: 0xC)
    float Radius0;                                                                    // 0x0048 (size: 0x4)
    float Radius1;                                                                    // 0x004C (size: 0x4)
    float Length;                                                                     // 0x0050 (size: 0x4)

}; // Size: 0x58

struct FKAggregateGeom
{
    TArray<FKSphereElem> SphereElems;                                                 // 0x0000 (size: 0x10)
    TArray<FKBoxElem> BoxElems;                                                       // 0x0010 (size: 0x10)
    TArray<FKSphylElem> SphylElems;                                                   // 0x0020 (size: 0x10)
    TArray<FKConvexElem> ConvexElems;                                                 // 0x0030 (size: 0x10)
    TArray<FKTaperedCapsuleElem> TaperedCapsuleElems;                                 // 0x0040 (size: 0x10)

}; // Size: 0x58

class UBodySetup : public UBodySetupCore
{
    FKAggregateGeom AggGeom;                                                          // 0x0048 (size: 0x58)
    uint8 bAlwaysFullAnimWeight;                                                      // 0x00A0 (size: 0x1)
    uint8 bConsiderForBounds;                                                         // 0x00A0 (size: 0x1)
    uint8 bMeshCollideAll;                                                            // 0x00A0 (size: 0x1)
    uint8 bDoubleSidedGeometry;                                                       // 0x00A0 (size: 0x1)
    uint8 bGenerateNonMirroredCollision;                                              // 0x00A0 (size: 0x1)
    uint8 bSharedCookedData;                                                          // 0x00A0 (size: 0x1)
    uint8 bGenerateMirroredCollision;                                                 // 0x00A0 (size: 0x1)
    uint8 bSupportUVsAndFaceRemap;                                                    // 0x00A0 (size: 0x1)
    class UPhysicalMaterial* PhysMaterial;                                            // 0x00A8 (size: 0x8)
    FWalkableSlopeOverride WalkableSlopeOverride;                                     // 0x00B0 (size: 0x10)
    FBodyInstance DefaultInstance;                                                    // 0x0128 (size: 0x158)
    FVector BuildScale3D;                                                             // 0x0288 (size: 0xC)

}; // Size: 0x2A0

struct FBranchFilter
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    int32 BlendDepth;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FInputBlendPose
{
    TArray<FBranchFilter> BranchFilters;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

class UBoneMaskFilter : public UObject
{
    TArray<FInputBlendPose> BlendPoses;                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UBookmarkBase : public UObject
{
}; // Size: 0x28

class UBookMark : public UBookmarkBase
{
    FVector Location;                                                                 // 0x0028 (size: 0xC)
    FRotator Rotation;                                                                // 0x0034 (size: 0xC)
    TArray<FString> HiddenLevels;                                                     // 0x0040 (size: 0x10)

}; // Size: 0x50

class UBookMark2D : public UBookmarkBase
{
    float Zoom2D;                                                                     // 0x0028 (size: 0x4)
    FIntPoint Location;                                                               // 0x002C (size: 0x8)

}; // Size: 0x38

class UBoundsCopyComponent : public UActorComponent
{
    TSoftObjectPtr<AActor> BoundsSourceActor;                                         // 0x00B0 (size: 0x28)
    bool bUseCollidingComponentsForSourceBounds;                                      // 0x00D8 (size: 0x1)
    bool bKeepOwnBoundsScale;                                                         // 0x00D9 (size: 0x1)
    bool bUseCollidingComponentsForOwnBounds;                                         // 0x00DA (size: 0x1)
    FTransform PostTransform;                                                         // 0x00E0 (size: 0x30)
    bool bCopyXBounds;                                                                // 0x0110 (size: 0x1)
    bool bCopyYBounds;                                                                // 0x0111 (size: 0x1)
    bool bCopyZBounds;                                                                // 0x0112 (size: 0x1)

}; // Size: 0x120

class AReflectionCapture : public AActor
{
    class UReflectionCaptureComponent* CaptureComponent;                              // 0x0228 (size: 0x8)

}; // Size: 0x230

class ABoxReflectionCapture : public AReflectionCapture
{
}; // Size: 0x230

class UReflectionCaptureComponent : public USceneComponent
{
    class UBillboardComponent* CaptureOffsetComponent;                                // 0x01F8 (size: 0x8)
    EReflectionSourceType ReflectionSourceType;                                       // 0x0200 (size: 0x1)
    EMobileReflectionCompression MobileReflectionCompression;                         // 0x0201 (size: 0x1)
    class UTextureCube* Cubemap;                                                      // 0x0208 (size: 0x8)
    float SourceCubemapAngle;                                                         // 0x0210 (size: 0x4)
    float Brightness;                                                                 // 0x0214 (size: 0x4)
    bool bModifyMaxValueRGBM;                                                         // 0x0218 (size: 0x1)
    float MaxValueRGBM;                                                               // 0x021C (size: 0x4)
    FVector CaptureOffset;                                                            // 0x0220 (size: 0xC)
    FGuid MapBuildDataId;                                                             // 0x022C (size: 0x10)
    class UTextureCube* CachedEncodedHDRCubemap;                                      // 0x0250 (size: 0x8)

}; // Size: 0x270

class UBoxReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float BoxTransitionDistance;                                                      // 0x0270 (size: 0x4)
    class UBoxComponent* PreviewInfluenceBox;                                         // 0x0278 (size: 0x8)
    class UBoxComponent* PreviewCaptureBox;                                           // 0x0280 (size: 0x8)

}; // Size: 0x290

class UBreakpoint : public UObject
{
    uint8 bEnabled;                                                                   // 0x0028 (size: 0x1)
    class UEdGraphNode* Node;                                                         // 0x0030 (size: 0x8)
    uint8 bStepOnce;                                                                  // 0x0038 (size: 0x1)
    uint8 bStepOnce_WasPreviouslyDisabled;                                            // 0x0038 (size: 0x1)
    uint8 bStepOnce_RemoveAfterHit;                                                   // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FBuilderPoly
{
    TArray<int32> VertexIndices;                                                      // 0x0000 (size: 0x10)
    int32 Direction;                                                                  // 0x0010 (size: 0x4)
    FName ItemName;                                                                   // 0x0014 (size: 0x8)
    int32 PolyFlags;                                                                  // 0x001C (size: 0x4)

}; // Size: 0x20

class UBrushBuilder : public UObject
{
    FString BitmapFilename;                                                           // 0x0028 (size: 0x10)
    FString Tooltip;                                                                  // 0x0038 (size: 0x10)
    uint8 NotifyBadParams;                                                            // 0x0048 (size: 0x1)
    TArray<FVector> Vertices;                                                         // 0x0050 (size: 0x10)
    TArray<FBuilderPoly> Polys;                                                       // 0x0060 (size: 0x10)
    FName Layer;                                                                      // 0x0070 (size: 0x8)
    uint8 MergeCoplanars;                                                             // 0x0078 (size: 0x1)

}; // Size: 0x80

class UBrushComponent : public UPrimitiveComponent
{
    class UModel* Brush;                                                              // 0x0450 (size: 0x8)
    class UBodySetup* BrushBodySetup;                                                 // 0x0458 (size: 0x8)

}; // Size: 0x460

class ABrushShape : public ABrush
{
}; // Size: 0x260

class UButtonStyleAsset : public UObject
{
    FButtonStyle ButtonStyle;                                                         // 0x0028 (size: 0x278)

}; // Size: 0x2A0

class UCameraAnim : public UObject
{
    class UInterpGroup* CameraInterpGroup;                                            // 0x0028 (size: 0x8)
    float AnimLength;                                                                 // 0x0030 (size: 0x4)
    FBox BoundingBox;                                                                 // 0x0034 (size: 0x1C)
    uint8 bRelativeToInitialTransform;                                                // 0x0050 (size: 0x1)
    uint8 bRelativeToInitialFOV;                                                      // 0x0050 (size: 0x1)
    float BaseFOV;                                                                    // 0x0054 (size: 0x4)
    FPostProcessSettings BasePostProcessSettings;                                     // 0x0060 (size: 0x560)
    float BasePostProcessBlendWeight;                                                 // 0x05C0 (size: 0x4)

}; // Size: 0x5D0

class UCameraAnimInst : public UObject
{
    class UCameraAnim* CamAnim;                                                       // 0x0028 (size: 0x8)
    class UInterpGroupInst* InterpGroupInst;                                          // 0x0030 (size: 0x8)
    float PlayRate;                                                                   // 0x0050 (size: 0x4)
    class UInterpTrackMove* MoveTrack;                                                // 0x0068 (size: 0x8)
    class UInterpTrackInstMove* MoveInst;                                             // 0x0070 (size: 0x8)
    ECameraShakePlaySpace PlaySpace;                                                  // 0x0078 (size: 0x1)

    void Stop(bool bImmediate);
    void SetScale(float NewDuration);
    void SetDuration(float NewDuration);
}; // Size: 0x110

class ACameraBlockingVolume : public AVolume
{
}; // Size: 0x260

class UCameraModifier : public UObject
{
    uint8 bDebug;                                                                     // 0x0028 (size: 0x1)
    uint8 bExclusive;                                                                 // 0x0028 (size: 0x1)
    uint8 Priority;                                                                   // 0x002C (size: 0x1)
    class APlayerCameraManager* CameraOwner;                                          // 0x0030 (size: 0x8)
    float AlphaInTime;                                                                // 0x0038 (size: 0x4)
    float AlphaOutTime;                                                               // 0x003C (size: 0x4)
    float Alpha;                                                                      // 0x0040 (size: 0x4)

    bool IsDisabled();
    class AActor* GetViewTarget();
    void EnableModifier();
    void DisableModifier(bool bImmediate);
    void BlueprintModifyPostProcess(float DeltaTime, float& PostProcessBlendWeight, FPostProcessSettings& PostProcessSettings);
    void BlueprintModifyCamera(float DeltaTime, FVector ViewLocation, FRotator ViewRotation, float FOV, FVector& NewViewLocation, FRotator& NewViewRotation, float& NewFOV);
}; // Size: 0x48

struct FActiveCameraShakeInfo
{
    class UCameraShakeBase* ShakeInstance;                                            // 0x0000 (size: 0x8)
    TWeakObjectPtr<class UCameraShakeSourceComponent> ShakeSource;                    // 0x0008 (size: 0x8)
    bool bIsCustomInitialized;                                                        // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FPooledCameraShakes
{
    TArray<class UCameraShakeBase*> PooledShakes;                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

class UCameraModifier_CameraShake : public UCameraModifier
{
    TArray<FActiveCameraShakeInfo> ActiveShakes;                                      // 0x0048 (size: 0x10)
    TMap<class TSubclassOf<UCameraShakeBase>, class FPooledCameraShakes> ExpiredPooledShakesMap; // 0x0058 (size: 0x50)
    float SplitScreenShakeScale;                                                      // 0x00A8 (size: 0x4)

}; // Size: 0xB0

class ACameraShakeSourceActor : public AActor
{
    class UCameraShakeSourceComponent* CameraShakeSourceComponent;                    // 0x0228 (size: 0x8)

}; // Size: 0x230

class UCameraShakeSourceComponent : public USceneComponent
{
    ECameraShakeAttenuation Attenuation;                                              // 0x01F8 (size: 0x1)
    float InnerAttenuationRadius;                                                     // 0x01FC (size: 0x4)
    float OuterAttenuationRadius;                                                     // 0x0200 (size: 0x4)
    TSubclassOf<class UCameraShakeBase> CameraShake;                                  // 0x0208 (size: 0x8)
    bool bAutoStart;                                                                  // 0x0210 (size: 0x1)

    void StopAllCameraShakesOfType(TSubclassOf<class UCameraShakeBase> InCameraShake, bool bImmediately);
    void StopAllCameraShakes(bool bImmediately);
    void StartCameraShake(TSubclassOf<class UCameraShakeBase> InCameraShake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void Start();
    float GetAttenuationFactor(const FVector& Location);
}; // Size: 0x220

struct FCanvasUVTri
{
    FVector2D V0_Pos;                                                                 // 0x0000 (size: 0x8)
    FVector2D V0_UV;                                                                  // 0x0008 (size: 0x8)
    FLinearColor V0_Color;                                                            // 0x0010 (size: 0x10)
    FVector2D V1_Pos;                                                                 // 0x0020 (size: 0x8)
    FVector2D V1_UV;                                                                  // 0x0028 (size: 0x8)
    FLinearColor V1_Color;                                                            // 0x0030 (size: 0x10)
    FVector2D V2_Pos;                                                                 // 0x0040 (size: 0x8)
    FVector2D V2_UV;                                                                  // 0x0048 (size: 0x8)
    FLinearColor V2_Color;                                                            // 0x0050 (size: 0x10)

}; // Size: 0x60

class UCanvas : public UObject
{
    float OrgX;                                                                       // 0x0028 (size: 0x4)
    float OrgY;                                                                       // 0x002C (size: 0x4)
    float ClipX;                                                                      // 0x0030 (size: 0x4)
    float ClipY;                                                                      // 0x0034 (size: 0x4)
    FColor DrawColor;                                                                 // 0x0038 (size: 0x4)
    uint8 bCenterX;                                                                   // 0x003C (size: 0x1)
    uint8 bCenterY;                                                                   // 0x003C (size: 0x1)
    uint8 bNoSmooth;                                                                  // 0x003C (size: 0x1)
    int32 SizeX;                                                                      // 0x0040 (size: 0x4)
    int32 SizeY;                                                                      // 0x0044 (size: 0x4)
    FPlane ColorModulate;                                                             // 0x0050 (size: 0x10)
    class UTexture2D* DefaultTexture;                                                 // 0x0060 (size: 0x8)
    class UTexture2D* GradientTexture0;                                               // 0x0068 (size: 0x8)
    class UReporterGraph* ReporterGraph;                                              // 0x0070 (size: 0x8)

    FVector2D K2_TextSize(class UFont* RenderFont, FString RenderText, FVector2D Scale);
    FVector2D K2_StrLen(class UFont* RenderFont, FString RenderText);
    FVector K2_Project(FVector WorldLocation);
    void K2_DrawTriangle(class UTexture* RenderTexture, TArray<FCanvasUVTri> Triangles);
    void K2_DrawTexture(class UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, TEnumAsByte<EBlendMode> BlendMode, float Rotation, FVector2D PivotPoint);
    void K2_DrawText(class UFont* RenderFont, FString RenderText, FVector2D ScreenPosition, FVector2D Scale, FLinearColor RenderColor, float Kerning, FLinearColor ShadowColor, FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, FLinearColor OutlineColor);
    void K2_DrawPolygon(class UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D Radius, int32 NumberOfSides, FLinearColor RenderColor);
    void K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, TArray<FCanvasUVTri> Triangles);
    void K2_DrawMaterial(class UMaterialInterface* RenderMaterial, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, float Rotation, FVector2D PivotPoint);
    void K2_DrawLine(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor);
    void K2_DrawBox(FVector2D ScreenPosition, FVector2D ScreenSize, float Thickness, FLinearColor RenderColor);
    void K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, FVector2D BorderScale, FVector2D BackgroundScale, float Rotation, FVector2D PivotPoint, FVector2D CornerSize);
    void K2_Deproject(FVector2D ScreenPosition, FVector& WorldOrigin, FVector& WorldDirection);
}; // Size: 0x2D0

class UTextureRenderTarget : public UTexture
{
    float TargetGamma;                                                                // 0x0178 (size: 0x4)

}; // Size: 0x180

class UTextureRenderTarget2D : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0180 (size: 0x4)
    int32 SizeY;                                                                      // 0x0184 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x0188 (size: 0x10)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0198 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0199 (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x019A (size: 0x1)
    uint8 bHDR;                                                                       // 0x019A (size: 0x1)
    uint8 bGPUSharedFlag;                                                             // 0x019A (size: 0x1)
    TEnumAsByte<ETextureRenderTargetFormat> RenderTargetFormat;                       // 0x019B (size: 0x1)
    uint8 bAutoGenerateMips;                                                          // 0x019C (size: 0x1)
    TEnumAsByte<TextureFilter> MipsSamplerFilter;                                     // 0x019D (size: 0x1)
    TEnumAsByte<TextureAddress> MipsAddressU;                                         // 0x019E (size: 0x1)
    TEnumAsByte<TextureAddress> MipsAddressV;                                         // 0x019F (size: 0x1)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x01A0 (size: 0x1)

}; // Size: 0x1B0

class UCanvasRenderTarget2D : public UTextureRenderTarget2D
{
    FCanvasRenderTarget2DOnCanvasRenderTargetUpdate OnCanvasRenderTargetUpdate;       // 0x01A8 (size: 0x10)
    void OnCanvasRenderTargetUpdate(class UCanvas* Canvas, int32 Width, int32 Height);
    TWeakObjectPtr<class UWorld> World;                                               // 0x01B8 (size: 0x8)
    bool bShouldClearRenderTargetOnReceiveUpdate;                                     // 0x01C0 (size: 0x1)

    void UpdateResource();
    void ReceiveUpdate(class UCanvas* Canvas, int32 Width, int32 Height);
    void GetSize(int32& Width, int32& Height);
    class UCanvasRenderTarget2D* CreateCanvasRenderTarget2D(class UObject* WorldContextObject, TSubclassOf<class UCanvasRenderTarget2D> CanvasRenderTarget2DClass, int32 Width, int32 Height);
}; // Size: 0x1D0

class UCapsuleComponent : public UShapeComponent
{
    float CapsuleHalfHeight;                                                          // 0x0468 (size: 0x4)
    float CapsuleRadius;                                                              // 0x046C (size: 0x4)

    void SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps);
    void SetCapsuleRadius(float Radius, bool bUpdateOverlaps);
    void SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps);
    void GetUnscaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere);
    void GetUnscaledCapsuleSize(float& OutRadius, float& OutHalfHeight);
    float GetUnscaledCapsuleRadius();
    float GetUnscaledCapsuleHalfHeight_WithoutHemisphere();
    float GetUnscaledCapsuleHalfHeight();
    float GetShapeScale();
    void GetScaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere);
    void GetScaledCapsuleSize(float& OutRadius, float& OutHalfHeight);
    float GetScaledCapsuleRadius();
    float GetScaledCapsuleHalfHeight_WithoutHemisphere();
    float GetScaledCapsuleHalfHeight();
}; // Size: 0x470

class UCheatManagerExtension : public UObject
{
}; // Size: 0x28

class UCheckBoxStyleAsset : public UObject
{
    FCheckBoxStyle CheckBoxStyle;                                                     // 0x0028 (size: 0x580)

}; // Size: 0x5A8

class UChildActorComponent : public USceneComponent
{
    TSubclassOf<class AActor> ChildActorClass;                                        // 0x01F8 (size: 0x8)
    class AActor* ChildActor;                                                         // 0x0200 (size: 0x8)
    class AActor* ChildActorTemplate;                                                 // 0x0208 (size: 0x8)

    void SetChildActorClass(TSubclassOf<class AActor> InClass);
}; // Size: 0x230

class UChildConnection : public UNetConnection
{
    class UNetConnection* Parent;                                                     // 0x1BA8 (size: 0x8)

}; // Size: 0x1BB0

struct FDelegateArray
{
    TArray<FDelegateArrayDelegates> Delegates;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

class UPlatformInterfaceBase : public UObject
{
    TArray<FDelegateArray> AllDelegates;                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class UCloudStorageBase : public UPlatformInterfaceBase
{
    TArray<FString> LocalCloudFiles;                                                  // 0x0038 (size: 0x10)
    uint8 bSuppressDelegateCalls;                                                     // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FCollisionResponseTemplate
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0008 (size: 0x1)
    bool bCanModify;                                                                  // 0x000A (size: 0x1)
    FName ObjectTypeName;                                                             // 0x002C (size: 0x8)
    TArray<FResponseChannel> CustomResponses;                                         // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FCustomChannelSetup
{
    TEnumAsByte<ECollisionChannel> Channel;                                           // 0x0000 (size: 0x1)
    TEnumAsByte<ECollisionResponse> DefaultResponse;                                  // 0x0001 (size: 0x1)
    bool bTraceType;                                                                  // 0x0002 (size: 0x1)
    bool bStaticObject;                                                               // 0x0003 (size: 0x1)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FCustomProfile
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TArray<FResponseChannel> CustomResponses;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FRedirector
{
    FName OldName;                                                                    // 0x0000 (size: 0x8)
    FName NewName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

class UCollisionProfile : public UDeveloperSettings
{
    TArray<FCollisionResponseTemplate> Profiles;                                      // 0x0038 (size: 0x10)
    TArray<FCustomChannelSetup> DefaultChannelResponses;                              // 0x0048 (size: 0x10)
    TArray<FCustomProfile> EditProfiles;                                              // 0x0058 (size: 0x10)
    TArray<FRedirector> ProfileRedirects;                                             // 0x0068 (size: 0x10)
    TArray<FRedirector> CollisionChannelRedirects;                                    // 0x0078 (size: 0x10)

}; // Size: 0x170

struct FBlueprintComponentDelegateBinding
{
    FName ComponentPropertyName;                                                      // 0x0000 (size: 0x8)
    FName DelegatePropertyName;                                                       // 0x0008 (size: 0x8)
    FName FunctionNameToBind;                                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

class UComponentDelegateBinding : public UDynamicBlueprintBinding
{
    TArray<FBlueprintComponentDelegateBinding> ComponentDelegateBindings;             // 0x0028 (size: 0x10)

}; // Size: 0x38

class UActorComponentInstanceDataTransientOuter : public UObject
{
}; // Size: 0x28

class UCurveTable : public UObject
{
}; // Size: 0xA0

class UCompositeCurveTable : public UCurveTable
{
    TArray<class UCurveTable*> ParentTables;                                          // 0x00A0 (size: 0x10)
    TArray<class UCurveTable*> OldParentTables;                                       // 0x00B0 (size: 0x10)

}; // Size: 0xC8

class UDataTable : public UObject
{
    class UScriptStruct* RowStruct;                                                   // 0x0028 (size: 0x8)
    uint8 bStripFromClientBuilds;                                                     // 0x0080 (size: 0x1)
    uint8 bIgnoreExtraFields;                                                         // 0x0080 (size: 0x1)
    uint8 bIgnoreMissingFields;                                                       // 0x0080 (size: 0x1)
    FString ImportKeyField;                                                           // 0x0088 (size: 0x10)

}; // Size: 0xB0

class UCompositeDataTable : public UDataTable
{
    TArray<class UDataTable*> ParentTables;                                           // 0x00B0 (size: 0x10)
    TArray<class UDataTable*> OldParentTables;                                        // 0x00C0 (size: 0x10)

}; // Size: 0xD8

class UScriptViewportClient : public UObject
{
}; // Size: 0x38

struct FDebugDisplayProperty
{
    class UObject* Obj;                                                               // 0x0000 (size: 0x8)
    UClass* WithinClass;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x20

class UGameViewportClient : public UScriptViewportClient
{
    class UConsole* ViewportConsole;                                                  // 0x0040 (size: 0x8)
    TArray<FDebugDisplayProperty> DebugProperties;                                    // 0x0048 (size: 0x10)
    int32 MaxSplitscreenPlayers;                                                      // 0x0068 (size: 0x4)
    class UWorld* World;                                                              // 0x0078 (size: 0x8)
    class UGameInstance* GameInstance;                                                // 0x0080 (size: 0x8)

    void SSSwapControllers();
    void ShowTitleSafeArea();
    void SetConsoleTarget(int32 PlayerIndex);
}; // Size: 0x360

class UConsole : public UObject
{
    class ULocalPlayer* ConsoleTargetPlayer;                                          // 0x0038 (size: 0x8)
    class UTexture2D* DefaultTexture_Black;                                           // 0x0040 (size: 0x8)
    class UTexture2D* DefaultTexture_White;                                           // 0x0048 (size: 0x8)
    TArray<FString> HistoryBuffer;                                                    // 0x0068 (size: 0x10)

}; // Size: 0x130

class UControlChannel : public UChannel
{
}; // Size: 0x80

class UStreamingSettings : public UDeveloperSettings
{
    uint8 AsyncLoadingThreadEnabled;                                                  // 0x0038 (size: 0x1)
    uint8 WarnIfTimeLimitExceeded;                                                    // 0x0038 (size: 0x1)
    float TimeLimitExceededMultiplier;                                                // 0x003C (size: 0x4)
    float TimeLimitExceededMinTime;                                                   // 0x0040 (size: 0x4)
    int32 MinBulkDataSizeForAsyncLoading;                                             // 0x0044 (size: 0x4)
    uint8 UseBackgroundLevelStreaming;                                                // 0x0048 (size: 0x1)
    uint8 AsyncLoadingUseFullTimeLimit;                                               // 0x0048 (size: 0x1)
    float AsyncLoadingTimeLimit;                                                      // 0x004C (size: 0x4)
    float PriorityAsyncLoadingExtraTime;                                              // 0x0050 (size: 0x4)
    float LevelStreamingActorsUpdateTimeLimit;                                        // 0x0054 (size: 0x4)
    float PriorityLevelStreamingActorsUpdateExtraTime;                                // 0x0058 (size: 0x4)
    int32 LevelStreamingComponentsRegistrationGranularity;                            // 0x005C (size: 0x4)
    float LevelStreamingUnregisterComponentsTimeLimit;                                // 0x0060 (size: 0x4)
    int32 LevelStreamingComponentsUnregistrationGranularity;                          // 0x0064 (size: 0x4)
    uint8 FlushStreamingOnExit;                                                       // 0x0068 (size: 0x1)
    uint8 EventDrivenLoaderEnabled;                                                   // 0x0068 (size: 0x1)

}; // Size: 0x70

class UGarbageCollectionSettings : public UDeveloperSettings
{
    float TimeBetweenPurgingPendingKillObjects;                                       // 0x0038 (size: 0x4)
    uint8 FlushStreamingOnGC;                                                         // 0x003C (size: 0x1)
    uint8 AllowParallelGC;                                                            // 0x003C (size: 0x1)
    uint8 IncrementalBeginDestroyEnabled;                                             // 0x003C (size: 0x1)
    uint8 MultithreadedDestructionEnabled;                                            // 0x003C (size: 0x1)
    uint8 CreateGCClusters;                                                           // 0x003C (size: 0x1)
    uint8 AssetClusteringEnabled;                                                     // 0x003C (size: 0x1)
    uint8 ActorClusteringEnabled;                                                     // 0x003C (size: 0x1)
    uint8 BlueprintClusteringEnabled;                                                 // 0x003C (size: 0x1)
    uint8 UseDisregardForGCOnDedicatedServers;                                        // 0x003D (size: 0x1)
    int32 MinGCClusterSize;                                                           // 0x0040 (size: 0x4)
    int32 NumRetriesBeforeForcingGC;                                                  // 0x0044 (size: 0x4)
    int32 MaxObjectsNotConsideredByGC;                                                // 0x0048 (size: 0x4)
    int32 SizeOfPermanentObjectPool;                                                  // 0x004C (size: 0x4)
    int32 MaxObjectsInGame;                                                           // 0x0050 (size: 0x4)
    int32 MaxObjectsInEditor;                                                         // 0x0054 (size: 0x4)

}; // Size: 0x58

struct FCullDistanceSizePair
{
    float Size;                                                                       // 0x0000 (size: 0x4)
    float CullDistance;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

class ACullDistanceVolume : public AVolume
{
    TArray<FCullDistanceSizePair> CullDistances;                                      // 0x0260 (size: 0x10)
    uint8 bEnabled;                                                                   // 0x0270 (size: 0x1)

}; // Size: 0x278

class UCurveBase : public UObject
{

    void GetValueRange(float& MinValue, float& MaxValue);
    void GetTimeRange(float& MinTime, float& MaxTime);
}; // Size: 0x30

class UDEPRECATED_CurveEdPresetCurve : public UObject
{
}; // Size: 0x28

class UCurveFloat : public UCurveBase
{
    FRichCurve FloatCurve;                                                            // 0x0030 (size: 0x80)
    bool bIsEventCurve;                                                               // 0x00B0 (size: 0x1)

    float GetFloatValue(float InTime);
}; // Size: 0xB8

class UCurveLinearColor : public UCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0030 (size: 0x200)
    float AdjustHue;                                                                  // 0x0230 (size: 0x4)
    float AdjustSaturation;                                                           // 0x0234 (size: 0x4)
    float AdjustBrightness;                                                           // 0x0238 (size: 0x4)
    float AdjustBrightnessCurve;                                                      // 0x023C (size: 0x4)
    float AdjustVibrance;                                                             // 0x0240 (size: 0x4)
    float AdjustMinAlpha;                                                             // 0x0244 (size: 0x4)
    float AdjustMaxAlpha;                                                             // 0x0248 (size: 0x4)

    FLinearColor GetUnadjustedLinearColorValue(float InTime);
    FLinearColor GetLinearColorValue(float InTime);
    FLinearColor GetClampedLinearColorValue(float InTime);
}; // Size: 0x250

class UTexture2D : public UTexture
{
    int32 LevelIndex;                                                                 // 0x0178 (size: 0x4)
    int32 FirstResourceMemMip;                                                        // 0x017C (size: 0x4)
    uint8 bTemporarilyDisableStreaming;                                               // 0x0180 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0181 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0182 (size: 0x1)
    FIntPoint ImportedSize;                                                           // 0x0184 (size: 0x8)

    int32 Blueprint_GetSizeY();
    int32 Blueprint_GetSizeX();
}; // Size: 0x1A0

class UCurveLinearColorAtlas : public UTexture2D
{
    uint32 TextureSize;                                                               // 0x01A0 (size: 0x4)
    uint8 bSquareResolution;                                                          // 0x01A4 (size: 0x1)
    uint32 TextureHeight;                                                             // 0x01A8 (size: 0x4)
    TArray<class UCurveLinearColor*> GradientCurves;                                  // 0x01B0 (size: 0x10)

    bool GetCurvePosition(class UCurveLinearColor* InCurve, float& Position);
}; // Size: 0x1C0

struct FNamedCurveValue
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    float Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

class ICurveSourceInterface : public IInterface
{

    float GetCurveValue(FName CurveName);
    void GetCurves(TArray<FNamedCurveValue>& OutValues);
    FName GetBindingName();
}; // Size: 0x28

class UCurveVector : public UCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0030 (size: 0x180)

    FVector GetVectorValue(float InTime);
}; // Size: 0x1B0

class UDamageType : public UObject
{
    uint8 bCausedByWorld;                                                             // 0x0028 (size: 0x1)
    uint8 bScaleMomentumByMass;                                                       // 0x0028 (size: 0x1)
    uint8 bRadialDamageVelChange;                                                     // 0x0028 (size: 0x1)
    float DamageImpulse;                                                              // 0x002C (size: 0x4)
    float DestructibleImpulse;                                                        // 0x0030 (size: 0x4)
    float DestructibleDamageSpreadScale;                                              // 0x0034 (size: 0x4)
    float DamageFalloff;                                                              // 0x0038 (size: 0x4)

}; // Size: 0x40

class UDataDrivenCVarEngineSubsystem : public UEngineSubsystem
{
    FDataDrivenCVarEngineSubsystemOnDataDrivenCVarDelegate OnDataDrivenCVarDelegate;  // 0x0030 (size: 0x10)
    void OnDataDrivenCVarChanged(FString CVarName);

}; // Size: 0x40

struct FDataDrivenConsoleVariable
{
    FDataDrivenCVarType Type;                                                         // 0x0000 (size: 0x1)
    FString Name;                                                                     // 0x0008 (size: 0x10)
    FString Tooltip;                                                                  // 0x0018 (size: 0x10)
    float DefaultValueFloat;                                                          // 0x0028 (size: 0x4)
    int32 DefaultValueInt;                                                            // 0x002C (size: 0x4)
    bool DefaultValueBool;                                                            // 0x0030 (size: 0x1)

}; // Size: 0x50

class UDataDrivenConsoleVariableSettings : public UDeveloperSettings
{
    TArray<FDataDrivenConsoleVariable> CVarsArray;                                    // 0x0050 (size: 0x10)

}; // Size: 0x70

class UDataTableFunctionLibrary : public UBlueprintFunctionLibrary
{

    void GetDataTableRowNames(class UDataTable* Table, TArray<FName>& OutRowNames);
    bool GetDataTableRowFromName(class UDataTable* Table, FName RowName, FTableRowBase& OutRow);
    TArray<FString> GetDataTableColumnAsString(const class UDataTable* DataTable, FName PropertyName);
    void EvaluateCurveTableRow(class UCurveTable* CurveTable, FName RowName, float InXY, TEnumAsByte<EEvaluateCurveTableResult::Type>& OutResult, float& OutXY, FString ContextString);
    bool DoesDataTableRowExist(class UDataTable* Table, FName RowName);
}; // Size: 0x28

class ADebugCameraController : public APlayerController
{
    uint8 bShowSelectedInfo;                                                          // 0x0578 (size: 0x1)
    uint8 bIsFrozenRendering;                                                         // 0x0578 (size: 0x1)
    uint8 bIsOrbitingSelectedActor;                                                   // 0x0578 (size: 0x1)
    uint8 bOrbitPivotUseCenter;                                                       // 0x0578 (size: 0x1)
    uint8 bEnableBufferVisualization;                                                 // 0x0578 (size: 0x1)
    uint8 bEnableBufferVisualizationFullMode;                                         // 0x0578 (size: 0x1)
    uint8 bIsBufferVisualizationInputSetup;                                           // 0x0578 (size: 0x1)
    uint8 bLastDisplayEnabled;                                                        // 0x0578 (size: 0x1)
    class UDrawFrustumComponent* DrawFrustum;                                         // 0x0580 (size: 0x8)
    class AActor* SelectedActor;                                                      // 0x0588 (size: 0x8)
    class UPrimitiveComponent* SelectedComponent;                                     // 0x0590 (size: 0x8)
    FHitResult SelectedHitPoint;                                                      // 0x0598 (size: 0x88)
    class APlayerController* OriginalControllerRef;                                   // 0x0620 (size: 0x8)
    class UPlayer* OriginalPlayer;                                                    // 0x0628 (size: 0x8)
    float SpeedScale;                                                                 // 0x0630 (size: 0x4)
    float InitialMaxSpeed;                                                            // 0x0634 (size: 0x4)
    float InitialAccel;                                                               // 0x0638 (size: 0x4)
    float InitialDecel;                                                               // 0x063C (size: 0x4)

    void ToggleDisplay();
    void ShowDebugSelectedInfo();
    void SetPawnMovementSpeedScale(float NewSpeedScale);
    void ReceiveOnDeactivate(class APlayerController* RestoredPC);
    void ReceiveOnActorSelected(class AActor* NewSelectedActor, const FVector& SelectHitLocation, const FVector& SelectHitNormal, const FHitResult& Hit);
    void ReceiveOnActivate(class APlayerController* OriginalPC);
    class AActor* GetSelectedActor();
}; // Size: 0x678

struct FDebugCameraControllerSettingsViewModeIndex
{
    TEnumAsByte<EViewModeIndex> ViewModeIndex;                                        // 0x0008 (size: 0x1)

}; // Size: 0x10

class UDebugCameraControllerSettings : public UDeveloperSettings
{
    TArray<FDebugCameraControllerSettingsViewModeIndex> CycleViewModes;               // 0x0038 (size: 0x10)

}; // Size: 0x48

class ADebugCameraHUD : public AHUD
{
}; // Size: 0x318

class UDebugDrawService : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class ADecalActor : public AActor
{
    class UDecalComponent* Decal;                                                     // 0x0228 (size: 0x8)

    void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
    class UMaterialInterface* GetDecalMaterial();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
}; // Size: 0x230

class UDecalComponent : public USceneComponent
{
    class UMaterialInterface* DecalMaterial;                                          // 0x01F8 (size: 0x8)
    int32 SortOrder;                                                                  // 0x0200 (size: 0x4)
    float FadeScreenSize;                                                             // 0x0204 (size: 0x4)
    float FadeStartDelay;                                                             // 0x0208 (size: 0x4)
    float FadeDuration;                                                               // 0x020C (size: 0x4)
    float FadeInDuration;                                                             // 0x0210 (size: 0x4)
    float FadeInStartDelay;                                                           // 0x0214 (size: 0x4)
    uint8 bDestroyOwnerAfterFade;                                                     // 0x0218 (size: 0x1)
    FVector DecalSize;                                                                // 0x021C (size: 0xC)

    void SetSortOrder(int32 Value);
    void SetFadeScreenSize(float NewFadeScreenSize);
    void SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade);
    void SetFadeIn(float StartDelay, float Duaration);
    void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
    float GetFadeStartDelay();
    float GetFadeInStartDelay();
    float GetFadeInDuration();
    float GetFadeDuration();
    class UMaterialInterface* GetDecalMaterial();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
}; // Size: 0x240

class APhysicsVolume : public AVolume
{
    float TerminalVelocity;                                                           // 0x0260 (size: 0x4)
    int32 Priority;                                                                   // 0x0264 (size: 0x4)
    float FluidFriction;                                                              // 0x0268 (size: 0x4)
    uint8 bWaterVolume;                                                               // 0x026C (size: 0x1)
    uint8 bPhysicsOnContact;                                                          // 0x026C (size: 0x1)

}; // Size: 0x270

class ADefaultPhysicsVolume : public APhysicsVolume
{
}; // Size: 0x270

class UDemoNetConnection : public UNetConnection
{
}; // Size: 0x1C18

struct FRollbackNetStartupActorInfo
{
    class UObject* Archetype;                                                         // 0x0008 (size: 0x8)
    class ULevel* Level;                                                              // 0x0038 (size: 0x8)
    TArray<class UObject*> ObjReferences;                                             // 0x00A0 (size: 0x10)

}; // Size: 0xB0

struct FMulticastRecordOptions
{
    FString FuncPathName;                                                             // 0x0000 (size: 0x10)
    bool bServerSkip;                                                                 // 0x0010 (size: 0x1)
    bool bClientSkip;                                                                 // 0x0011 (size: 0x1)

}; // Size: 0x18

class UDemoNetDriver : public UNetDriver
{
    TMap<class FString, class FRollbackNetStartupActorInfo> RollbackNetStartupActors; // 0x0858 (size: 0x50)
    float CheckpointSaveMaxMSPerFrame;                                                // 0x0A04 (size: 0x4)
    TArray<FMulticastRecordOptions> MulticastRecordOptions;                           // 0x0A28 (size: 0x10)
    bool bIsLocalReplay;                                                              // 0x0A38 (size: 0x1)
    TArray<class APlayerController*> SpectatorControllers;                            // 0x0A40 (size: 0x10)

}; // Size: 0x12D8

class UPendingNetGame : public UObject
{
    class UNetDriver* NetDriver;                                                      // 0x0030 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x0038 (size: 0x8)

}; // Size: 0xC0

class UDemoPendingNetGame : public UPendingNetGame
{
}; // Size: 0xC0

class IDestructibleInterface : public IInterface
{
}; // Size: 0x28

struct FTextureLODGroup
{
    TEnumAsByte<TextureGroup> Group;                                                  // 0x0000 (size: 0x1)
    int32 LODBias;                                                                    // 0x000C (size: 0x4)
    int32 LODBias_Smaller;                                                            // 0x0010 (size: 0x4)
    int32 LODBias_Smallest;                                                           // 0x0014 (size: 0x4)
    int32 NumStreamedMips;                                                            // 0x001C (size: 0x4)
    TEnumAsByte<TextureMipGenSettings> MipGenSettings;                                // 0x0020 (size: 0x1)
    int32 MinLODSize;                                                                 // 0x0024 (size: 0x4)
    int32 MaxLODSize;                                                                 // 0x0028 (size: 0x4)
    int32 MaxLODSize_Smaller;                                                         // 0x002C (size: 0x4)
    int32 MaxLODSize_Smallest;                                                        // 0x0030 (size: 0x4)
    int32 OptionalLODBias;                                                            // 0x0034 (size: 0x4)
    int32 OptionalMaxLODSize;                                                         // 0x0038 (size: 0x4)
    FName MinMagFilter;                                                               // 0x0040 (size: 0x8)
    FName MipFilter;                                                                  // 0x0048 (size: 0x8)
    ETextureMipLoadOptions MipLoadOptions;                                            // 0x0050 (size: 0x1)
    bool HighPriorityLoad;                                                            // 0x0051 (size: 0x1)
    bool DuplicateNonOptionalMips;                                                    // 0x0052 (size: 0x1)
    float Downscale;                                                                  // 0x0054 (size: 0x4)
    ETextureDownscaleOptions DownscaleOptions;                                        // 0x0058 (size: 0x1)
    int32 VirtualTextureTileCountBias;                                                // 0x005C (size: 0x4)
    int32 VirtualTextureTileSizeBias;                                                 // 0x0060 (size: 0x4)
    TEnumAsByte<ETextureLossyCompressionAmount> LossyCompressionAmount;               // 0x0064 (size: 0x1)

}; // Size: 0x68

class UTextureLODSettings : public UObject
{
    TArray<FTextureLODGroup> TextureLODGroups;                                        // 0x0028 (size: 0x10)

}; // Size: 0x38

class UDeviceProfile : public UTextureLODSettings
{
    FString DeviceType;                                                               // 0x0038 (size: 0x10)
    FString BaseProfileName;                                                          // 0x0048 (size: 0x10)
    class UObject* Parent;                                                            // 0x0058 (size: 0x8)
    TArray<FString> CVars;                                                            // 0x0088 (size: 0x10)

}; // Size: 0xA8

class UDeviceProfileFragment : public UObject
{
}; // Size: 0x38

class UDeviceProfileManager : public UObject
{
    TArray<class UObject*> Profiles;                                                  // 0x0028 (size: 0x10)

}; // Size: 0xC8

class UDialogueSoundWaveProxy : public USoundBase
{
}; // Size: 0x188

class UDialogueVoice : public UObject
{
    TEnumAsByte<EGrammaticalGender::Type> Gender;                                     // 0x0028 (size: 0x1)
    TEnumAsByte<EGrammaticalNumber::Type> Plurality;                                  // 0x0029 (size: 0x1)
    FGuid LocalizationGUID;                                                           // 0x002C (size: 0x10)

}; // Size: 0x40

struct FDialogueContext
{
    class UDialogueVoice* Speaker;                                                    // 0x0000 (size: 0x8)
    TArray<class UDialogueVoice*> Targets;                                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FDialogueContextMapping
{
    FDialogueContext Context;                                                         // 0x0000 (size: 0x18)
    class USoundWave* SoundWave;                                                      // 0x0018 (size: 0x8)
    FString LocalizationKeyFormat;                                                    // 0x0020 (size: 0x10)
    class UDialogueSoundWaveProxy* Proxy;                                             // 0x0030 (size: 0x8)

}; // Size: 0x38

class UDialogueWave : public UObject
{
    uint8 bMature;                                                                    // 0x0028 (size: 0x1)
    uint8 bOverride_SubtitleOverride;                                                 // 0x0028 (size: 0x1)
    FString SpokenText;                                                               // 0x0030 (size: 0x10)
    FString SubtitleOverride;                                                         // 0x0040 (size: 0x10)
    TArray<FDialogueContextMapping> ContextMappings;                                  // 0x0050 (size: 0x10)
    FGuid LocalizationGUID;                                                           // 0x0060 (size: 0x10)

}; // Size: 0x70

class ALight : public AActor
{
    class ULightComponent* LightComponent;                                            // 0x0228 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0230 (size: 0x1)

    void ToggleEnabled();
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightColor(FLinearColor NewLightColor);
    void SetEnabled(bool bSetEnabled);
    void SetCastShadows(bool bNewValue);
    void SetBrightness(float NewBrightness);
    void SetAffectTranslucentLighting(bool bNewValue);
    void OnRep_bEnabled();
    bool IsEnabled();
    FLinearColor GetLightColor();
    float GetBrightness();
}; // Size: 0x238

class ADirectionalLight : public ALight
{
}; // Size: 0x238

struct FLightmassDirectionalLightSettings : public FLightmassLightSettings
{
    float LightSourceAngle;                                                           // 0x000C (size: 0x4)

}; // Size: 0x10

class UDirectionalLightComponent : public ULightComponent
{
    float ShadowCascadeBiasDistribution;                                              // 0x0328 (size: 0x4)
    uint8 bEnableLightShaftOcclusion;                                                 // 0x032C (size: 0x1)
    float OcclusionMaskDarkness;                                                      // 0x0330 (size: 0x4)
    float OcclusionDepthRange;                                                        // 0x0334 (size: 0x4)
    FVector LightShaftOverrideDirection;                                              // 0x0338 (size: 0xC)
    float WholeSceneDynamicShadowRadius;                                              // 0x0344 (size: 0x4)
    float DynamicShadowDistanceMovableLight;                                          // 0x0348 (size: 0x4)
    float DynamicShadowDistanceStationaryLight;                                       // 0x034C (size: 0x4)
    int32 DynamicShadowCascades;                                                      // 0x0350 (size: 0x4)
    float CascadeDistributionExponent;                                                // 0x0354 (size: 0x4)
    float CascadeTransitionFraction;                                                  // 0x0358 (size: 0x4)
    float ShadowDistanceFadeoutFraction;                                              // 0x035C (size: 0x4)
    uint8 bUseInsetShadowsForMovableObjects;                                          // 0x0360 (size: 0x1)
    int32 FarShadowCascadeCount;                                                      // 0x0364 (size: 0x4)
    float FarShadowDistance;                                                          // 0x0368 (size: 0x4)
    float DistanceFieldShadowDistance;                                                // 0x036C (size: 0x4)
    float LightSourceAngle;                                                           // 0x0370 (size: 0x4)
    float LightSourceSoftAngle;                                                       // 0x0374 (size: 0x4)
    float ShadowSourceAngleFactor;                                                    // 0x0378 (size: 0x4)
    float TraceDistance;                                                              // 0x037C (size: 0x4)
    uint8 bUsedAsAtmosphereSunLight;                                                  // 0x0380 (size: 0x1)
    int32 AtmosphereSunLightIndex;                                                    // 0x0384 (size: 0x4)
    FLinearColor AtmosphereSunDiskColorScale;                                         // 0x0388 (size: 0x10)
    uint8 bPerPixelAtmosphereTransmittance;                                           // 0x0398 (size: 0x1)
    uint8 bCastShadowsOnClouds;                                                       // 0x0398 (size: 0x1)
    uint8 bCastShadowsOnAtmosphere;                                                   // 0x0398 (size: 0x1)
    uint8 bCastCloudShadows;                                                          // 0x0398 (size: 0x1)
    float CloudShadowStrength;                                                        // 0x039C (size: 0x4)
    float CloudShadowOnAtmosphereStrength;                                            // 0x03A0 (size: 0x4)
    float CloudShadowOnSurfaceStrength;                                               // 0x03A4 (size: 0x4)
    float CloudShadowDepthBias;                                                       // 0x03A8 (size: 0x4)
    float CloudShadowExtent;                                                          // 0x03AC (size: 0x4)
    float CloudShadowMapResolutionScale;                                              // 0x03B0 (size: 0x4)
    float CloudShadowRaySampleCountScale;                                             // 0x03B4 (size: 0x4)
    FLinearColor CloudScatteredLuminanceScale;                                        // 0x03B8 (size: 0x10)
    FLightmassDirectionalLightSettings LightmassSettings;                             // 0x03C8 (size: 0x10)
    uint8 bCastModulatedShadows;                                                      // 0x03D8 (size: 0x1)
    FColor ModulatedShadowColor;                                                      // 0x03DC (size: 0x4)
    float ShadowAmount;                                                               // 0x03E0 (size: 0x4)

    void SetShadowDistanceFadeoutFraction(float newValue);
    void SetShadowAmount(float newValue);
    void SetOcclusionMaskDarkness(float newValue);
    void SetLightShaftOverrideDirection(FVector newValue);
    void SetEnableLightShaftOcclusion(bool bNewValue);
    void SetDynamicShadowDistanceStationaryLight(float newValue);
    void SetDynamicShadowDistanceMovableLight(float newValue);
    void SetDynamicShadowCascades(int32 newValue);
    void SetCascadeTransitionFraction(float newValue);
    void SetCascadeDistributionExponent(float newValue);
    void SetAtmosphereSunLightIndex(int32 newValue);
    void SetAtmosphereSunLight(bool bNewValue);
}; // Size: 0x3F0

class UDistribution : public UObject
{
}; // Size: 0x30

class UDistributionFloat : public UDistribution
{
    uint8 bCanBeBaked;                                                                // 0x0030 (size: 0x1)
    uint8 bBakedDataSuccesfully;                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

class UDistributionFloatConstant : public UDistributionFloat
{
    float Constant;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

class UDistributionFloatConstantCurve : public UDistributionFloat
{
    FInterpCurveFloat ConstantCurve;                                                  // 0x0038 (size: 0x18)

}; // Size: 0x50

class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
    FName ParameterName;                                                              // 0x0040 (size: 0x8)
    float MinInput;                                                                   // 0x0048 (size: 0x4)
    float MaxInput;                                                                   // 0x004C (size: 0x4)
    float MinOutput;                                                                  // 0x0050 (size: 0x4)
    float MaxOutput;                                                                  // 0x0054 (size: 0x4)
    TEnumAsByte<DistributionParamMode> ParamMode;                                     // 0x0058 (size: 0x1)

}; // Size: 0x60

class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
}; // Size: 0x60

class UDistributionFloatUniform : public UDistributionFloat
{
    float Min;                                                                        // 0x0038 (size: 0x4)
    float Max;                                                                        // 0x003C (size: 0x4)

}; // Size: 0x40

class UDistributionFloatUniformCurve : public UDistributionFloat
{
    FInterpCurveVector2D ConstantCurve;                                               // 0x0038 (size: 0x18)

}; // Size: 0x50

class UDistributionVector : public UDistribution
{
    uint8 bCanBeBaked;                                                                // 0x0030 (size: 0x1)
    uint8 bIsDirty;                                                                   // 0x0030 (size: 0x1)
    uint8 bBakedDataSuccesfully;                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

class UDistributionVectorConstant : public UDistributionVector
{
    FVector Constant;                                                                 // 0x0038 (size: 0xC)
    uint8 bLockAxes;                                                                  // 0x0044 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0048 (size: 0x1)

}; // Size: 0x50

class UDistributionVectorConstantCurve : public UDistributionVector
{
    FInterpCurveVector ConstantCurve;                                                 // 0x0038 (size: 0x18)
    uint8 bLockAxes;                                                                  // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x1)

}; // Size: 0x58

class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
    FName ParameterName;                                                              // 0x0050 (size: 0x8)
    FVector MinInput;                                                                 // 0x0058 (size: 0xC)
    FVector MaxInput;                                                                 // 0x0064 (size: 0xC)
    FVector MinOutput;                                                                // 0x0070 (size: 0xC)
    FVector MaxOutput;                                                                // 0x007C (size: 0xC)
    TEnumAsByte<DistributionParamMode> ParamModes;                                    // 0x0088 (size: 0x3)

}; // Size: 0x90

class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
}; // Size: 0x90

class UDistributionVectorUniform : public UDistributionVector
{
    FVector Max;                                                                      // 0x0038 (size: 0xC)
    FVector Min;                                                                      // 0x0044 (size: 0xC)
    uint8 bLockAxes;                                                                  // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x1)
    TEnumAsByte<EDistributionVectorMirrorFlags> MirrorFlags;                          // 0x0055 (size: 0x3)
    uint8 bUseExtremes;                                                               // 0x0058 (size: 0x1)

}; // Size: 0x60

class UDistributionVectorUniformCurve : public UDistributionVector
{
    FInterpCurveTwoVectors ConstantCurve;                                             // 0x0038 (size: 0x18)
    uint8 bLockAxes1;                                                                 // 0x0050 (size: 0x1)
    uint8 bLockAxes2;                                                                 // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x2)
    TEnumAsByte<EDistributionVectorMirrorFlags> MirrorFlags;                          // 0x0056 (size: 0x3)
    uint8 bUseExtremes;                                                               // 0x005C (size: 0x1)

}; // Size: 0x60

class ADocumentationActor : public AActor
{
}; // Size: 0x230

class UDPICustomScalingRule : public UObject
{
}; // Size: 0x28

class UDrawFrustumComponent : public UPrimitiveComponent
{
    FColor FrustumColor;                                                              // 0x0450 (size: 0x4)
    float FrustumAngle;                                                               // 0x0454 (size: 0x4)
    float FrustumAspectRatio;                                                         // 0x0458 (size: 0x4)
    float FrustumStartDist;                                                           // 0x045C (size: 0x4)
    float FrustumEndDist;                                                             // 0x0460 (size: 0x4)
    class UTexture* Texture;                                                          // 0x0468 (size: 0x8)

}; // Size: 0x470

class UDrawSphereComponent : public USphereComponent
{
}; // Size: 0x470

class UEdGraph : public UObject
{
    TSubclassOf<class UEdGraphSchema> Schema;                                         // 0x0028 (size: 0x8)
    TArray<class UEdGraphNode*> Nodes;                                                // 0x0030 (size: 0x10)
    uint8 bEditable;                                                                  // 0x0040 (size: 0x1)
    uint8 bAllowDeletion;                                                             // 0x0040 (size: 0x1)
    uint8 bAllowRenaming;                                                             // 0x0040 (size: 0x1)

}; // Size: 0x60

class UGraphNodeContextMenuContext : public UObject
{
    class UBlueprint* Blueprint;                                                      // 0x0028 (size: 0x8)
    class UEdGraph* Graph;                                                            // 0x0030 (size: 0x8)
    class UEdGraphNode* Node;                                                         // 0x0038 (size: 0x8)
    bool bIsDebugging;                                                                // 0x0048 (size: 0x1)

}; // Size: 0x50

class UEdGraphNode : public UObject
{
    TArray<class UEdGraphPin_Deprecated*> DeprecatedPins;                             // 0x0038 (size: 0x10)
    int32 NodePosX;                                                                   // 0x0048 (size: 0x4)
    int32 NodePosY;                                                                   // 0x004C (size: 0x4)
    int32 NodeWidth;                                                                  // 0x0050 (size: 0x4)
    int32 NodeHeight;                                                                 // 0x0054 (size: 0x4)
    TEnumAsByte<ENodeAdvancedPins::Type> AdvancedPinDisplay;                          // 0x0058 (size: 0x1)
    ENodeEnabledState EnabledState;                                                   // 0x0059 (size: 0x1)
    uint8 bDisplayAsDisabled;                                                         // 0x005B (size: 0x1)
    uint8 bUserSetEnabledState;                                                       // 0x005B (size: 0x1)
    uint8 bIsNodeEnabled;                                                             // 0x005B (size: 0x1)
    uint8 bHasCompilerMessage;                                                        // 0x005B (size: 0x1)
    FString NodeComment;                                                              // 0x0060 (size: 0x10)
    int32 ErrorType;                                                                  // 0x0070 (size: 0x4)
    FString ErrorMsg;                                                                 // 0x0078 (size: 0x10)
    FGuid NodeGuid;                                                                   // 0x0088 (size: 0x10)

}; // Size: 0x98

class UEdGraphNode_Documentation : public UEdGraphNode
{
    FString Link;                                                                     // 0x0098 (size: 0x10)
    FString Excerpt;                                                                  // 0x00A8 (size: 0x10)

}; // Size: 0xB8

struct FEdGraphTerminalType
{
    FName TerminalCategory;                                                           // 0x0000 (size: 0x8)
    FName TerminalSubCategory;                                                        // 0x0008 (size: 0x8)
    TWeakObjectPtr<class UObject> TerminalSubCategoryObject;                          // 0x0010 (size: 0x8)
    bool bTerminalIsConst;                                                            // 0x0018 (size: 0x1)
    bool bTerminalIsWeakPointer;                                                      // 0x0019 (size: 0x1)
    bool bTerminalIsUObjectWrapper;                                                   // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FEdGraphPinType
{
    FName PinCategory;                                                                // 0x0000 (size: 0x8)
    FName PinSubCategory;                                                             // 0x0008 (size: 0x8)
    TWeakObjectPtr<class UObject> PinSubCategoryObject;                               // 0x0010 (size: 0x8)
    FSimpleMemberReference PinSubCategoryMemberReference;                             // 0x0018 (size: 0x20)
    FEdGraphTerminalType PinValueType;                                                // 0x0038 (size: 0x1C)
    EPinContainerType ContainerType;                                                  // 0x0054 (size: 0x1)
    uint8 bIsArray;                                                                   // 0x0055 (size: 0x1)
    uint8 bIsReference;                                                               // 0x0055 (size: 0x1)
    uint8 bIsConst;                                                                   // 0x0055 (size: 0x1)
    uint8 bIsWeakPointer;                                                             // 0x0055 (size: 0x1)
    uint8 bIsUObjectWrapper;                                                          // 0x0055 (size: 0x1)

}; // Size: 0x58

class UEdGraphPin_Deprecated : public UObject
{
    FString PinName;                                                                  // 0x0028 (size: 0x10)
    FString PinToolTip;                                                               // 0x0038 (size: 0x10)
    TEnumAsByte<EEdGraphPinDirection> Direction;                                      // 0x0048 (size: 0x1)
    FEdGraphPinType PinType;                                                          // 0x0050 (size: 0x58)
    FString DefaultValue;                                                             // 0x00A8 (size: 0x10)
    FString AutogeneratedDefaultValue;                                                // 0x00B8 (size: 0x10)
    class UObject* DefaultObject;                                                     // 0x00C8 (size: 0x8)
    FText DefaultTextValue;                                                           // 0x00D0 (size: 0x18)
    TArray<class UEdGraphPin_Deprecated*> LinkedTo;                                   // 0x00E8 (size: 0x10)
    TArray<class UEdGraphPin_Deprecated*> SubPins;                                    // 0x00F8 (size: 0x10)
    class UEdGraphPin_Deprecated* ParentPin;                                          // 0x0108 (size: 0x8)
    class UEdGraphPin_Deprecated* ReferencePassThroughConnection;                     // 0x0110 (size: 0x8)

}; // Size: 0x118

class UEdGraphSchema : public UObject
{
}; // Size: 0x28

class AEmitter : public AActor
{
    class UParticleSystemComponent* ParticleSystemComponent;                          // 0x0228 (size: 0x8)
    uint8 bDestroyOnSystemFinish;                                                     // 0x0230 (size: 0x1)
    uint8 bPostUpdateTickGroup;                                                       // 0x0230 (size: 0x1)
    uint8 bCurrentlyActive;                                                           // 0x0230 (size: 0x1)
    FEmitterOnParticleSpawn OnParticleSpawn;                                          // 0x0238 (size: 0x10)
    void ParticleSpawnSignature(FName EventName, float EmitterTime, FVector Location, FVector Velocity);
    FEmitterOnParticleBurst OnParticleBurst;                                          // 0x0248 (size: 0x10)
    void ParticleBurstSignature(FName EventName, float EmitterTime, int32 ParticleCount);
    FEmitterOnParticleDeath OnParticleDeath;                                          // 0x0258 (size: 0x10)
    void ParticleDeathSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction);
    FEmitterOnParticleCollide OnParticleCollide;                                      // 0x0268 (size: 0x10)
    void ParticleCollisionSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction, FVector Normal, FName BoneName, class UPhysicalMaterial* PhysMat);

    void ToggleActive();
    void SetVectorParameter(FName ParameterName, FVector Param);
    void SetTemplate(class UParticleSystem* NewTemplate);
    void SetMaterialParameter(FName ParameterName, class UMaterialInterface* Param);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetActorParameter(FName ParameterName, class AActor* Param);
    void OnRep_bCurrentlyActive();
    void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
    bool IsActive();
    void Deactivate();
    void Activate();
}; // Size: 0x278

class AEmitterCameraLensEffectBase : public AEmitter
{
    class UParticleSystem* PS_CameraEffect;                                           // 0x0278 (size: 0x8)
    class UParticleSystem* PS_CameraEffectNonExtremeContent;                          // 0x0280 (size: 0x8)
    class APlayerCameraManager* BaseCamera;                                           // 0x0288 (size: 0x8)
    FTransform RelativeTransform;                                                     // 0x0290 (size: 0x30)
    float BaseFOV;                                                                    // 0x02C0 (size: 0x4)
    uint8 bAllowMultipleInstances;                                                    // 0x02C4 (size: 0x1)
    uint8 bResetWhenRetriggered;                                                      // 0x02C4 (size: 0x1)
    TArray<class TSubclassOf<AEmitterCameraLensEffectBase>> EmittersToTreatAsSame;    // 0x02C8 (size: 0x10)
    float DistFromCamera;                                                             // 0x02D8 (size: 0x4)

}; // Size: 0x2E0

class UViewModeUtils : public UObject
{
}; // Size: 0x28

class UEngineBaseTypes : public UObject
{
}; // Size: 0x28

class UEngineHandlerComponentFactory : public UHandlerComponentFactory
{
}; // Size: 0x28

class ULocalMessage : public UObject
{
}; // Size: 0x28

class UEngineMessage : public ULocalMessage
{
    FString FailedPlaceMessage;                                                       // 0x0028 (size: 0x10)
    FString MaxedOutMessage;                                                          // 0x0038 (size: 0x10)
    FString EnteredMessage;                                                           // 0x0048 (size: 0x10)
    FString LeftMessage;                                                              // 0x0058 (size: 0x10)
    FString GlobalNameChange;                                                         // 0x0068 (size: 0x10)
    FString SpecEnteredMessage;                                                       // 0x0078 (size: 0x10)
    FString NewPlayerMessage;                                                         // 0x0088 (size: 0x10)
    FString NewSpecMessage;                                                           // 0x0098 (size: 0x10)

}; // Size: 0xA8

class UEngineTypes : public UObject
{
}; // Size: 0x28

class AExponentialHeightFog : public AInfo
{
    class UExponentialHeightFogComponent* Component;                                  // 0x0228 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0230 (size: 0x1)

    void OnRep_bEnabled();
}; // Size: 0x238

struct FExponentialHeightFogData
{
    float FogDensity;                                                                 // 0x0000 (size: 0x4)
    float FogHeightFalloff;                                                           // 0x0004 (size: 0x4)
    float FogHeightOffset;                                                            // 0x0008 (size: 0x4)

}; // Size: 0xC

class UExponentialHeightFogComponent : public USceneComponent
{
    float FogDensity;                                                                 // 0x01F8 (size: 0x4)
    float FogHeightFalloff;                                                           // 0x01FC (size: 0x4)
    FExponentialHeightFogData SecondFogData;                                          // 0x0200 (size: 0xC)
    FLinearColor FogInscatteringColor;                                                // 0x020C (size: 0x10)
    class UTextureCube* InscatteringColorCubemap;                                     // 0x0220 (size: 0x8)
    float InscatteringColorCubemapAngle;                                              // 0x0228 (size: 0x4)
    FLinearColor InscatteringTextureTint;                                             // 0x022C (size: 0x10)
    float FullyDirectionalInscatteringColorDistance;                                  // 0x023C (size: 0x4)
    float NonDirectionalInscatteringColorDistance;                                    // 0x0240 (size: 0x4)
    float DirectionalInscatteringExponent;                                            // 0x0244 (size: 0x4)
    float DirectionalInscatteringStartDistance;                                       // 0x0248 (size: 0x4)
    FLinearColor DirectionalInscatteringColor;                                        // 0x024C (size: 0x10)
    float FogMaxOpacity;                                                              // 0x025C (size: 0x4)
    float StartDistance;                                                              // 0x0260 (size: 0x4)
    float FogCutoffDistance;                                                          // 0x0264 (size: 0x4)
    bool bEnableVolumetricFog;                                                        // 0x0268 (size: 0x1)
    float VolumetricFogScatteringDistribution;                                        // 0x026C (size: 0x4)
    FColor VolumetricFogAlbedo;                                                       // 0x0270 (size: 0x4)
    FLinearColor VolumetricFogEmissive;                                               // 0x0274 (size: 0x10)
    float VolumetricFogExtinctionScale;                                               // 0x0284 (size: 0x4)
    float VolumetricFogDistance;                                                      // 0x0288 (size: 0x4)
    float VolumetricFogStaticLightingScatteringIntensity;                             // 0x028C (size: 0x4)
    bool bOverrideLightColorsWithFogInscatteringColors;                               // 0x0290 (size: 0x1)

    void SetVolumetricFogScatteringDistribution(float newValue);
    void SetVolumetricFogExtinctionScale(float newValue);
    void SetVolumetricFogEmissive(FLinearColor newValue);
    void SetVolumetricFogDistance(float newValue);
    void SetVolumetricFogAlbedo(FColor newValue);
    void SetVolumetricFog(bool bNewValue);
    void SetStartDistance(float Value);
    void SetNonDirectionalInscatteringColorDistance(float Value);
    void SetInscatteringTextureTint(FLinearColor Value);
    void SetInscatteringColorCubemapAngle(float Value);
    void SetInscatteringColorCubemap(class UTextureCube* Value);
    void SetFullyDirectionalInscatteringColorDistance(float Value);
    void SetFogMaxOpacity(float Value);
    void SetFogInscatteringColor(FLinearColor Value);
    void SetFogHeightFalloff(float Value);
    void SetFogDensity(float Value);
    void SetFogCutoffDistance(float Value);
    void SetDirectionalInscatteringStartDistance(float Value);
    void SetDirectionalInscatteringExponent(float Value);
    void SetDirectionalInscatteringColor(FLinearColor Value);
}; // Size: 0x2A0

class UFloatingPawnMovement : public UPawnMovementComponent
{
    float MaxSpeed;                                                                   // 0x0138 (size: 0x4)
    float Acceleration;                                                               // 0x013C (size: 0x4)
    float Deceleration;                                                               // 0x0140 (size: 0x4)
    float TurningBoost;                                                               // 0x0144 (size: 0x4)
    uint8 bPositionCorrected;                                                         // 0x0148 (size: 0x1)

}; // Size: 0x150

struct FFontCharacter
{
    int32 StartU;                                                                     // 0x0000 (size: 0x4)
    int32 StartV;                                                                     // 0x0004 (size: 0x4)
    int32 USize;                                                                      // 0x0008 (size: 0x4)
    int32 VSize;                                                                      // 0x000C (size: 0x4)
    uint8 TextureIndex;                                                               // 0x0010 (size: 0x1)
    int32 VerticalOffset;                                                             // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FFontImportOptionsData
{
    FString FontName;                                                                 // 0x0000 (size: 0x10)
    float Height;                                                                     // 0x0010 (size: 0x4)
    uint8 bEnableAntialiasing;                                                        // 0x0014 (size: 0x1)
    uint8 bEnableBold;                                                                // 0x0014 (size: 0x1)
    uint8 bEnableItalic;                                                              // 0x0014 (size: 0x1)
    uint8 bEnableUnderline;                                                           // 0x0014 (size: 0x1)
    uint8 bAlphaOnly;                                                                 // 0x0014 (size: 0x1)
    TEnumAsByte<EFontImportCharacterSet> CharacterSet;                                // 0x0018 (size: 0x1)
    FString Chars;                                                                    // 0x0020 (size: 0x10)
    FString UnicodeRange;                                                             // 0x0030 (size: 0x10)
    FString CharsFilePath;                                                            // 0x0040 (size: 0x10)
    FString CharsFileWildcard;                                                        // 0x0050 (size: 0x10)
    uint8 bCreatePrintableOnly;                                                       // 0x0060 (size: 0x1)
    uint8 bIncludeASCIIRange;                                                         // 0x0060 (size: 0x1)
    FLinearColor ForegroundColor;                                                     // 0x0064 (size: 0x10)
    uint8 bEnableDropShadow;                                                          // 0x0074 (size: 0x1)
    int32 TexturePageWidth;                                                           // 0x0078 (size: 0x4)
    int32 TexturePageMaxHeight;                                                       // 0x007C (size: 0x4)
    int32 XPadding;                                                                   // 0x0080 (size: 0x4)
    int32 YPadding;                                                                   // 0x0084 (size: 0x4)
    int32 ExtendBoxTop;                                                               // 0x0088 (size: 0x4)
    int32 ExtendBoxBottom;                                                            // 0x008C (size: 0x4)
    int32 ExtendBoxRight;                                                             // 0x0090 (size: 0x4)
    int32 ExtendBoxLeft;                                                              // 0x0094 (size: 0x4)
    uint8 bEnableLegacyMode;                                                          // 0x0098 (size: 0x1)
    int32 Kerning;                                                                    // 0x009C (size: 0x4)
    uint8 bUseDistanceFieldAlpha;                                                     // 0x00A0 (size: 0x1)
    int32 DistanceFieldScaleFactor;                                                   // 0x00A4 (size: 0x4)
    float DistanceFieldScanRadiusScale;                                               // 0x00A8 (size: 0x4)

}; // Size: 0xB0

class UFont : public UObject
{
    EFontCacheType FontCacheType;                                                     // 0x0030 (size: 0x1)
    TArray<FFontCharacter> Characters;                                                // 0x0038 (size: 0x10)
    TArray<class UTexture2D*> Textures;                                               // 0x0048 (size: 0x10)
    int32 IsRemapped;                                                                 // 0x0058 (size: 0x4)
    float EmScale;                                                                    // 0x005C (size: 0x4)
    float Ascent;                                                                     // 0x0060 (size: 0x4)
    float Descent;                                                                    // 0x0064 (size: 0x4)
    float Leading;                                                                    // 0x0068 (size: 0x4)
    int32 Kerning;                                                                    // 0x006C (size: 0x4)
    FFontImportOptionsData ImportOptions;                                             // 0x0070 (size: 0xB0)
    int32 NumCharacters;                                                              // 0x0120 (size: 0x4)
    TArray<int32> MaxCharHeight;                                                      // 0x0128 (size: 0x10)
    float ScalingFactor;                                                              // 0x0138 (size: 0x4)
    int32 LegacyFontSize;                                                             // 0x013C (size: 0x4)
    FName LegacyFontName;                                                             // 0x0140 (size: 0x8)
    FCompositeFont CompositeFont;                                                     // 0x0148 (size: 0x38)

}; // Size: 0x1D0

class UFontFace : public UObject
{
    FString SourceFilename;                                                           // 0x0030 (size: 0x10)
    EFontHinting Hinting;                                                             // 0x0040 (size: 0x1)
    EFontLoadingPolicy LoadingPolicy;                                                 // 0x0041 (size: 0x1)
    EFontLayoutMethod LayoutMethod;                                                   // 0x0042 (size: 0x1)

}; // Size: 0x58

class UFontImportOptions : public UObject
{
    FFontImportOptionsData Data;                                                      // 0x0028 (size: 0xB0)

}; // Size: 0xD8

struct FForceFeedbackAttenuationSettings : public FBaseAttenuationSettings
{
}; // Size: 0xB0

class UForceFeedbackAttenuation : public UObject
{
    FForceFeedbackAttenuationSettings Attenuation;                                    // 0x0028 (size: 0xB0)

}; // Size: 0xD8

class UForceFeedbackComponent : public USceneComponent
{
    class UForceFeedbackEffect* ForceFeedbackEffect;                                  // 0x01F8 (size: 0x8)
    uint8 bAutoDestroy;                                                               // 0x0200 (size: 0x1)
    uint8 bStopWhenOwnerDestroyed;                                                    // 0x0200 (size: 0x1)
    uint8 bLooping;                                                                   // 0x0200 (size: 0x1)
    uint8 bIgnoreTimeDilation;                                                        // 0x0200 (size: 0x1)
    uint8 bOverrideAttenuation;                                                       // 0x0200 (size: 0x1)
    float IntensityMultiplier;                                                        // 0x0204 (size: 0x4)
    class UForceFeedbackAttenuation* AttenuationSettings;                             // 0x0208 (size: 0x8)
    FForceFeedbackAttenuationSettings AttenuationOverrides;                           // 0x0210 (size: 0xB0)
    FForceFeedbackComponentOnForceFeedbackFinished OnForceFeedbackFinished;           // 0x02C0 (size: 0x10)
    void OnForceFeedbackFinished(class UForceFeedbackComponent* ForceFeedbackComponent);

    void Stop();
    void SetIntensityMultiplier(float NewIntensityMultiplier);
    void SetForceFeedbackEffect(class UForceFeedbackEffect* NewForceFeedbackEffect);
    void Play(float StartTime);
    bool BP_GetAttenuationSettingsToApply(FForceFeedbackAttenuationSettings& OutAttenuationSettings);
    void AdjustAttenuation(const FForceFeedbackAttenuationSettings& InAttenuationSettings);
}; // Size: 0x2E0

struct FForceFeedbackChannelDetails
{
    uint8 bAffectsLeftLarge;                                                          // 0x0000 (size: 0x1)
    uint8 bAffectsLeftSmall;                                                          // 0x0000 (size: 0x1)
    uint8 bAffectsRightLarge;                                                         // 0x0000 (size: 0x1)
    uint8 bAffectsRightSmall;                                                         // 0x0000 (size: 0x1)
    FRuntimeFloatCurve Curve;                                                         // 0x0008 (size: 0x88)

}; // Size: 0x90

class UForceFeedbackEffect : public UObject
{
    TArray<FForceFeedbackChannelDetails> ChannelDetails;                              // 0x0028 (size: 0x10)
    float Duration;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

class AGameNetworkManager : public AInfo
{
    float BadPacketLossThreshold;                                                     // 0x0228 (size: 0x4)
    float SeverePacketLossThreshold;                                                  // 0x022C (size: 0x4)
    int32 BadPingThreshold;                                                           // 0x0230 (size: 0x4)
    int32 SeverePingThreshold;                                                        // 0x0234 (size: 0x4)
    int32 AdjustedNetSpeed;                                                           // 0x0238 (size: 0x4)
    float LastNetSpeedUpdateTime;                                                     // 0x023C (size: 0x4)
    int32 TotalNetBandwidth;                                                          // 0x0240 (size: 0x4)
    int32 MinDynamicBandwidth;                                                        // 0x0244 (size: 0x4)
    int32 MaxDynamicBandwidth;                                                        // 0x0248 (size: 0x4)
    uint8 bIsStandbyCheckingEnabled;                                                  // 0x024C (size: 0x1)
    uint8 bHasStandbyCheatTriggered;                                                  // 0x024C (size: 0x1)
    float StandbyRxCheatTime;                                                         // 0x0250 (size: 0x4)
    float StandbyTxCheatTime;                                                         // 0x0254 (size: 0x4)
    float PercentMissingForRxStandby;                                                 // 0x0258 (size: 0x4)
    float PercentMissingForTxStandby;                                                 // 0x025C (size: 0x4)
    float PercentForBadPing;                                                          // 0x0260 (size: 0x4)
    float JoinInProgressStandbyWaitTime;                                              // 0x0264 (size: 0x4)
    float MoveRepSize;                                                                // 0x0268 (size: 0x4)
    float MAXPOSITIONERRORSQUARED;                                                    // 0x026C (size: 0x4)
    float MAXNEARZEROVELOCITYSQUARED;                                                 // 0x0270 (size: 0x4)
    float CLIENTADJUSTUPDATECOST;                                                     // 0x0274 (size: 0x4)
    float MAXCLIENTUPDATEINTERVAL;                                                    // 0x0278 (size: 0x4)
    float MaxClientForcedUpdateDuration;                                              // 0x027C (size: 0x4)
    float ServerForcedUpdateHitchThreshold;                                           // 0x0280 (size: 0x4)
    float ServerForcedUpdateHitchCooldown;                                            // 0x0284 (size: 0x4)
    float MaxMoveDeltaTime;                                                           // 0x0288 (size: 0x4)
    float MaxClientSmoothingDeltaTime;                                                // 0x028C (size: 0x4)
    float ClientNetSendMoveDeltaTime;                                                 // 0x0290 (size: 0x4)
    float ClientNetSendMoveDeltaTimeThrottled;                                        // 0x0294 (size: 0x4)
    float ClientNetSendMoveDeltaTimeStationary;                                       // 0x0298 (size: 0x4)
    int32 ClientNetSendMoveThrottleAtNetSpeed;                                        // 0x029C (size: 0x4)
    int32 ClientNetSendMoveThrottleOverPlayerCount;                                   // 0x02A0 (size: 0x4)
    bool ClientAuthorativePosition;                                                   // 0x02A4 (size: 0x1)
    float ClientErrorUpdateRateLimit;                                                 // 0x02A8 (size: 0x4)
    float ClientNetCamUpdateDeltaTime;                                                // 0x02AC (size: 0x4)
    float ClientNetCamUpdatePositionLimit;                                            // 0x02B0 (size: 0x4)
    bool bMovementTimeDiscrepancyDetection;                                           // 0x02B4 (size: 0x1)
    bool bMovementTimeDiscrepancyResolution;                                          // 0x02B5 (size: 0x1)
    float MovementTimeDiscrepancyMaxTimeMargin;                                       // 0x02B8 (size: 0x4)
    float MovementTimeDiscrepancyMinTimeMargin;                                       // 0x02BC (size: 0x4)
    float MovementTimeDiscrepancyResolutionRate;                                      // 0x02C0 (size: 0x4)
    float MovementTimeDiscrepancyDriftAllowance;                                      // 0x02C4 (size: 0x4)
    bool bMovementTimeDiscrepancyForceCorrectionsDuringResolution;                    // 0x02C8 (size: 0x1)
    bool bUseDistanceBasedRelevancy;                                                  // 0x02C9 (size: 0x1)

}; // Size: 0x2D8

struct FPredictProjectilePathParams
{
    FVector StartLocation;                                                            // 0x0000 (size: 0xC)
    FVector LaunchVelocity;                                                           // 0x000C (size: 0xC)
    bool bTraceWithCollision;                                                         // 0x0018 (size: 0x1)
    float ProjectileRadius;                                                           // 0x001C (size: 0x4)
    float MaxSimTime;                                                                 // 0x0020 (size: 0x4)
    bool bTraceWithChannel;                                                           // 0x0024 (size: 0x1)
    TEnumAsByte<ECollisionChannel> TraceChannel;                                      // 0x0025 (size: 0x1)
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes;                                // 0x0028 (size: 0x10)
    TArray<class AActor*> ActorsToIgnore;                                             // 0x0038 (size: 0x10)
    float SimFrequency;                                                               // 0x0048 (size: 0x4)
    float OverrideGravityZ;                                                           // 0x004C (size: 0x4)
    TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;                                 // 0x0050 (size: 0x1)
    float DrawDebugTime;                                                              // 0x0054 (size: 0x4)
    bool bTraceComplex;                                                               // 0x0058 (size: 0x1)

}; // Size: 0x60

struct FPredictProjectilePathPointData
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FVector Velocity;                                                                 // 0x000C (size: 0xC)
    float Time;                                                                       // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FPredictProjectilePathResult
{
    TArray<FPredictProjectilePathPointData> PathData;                                 // 0x0000 (size: 0x10)
    FPredictProjectilePathPointData LastTraceDestination;                             // 0x0010 (size: 0x1C)
    FHitResult HitResult;                                                             // 0x002C (size: 0x88)

}; // Size: 0xB8

class UGameplayStatics : public UBlueprintFunctionLibrary
{

    void UnRetainAllSoundsInSoundClass(class USoundClass* InSoundClass);
    void UnloadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
    void UnloadStreamLevel(const class UObject* WorldContextObject, FName LevelName, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
    bool SuggestProjectileVelocity_CustomArc(const class UObject* WorldContextObject, FVector& OutLaunchVelocity, FVector StartPos, FVector EndPos, float OverrideGravityZ, float ArcParam);
    class UAudioComponent* SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bPlaySound);
    class UAudioComponent* SpawnSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy, bool bPlaySound);
    class UAudioComponent* SpawnSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy, bool bPlaySound);
    class UObject* SpawnObject(UClass* ObjectClass, class UObject* Outer);
    class UForceFeedbackComponent* SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UForceFeedbackComponent* SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, FVector Location, FRotator Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UParticleSystemComponent* SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, FVector Scale, TEnumAsByte<EAttachLocation::Type> LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate);
    class UParticleSystemComponent* SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, FVector Location, FRotator Rotation, FVector Scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem);
    class UAudioComponent* SpawnDialogueAttached(class UDialogueWave* Dialogue, const FDialogueContext& Context, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UAudioComponent* SpawnDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UAudioComponent* SpawnDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy);
    class UDecalComponent* SpawnDecalAttached(class UMaterialInterface* DecalMaterial, FVector DecalSize, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, float LifeSpan);
    class UDecalComponent* SpawnDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, FVector DecalSize, FVector Location, FRotator Rotation, float LifeSpan);
    void SetWorldOriginLocation(const class UObject* WorldContextObject, FIntVector NewLocation);
    void SetViewportMouseCaptureMode(const class UObject* WorldContextObject, const EMouseCaptureMode MouseCaptureMode);
    void SetSubtitlesEnabled(bool bEnabled);
    void SetSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren);
    void SetSoundClassDistanceScale(const class UObject* WorldContextObject, class USoundClass* SoundClass, float DistanceAttenuationScale, float TimeSec);
    void SetPlayerControllerID(class APlayerController* Player, int32 ControllerId);
    void SetMaxAudioChannelsScaled(const class UObject* WorldContextObject, float MaxChannelCountScale);
    void SetGlobalTimeDilation(const class UObject* WorldContextObject, float TimeDilation);
    void SetGlobalPitchModulation(const class UObject* WorldContextObject, float PitchModulation, float TimeSec);
    void SetGlobalListenerFocusParameters(const class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale);
    bool SetGamePaused(const class UObject* WorldContextObject, bool bPaused);
    void SetForceDisableSplitscreen(const class UObject* WorldContextObject, bool bDisable);
    void SetEnableWorldRendering(const class UObject* WorldContextObject, bool bEnable);
    void SetBaseSoundMix(const class UObject* WorldContextObject, class USoundMix* InSoundMix);
    bool SaveGameToSlot(class USaveGame* SaveGameObject, FString SlotName, const int32 UserIndex);
    void RemovePlayer(class APlayerController* Player, bool bDestroyPawn);
    FVector RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, FVector WorldLocation);
    FVector RebaseLocalOriginOntoZero(class UObject* WorldContextObject, FVector WorldLocation);
    void PushSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
    bool ProjectWorldToScreen(class APlayerController* Player, const FVector& WorldPosition, FVector2D& ScreenPosition, bool bPlayerViewportRelative);
    void PrimeSound(class USoundBase* InSound);
    void PrimeAllSoundsInSoundClass(class USoundClass* InSoundClass);
    void PopSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
    void PlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
    void PlaySoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor);
    void PlaySound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor, bool bIsUISound);
    void PlayDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
    void PlayDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime);
    FString ParseOption(FString Options, FString Key);
    void OpenLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bAbsolute, FString Options);
    void OpenLevel(const class UObject* WorldContextObject, FName LevelName, bool bAbsolute, FString Options);
    FHitResult MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, FVector Location, FVector ImpactPoint, FVector Normal, FVector ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, FName HitBoneName, int32 HitItem, int32 ElementIndex, int32 FaceIndex, FVector TraceStart, FVector TraceEnd);
    void LoadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    void LoadStreamLevel(const class UObject* WorldContextObject, FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    class USaveGame* LoadGameFromSlot(FString SlotName, const int32 UserIndex);
    bool IsSplitscreenForceDisabled(const class UObject* WorldContextObject);
    bool IsGamePaused(const class UObject* WorldContextObject);
    bool HasOption(FString Options, FString InKey);
    bool HasLaunchOption(FString OptionToCheck);
    int32 GrassOverlappingSphereCount(const class UObject* WorldContextObject, const class UStaticMesh* StaticMesh, FVector CenterPosition, float Radius);
    FIntVector GetWorldOriginLocation(const class UObject* WorldContextObject);
    float GetWorldDeltaSeconds(const class UObject* WorldContextObject);
    void GetViewProjectionMatrix(FMinimalViewInfo DesiredView, FMatrix& ViewMatrix, FMatrix& ProjectionMatrix, FMatrix& ViewProjectionMatrix);
    EMouseCaptureMode GetViewportMouseCaptureMode(const class UObject* WorldContextObject);
    float GetUnpausedTimeSeconds(const class UObject* WorldContextObject);
    float GetTimeSeconds(const class UObject* WorldContextObject);
    TEnumAsByte<EPhysicalSurface> GetSurfaceType(const FHitResult& Hit);
    class ULevelStreaming* GetStreamingLevel(const class UObject* WorldContextObject, FName PackageName);
    float GetRealTimeSeconds(const class UObject* WorldContextObject);
    class APawn* GetPlayerPawn(const class UObject* WorldContextObject, int32 PlayerIndex);
    int32 GetPlayerControllerID(class APlayerController* Player);
    class APlayerController* GetPlayerControllerFromID(const class UObject* WorldContextObject, int32 ControllerId);
    class APlayerController* GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ACharacter* GetPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex);
    class APlayerCameraManager* GetPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
    FString GetPlatformName();
    UClass* GetObjectClass(const class UObject* Object);
    int32 GetMaxAudioChannelCount(const class UObject* WorldContextObject);
    void GetKeyValue(FString Pair, FString& Key, FString& Value);
    int32 GetIntOption(FString Options, FString Key, int32 DefaultValue);
    float GetGlobalTimeDilation(const class UObject* WorldContextObject);
    class AGameStateBase* GetGameState(const class UObject* WorldContextObject);
    class AGameModeBase* GetGameMode(const class UObject* WorldContextObject);
    class UGameInstance* GetGameInstance(const class UObject* WorldContextObject);
    bool GetEnableWorldRendering(const class UObject* WorldContextObject);
    class UReverbEffect* GetCurrentReverbEffect(const class UObject* WorldContextObject);
    FString GetCurrentLevelName(const class UObject* WorldContextObject, bool bRemovePrefixString);
    bool GetClosestListenerLocation(const class UObject* WorldContextObject, const FVector& Location, float MaximumRange, const bool bAllowAttenuationOverride, FVector& ListenerPosition);
    float GetAudioTimeSeconds(const class UObject* WorldContextObject);
    void GetAllActorsWithTag(const class UObject* WorldContextObject, FName Tag, TArray<class AActor*>& OutActors);
    void GetAllActorsWithInterface(const class UObject* WorldContextObject, TSubclassOf<class UInterface> Interface, TArray<class AActor*>& OutActors);
    void GetAllActorsOfClassWithTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, FName Tag, TArray<class AActor*>& OutActors);
    void GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>& OutActors);
    class AActor* GetActorOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass);
    void GetActorArrayBounds(const TArray<class AActor*>& Actors, bool bOnlyCollidingComponents, FVector& Center, FVector& BoxExtent);
    FVector GetActorArrayAverageLocation(const TArray<class AActor*>& Actors);
    void GetAccurateRealTime(int32& Seconds, float& PartialSeconds);
    void FlushLevelStreaming(const class UObject* WorldContextObject);
    class AActor* FinishSpawningActor(class AActor* Actor, const FTransform& SpawnTransform);
    class AActor* FindNearestActor(FVector Origin, const TArray<class AActor*>& ActorsToCheck, float& Distance);
    bool FindCollisionUV(const FHitResult& Hit, int32 UVChannel, FVector2D& UV);
    void EnableLiveStreaming(bool Enable);
    bool DoesSaveGameExist(FString SlotName, const int32 UserIndex);
    bool DeprojectScreenToWorld(class APlayerController* Player, const FVector2D& ScreenPosition, FVector& WorldPosition, FVector& WorldDirection);
    bool DeleteGameInSlot(FString SlotName, const int32 UserIndex);
    void DeactivateReverbEffect(const class UObject* WorldContextObject, FName TagName);
    class UAudioComponent* CreateSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);
    class USaveGame* CreateSaveGameObject(TSubclassOf<class USaveGame> SaveGameClass);
    class APlayerController* CreatePlayer(const class UObject* WorldContextObject, int32 ControllerId, bool bSpawnPlayerController);
    void ClearSoundMixModifiers(const class UObject* WorldContextObject);
    void ClearSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime);
    void CancelAsyncLoading();
    void BreakHitResult(const FHitResult& Hit, bool& bBlockingHit, bool& bInitialOverlap, float& Time, float& Distance, FVector& Location, FVector& ImpactPoint, FVector& Normal, FVector& ImpactNormal, class UPhysicalMaterial*& PhysMat, class AActor*& HitActor, class UPrimitiveComponent*& HitComponent, FName& HitBoneName, int32& HitItem, int32& ElementIndex, int32& FaceIndex, FVector& TraceStart, FVector& TraceEnd);
    bool BlueprintSuggestProjectileVelocity(const class UObject* WorldContextObject, FVector& TossVelocity, FVector StartLocation, FVector EndLocation, float LaunchSpeed, float OverrideGravityZ, TEnumAsByte<ESuggestProjVelocityTraceOption::Type> TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug);
    bool Blueprint_PredictProjectilePath_ByTraceChannel(const class UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    bool Blueprint_PredictProjectilePath_ByObjectType(const class UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    bool Blueprint_PredictProjectilePath_Advanced(const class UObject* WorldContextObject, const FPredictProjectilePathParams& PredictParams, FPredictProjectilePathResult& PredictResult);
    class AActor* BeginSpawningActorFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const FTransform& SpawnTransform, bool bNoCollisionFail, class AActor* Owner);
    class AActor* BeginSpawningActorFromBlueprint(const class UObject* WorldContextObject, const class UBlueprint* Blueprint, const FTransform& SpawnTransform, bool bNoCollisionFail);
    class AActor* BeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner);
    bool AreSubtitlesEnabled();
    bool AreAnyListenersWithinRange(const class UObject* WorldContextObject, const FVector& Location, float MaximumRange);
    bool ApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<ECollisionChannel> DamagePreventionChannel);
    bool ApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, TEnumAsByte<ECollisionChannel> DamagePreventionChannel);
    float ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const FVector& HitFromDirection, const FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
    float ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
    void AnnounceAccessibleString(FString AnnouncementString);
    void ActivateReverbEffect(const class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, FName TagName, float Priority, float Volume, float FadeTime);
}; // Size: 0x28

class AGameSession : public AInfo
{
    int32 MaxSpectators;                                                              // 0x0228 (size: 0x4)
    int32 MaxPlayers;                                                                 // 0x022C (size: 0x4)
    int32 MaxPartySize;                                                               // 0x0230 (size: 0x4)
    uint8 MaxSplitscreensPerConnection;                                               // 0x0234 (size: 0x1)
    bool bRequiresPushToTalk;                                                         // 0x0235 (size: 0x1)
    FName SessionName;                                                                // 0x0238 (size: 0x8)

}; // Size: 0x240

class ASpotLight : public ALight
{
    class USpotLightComponent* SpotLightComponent;                                    // 0x0238 (size: 0x8)

    void SetOuterConeAngle(float NewOuterConeAngle);
    void SetInnerConeAngle(float NewInnerConeAngle);
}; // Size: 0x240

class AGeneratedMeshAreaLight : public ASpotLight
{
}; // Size: 0x240

class UHapticFeedbackEffect_Base : public UObject
{
}; // Size: 0x28

class UHapticFeedbackEffect_Buffer : public UHapticFeedbackEffect_Base
{
    TArray<uint8> Amplitudes;                                                         // 0x0028 (size: 0x10)
    int32 SampleRate;                                                                 // 0x0038 (size: 0x4)

}; // Size: 0x68

struct FHapticFeedbackDetails_Curve
{
    FRuntimeFloatCurve Frequency;                                                     // 0x0000 (size: 0x88)
    FRuntimeFloatCurve Amplitude;                                                     // 0x0088 (size: 0x88)

}; // Size: 0x110

class UHapticFeedbackEffect_Curve : public UHapticFeedbackEffect_Base
{
    FHapticFeedbackDetails_Curve HapticDetails;                                       // 0x0028 (size: 0x110)

}; // Size: 0x138

class UHapticFeedbackEffect_SoundWave : public UHapticFeedbackEffect_Base
{
    class USoundWave* SoundWave;                                                      // 0x0028 (size: 0x8)

}; // Size: 0x60

class UHealthSnapshotBlueprintLibrary : public UBlueprintFunctionLibrary
{

    void StopPerformanceSnapshots();
    void StartPerformanceSnapshots();
    void LogPerformanceSnapshot(const FString SnapshotTitle, bool bResetStats);
}; // Size: 0x28

class UHKSettings : public UDeveloperSettings
{
    bool GarbageCollectionOnMapChange;                                                // 0x0038 (size: 0x1)
    bool KeepCommonLevelsOnMapChange;                                                 // 0x0039 (size: 0x1)
    bool AmortizeActorInitialization;                                                 // 0x003A (size: 0x1)
    bool IgnoreHigherFadeOutRequests;                                                 // 0x003B (size: 0x1)
    float StreamingVolumeExitHysteresis;                                              // 0x003C (size: 0x4)

}; // Size: 0x40

class UHLODEngineSubsystem : public UEngineSubsystem
{
}; // Size: 0x30

struct FHLODProxyMesh
{
    TLazyObjectPtr<class ALODActor> LODActor;                                         // 0x0000 (size: 0x1C)
    class UStaticMesh* StaticMesh;                                                    // 0x0020 (size: 0x8)
    FName Key;                                                                        // 0x0028 (size: 0x8)

}; // Size: 0x30

class UHLODProxy : public UObject
{
    TArray<FHLODProxyMesh> ProxyMeshes;                                               // 0x0028 (size: 0x10)
    TMap<class UHLODProxyDesc*, class FHLODProxyMesh> HLODActors;                     // 0x0038 (size: 0x50)

}; // Size: 0x88

class UHLODProxyDesc : public UObject
{
}; // Size: 0x28

struct FImportanceTexture
{
    FIntPoint Size;                                                                   // 0x0000 (size: 0x8)
    int32 NumMips;                                                                    // 0x0008 (size: 0x4)
    TArray<float> MarginalCDF;                                                        // 0x0010 (size: 0x10)
    TArray<float> ConditionalCDF;                                                     // 0x0020 (size: 0x10)
    TArray<FColor> TextureData;                                                       // 0x0030 (size: 0x10)
    TWeakObjectPtr<class UTexture2D> Texture;                                         // 0x0040 (size: 0x8)
    TEnumAsByte<EImportanceWeight::Type> Weighting;                                   // 0x0048 (size: 0x1)

}; // Size: 0x50

class UImportanceSamplingLibrary : public UBlueprintFunctionLibrary
{

    float RandomSobolFloat(int32 Index, int32 Dimension, float Seed);
    FVector RandomSobolCell3D(int32 Index, int32 NumCells, FVector Cell, FVector Seed);
    FVector2D RandomSobolCell2D(int32 Index, int32 NumCells, FVector2D Cell, FVector2D Seed);
    float NextSobolFloat(int32 Index, int32 Dimension, float PreviousValue);
    FVector NextSobolCell3D(int32 Index, int32 NumCells, FVector PreviousValue);
    FVector2D NextSobolCell2D(int32 Index, int32 NumCells, FVector2D PreviousValue);
    FImportanceTexture MakeImportanceTexture(class UTexture2D* Texture, TEnumAsByte<EImportanceWeight::Type> WeightingFunc);
    void ImportanceSample(const FImportanceTexture& Texture, const FVector2D& Rand, int32 Samples, float Intensity, FVector2D& SamplePosition, FLinearColor& SampleColor, float& SampleIntensity, float& SampleSize);
    void BreakImportanceTexture(const FImportanceTexture& ImportanceTexture, class UTexture2D*& Texture, TEnumAsByte<EImportanceWeight::Type>& WeightingFunc);
}; // Size: 0x28

class IImportantToggleSettingInterface : public IInterface
{
}; // Size: 0x28

class UInGameAdManager : public UPlatformInterfaceBase
{
    uint8 bShouldPauseWhileAdOpen;                                                    // 0x0038 (size: 0x1)
    TArray<FInGameAdManagerClickedBannerDelegates> ClickedBannerDelegates;            // 0x0040 (size: 0x10)
    TArray<FInGameAdManagerClosedAdDelegates> ClosedAdDelegates;                      // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FComponentKey
{
    UClass* OwnerClass;                                                               // 0x0000 (size: 0x8)
    FName SCSVariableName;                                                            // 0x0008 (size: 0x8)
    FGuid AssociatedGuid;                                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FComponentOverrideRecord
{
    UClass* ComponentClass;                                                           // 0x0000 (size: 0x8)
    class UActorComponent* ComponentTemplate;                                         // 0x0008 (size: 0x8)
    FComponentKey ComponentKey;                                                       // 0x0010 (size: 0x20)
    FBlueprintCookedComponentInstancingData CookedComponentInstancingData;            // 0x0030 (size: 0x48)

}; // Size: 0x78

class UInheritableComponentHandler : public UObject
{
    TArray<FComponentOverrideRecord> Records;                                         // 0x0028 (size: 0x10)
    TArray<class UActorComponent*> UnnecessaryComponents;                             // 0x0038 (size: 0x10)

}; // Size: 0x48

class UInputDelegateBinding : public UDynamicBlueprintBinding
{
}; // Size: 0x28

struct FBlueprintInputDelegateBinding
{
    uint8 bConsumeInput;                                                              // 0x0000 (size: 0x1)
    uint8 bExecuteWhenPaused;                                                         // 0x0000 (size: 0x1)
    uint8 bOverrideParentBinding;                                                     // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FBlueprintInputActionDelegateBinding : public FBlueprintInputDelegateBinding
{
    FName InputActionName;                                                            // 0x0004 (size: 0x8)
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x000C (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

class UInputActionDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputActionDelegateBinding> InputActionDelegateBindings;         // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FBlueprintInputAxisDelegateBinding : public FBlueprintInputDelegateBinding
{
    FName InputAxisName;                                                              // 0x0004 (size: 0x8)
    FName FunctionNameToBind;                                                         // 0x000C (size: 0x8)

}; // Size: 0x14

class UInputAxisDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputAxisDelegateBinding> InputAxisDelegateBindings;             // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FBlueprintInputAxisKeyDelegateBinding : public FBlueprintInputDelegateBinding
{
    FKey AxisKey;                                                                     // 0x0008 (size: 0x18)
    FName FunctionNameToBind;                                                         // 0x0020 (size: 0x8)

}; // Size: 0x28

class UInputAxisKeyDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputAxisKeyDelegateBinding> InputAxisKeyDelegateBindings;       // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FCachedKeyToActionInfo
{
    class UPlayerInput* PlayerInput;                                                  // 0x0000 (size: 0x8)

}; // Size: 0x70

class UInputComponent : public UActorComponent
{
    TArray<FCachedKeyToActionInfo> CachedKeyToActionInfo;                             // 0x0120 (size: 0x10)

    bool WasControllerKeyJustReleased(FKey Key);
    bool WasControllerKeyJustPressed(FKey Key);
    bool IsControllerKeyDown(FKey Key);
    void GetTouchState(int32 FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed);
    FVector GetControllerVectorKeyState(FKey Key);
    void GetControllerMouseDelta(float& DeltaX, float& DeltaY);
    float GetControllerKeyTimeDown(FKey Key);
    void GetControllerAnalogStickState(TEnumAsByte<EControllerAnalogStick::Type> WhichStick, float& StickX, float& StickY);
    float GetControllerAnalogKeyState(FKey Key);
}; // Size: 0x138

struct FBlueprintInputKeyDelegateBinding : public FBlueprintInputDelegateBinding
{
    FInputChord InputChord;                                                           // 0x0008 (size: 0x20)
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x0028 (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x002C (size: 0x8)

}; // Size: 0x38

class UInputKeyDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputKeyDelegateBinding> InputKeyDelegateBindings;               // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FInputAxisProperties
{
    float DeadZone;                                                                   // 0x0000 (size: 0x4)
    float Sensitivity;                                                                // 0x0004 (size: 0x4)
    float Exponent;                                                                   // 0x0008 (size: 0x4)
    uint8 bInvert;                                                                    // 0x000C (size: 0x1)

}; // Size: 0x10

struct FInputAxisConfigEntry
{
    FName AxisKeyName;                                                                // 0x0000 (size: 0x8)
    FInputAxisProperties AxisProperties;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FInputAxisKeyMapping
{
    FName AxisName;                                                                   // 0x0000 (size: 0x8)
    float Scale;                                                                      // 0x0008 (size: 0x4)
    FKey Key;                                                                         // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FInputActionSpeechMapping
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    FName SpeechKeyword;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

class UInputSettings : public UObject
{
    TArray<FInputAxisConfigEntry> AxisConfig;                                         // 0x0028 (size: 0x10)
    uint8 bAltEnterTogglesFullscreen;                                                 // 0x0038 (size: 0x1)
    uint8 bF11TogglesFullscreen;                                                      // 0x0038 (size: 0x1)
    uint8 bUseMouseForTouch;                                                          // 0x0038 (size: 0x1)
    uint8 bEnableMouseSmoothing;                                                      // 0x0038 (size: 0x1)
    uint8 bEnableFOVScaling;                                                          // 0x0038 (size: 0x1)
    uint8 bCaptureMouseOnLaunch;                                                      // 0x0038 (size: 0x1)
    uint8 bDefaultViewportMouseLock;                                                  // 0x0038 (size: 0x1)
    uint8 bAlwaysShowTouchInterface;                                                  // 0x0038 (size: 0x1)
    uint8 bShowConsoleOnFourFingerTap;                                                // 0x0039 (size: 0x1)
    uint8 bEnableGestureRecognizer;                                                   // 0x0039 (size: 0x1)
    bool bUseAutocorrect;                                                             // 0x003A (size: 0x1)
    TArray<FString> ExcludedAutocorrectOS;                                            // 0x0040 (size: 0x10)
    TArray<FString> ExcludedAutocorrectCultures;                                      // 0x0050 (size: 0x10)
    TArray<FString> ExcludedAutocorrectDeviceModels;                                  // 0x0060 (size: 0x10)
    EMouseCaptureMode DefaultViewportMouseCaptureMode;                                // 0x0070 (size: 0x1)
    EMouseLockMode DefaultViewportMouseLockMode;                                      // 0x0071 (size: 0x1)
    float FOVScale;                                                                   // 0x0074 (size: 0x4)
    float DoubleClickTime;                                                            // 0x0078 (size: 0x4)
    TArray<FInputActionKeyMapping> ActionMappings;                                    // 0x0080 (size: 0x10)
    TArray<FInputAxisKeyMapping> AxisMappings;                                        // 0x0090 (size: 0x10)
    TArray<FInputActionSpeechMapping> SpeechMappings;                                 // 0x00A0 (size: 0x10)
    TSoftClassPtr<UPlayerInput> DefaultPlayerInputClass;                              // 0x00B0 (size: 0x28)
    TSoftClassPtr<UInputComponent> DefaultInputComponentClass;                        // 0x00D8 (size: 0x28)
    FSoftObjectPath DefaultTouchInterface;                                            // 0x0100 (size: 0x18)
    FKey ConsoleKey;                                                                  // 0x0118 (size: 0x18)
    TArray<FKey> ConsoleKeys;                                                         // 0x0130 (size: 0x10)

    void SaveKeyMappings();
    void RemoveAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void RemoveActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    class UInputSettings* GetInputSettings();
    void GetAxisNames(TArray<FName>& AxisNames);
    void GetAxisMappingByName(const FName InAxisName, TArray<FInputAxisKeyMapping>& OutMappings);
    void GetActionNames(TArray<FName>& ActionNames);
    void GetActionMappingByName(const FName InActionName, TArray<FInputActionKeyMapping>& OutMappings);
    void ForceRebuildKeymaps();
    void AddAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void AddActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
}; // Size: 0x140

struct FBlueprintInputTouchDelegateBinding : public FBlueprintInputDelegateBinding
{
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x0004 (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x0008 (size: 0x8)

}; // Size: 0x10

class UInputTouchDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputTouchDelegateBinding> InputTouchDelegateBindings;           // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputVectorAxisDelegateBinding : public UInputAxisKeyDelegateBinding
{
}; // Size: 0x38

class IInterface_ActorSubobject : public IInterface
{
}; // Size: 0x28

class IInterface_AssetUserData : public IInterface
{
}; // Size: 0x28

class IBoneReferenceSkeletonProvider : public IInterface
{
}; // Size: 0x28

class IInterface_CollisionDataProvider : public IInterface
{
}; // Size: 0x28

class IInterface_PostProcessVolume : public IInterface
{
}; // Size: 0x28

class IInterface_PreviewMeshProvider : public IInterface
{
}; // Size: 0x28

struct FCurveEdEntry
{
    class UObject* CurveObject;                                                       // 0x0000 (size: 0x8)
    FColor CurveColor;                                                                // 0x0008 (size: 0x4)
    FString CurveName;                                                                // 0x0010 (size: 0x10)
    int32 bHideCurve;                                                                 // 0x0020 (size: 0x4)
    int32 bColorCurve;                                                                // 0x0024 (size: 0x4)
    int32 bFloatingPointColorCurve;                                                   // 0x0028 (size: 0x4)
    int32 bClamp;                                                                     // 0x002C (size: 0x4)
    float ClampLow;                                                                   // 0x0030 (size: 0x4)
    float ClampHigh;                                                                  // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FCurveEdTab
{
    FString TabName;                                                                  // 0x0000 (size: 0x10)
    TArray<FCurveEdEntry> Curves;                                                     // 0x0010 (size: 0x10)
    float ViewStartInput;                                                             // 0x0020 (size: 0x4)
    float ViewEndInput;                                                               // 0x0024 (size: 0x4)
    float ViewStartOutput;                                                            // 0x0028 (size: 0x4)
    float ViewEndOutput;                                                              // 0x002C (size: 0x4)

}; // Size: 0x30

class UInterpCurveEdSetup : public UObject
{
    TArray<FCurveEdTab> Tabs;                                                         // 0x0028 (size: 0x10)
    int32 ActiveTab;                                                                  // 0x0038 (size: 0x4)

}; // Size: 0x40

class UInterpData : public UObject
{
    float InterpLength;                                                               // 0x0028 (size: 0x4)
    float PathBuildTime;                                                              // 0x002C (size: 0x4)
    TArray<class UInterpGroup*> InterpGroups;                                         // 0x0030 (size: 0x10)
    class UInterpCurveEdSetup* CurveEdSetup;                                          // 0x0040 (size: 0x8)
    float EdSectionStart;                                                             // 0x0048 (size: 0x4)
    float EdSectionEnd;                                                               // 0x004C (size: 0x4)
    uint8 bShouldBakeAndPrune;                                                        // 0x0050 (size: 0x1)
    class UInterpGroupDirector* CachedDirectorGroup;                                  // 0x0058 (size: 0x8)
    TArray<FName> AllEventNames;                                                      // 0x0060 (size: 0x10)

}; // Size: 0x70

class UInterpFilter : public UObject
{
    FString Caption;                                                                  // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInterpFilter_Classes : public UInterpFilter
{
}; // Size: 0x38

class UInterpFilter_Custom : public UInterpFilter
{
}; // Size: 0x38

class UInterpGroup : public UObject
{
    TArray<class UInterpTrack*> InterpTracks;                                         // 0x0030 (size: 0x10)
    FName GroupName;                                                                  // 0x0040 (size: 0x8)
    FColor GroupColor;                                                                // 0x0048 (size: 0x4)
    uint8 bCollapsed;                                                                 // 0x004C (size: 0x1)
    uint8 bVisible;                                                                   // 0x004C (size: 0x1)
    uint8 bIsFolder;                                                                  // 0x004C (size: 0x1)
    uint8 bIsParented;                                                                // 0x004C (size: 0x1)
    uint8 bIsSelected;                                                                // 0x004C (size: 0x1)

}; // Size: 0x50

class UInterpGroupCamera : public UInterpGroup
{
    class UCameraAnim* CameraAnimInst;                                                // 0x0050 (size: 0x8)
    float CompressTolerance;                                                          // 0x0058 (size: 0x4)

}; // Size: 0x60

class UInterpGroupDirector : public UInterpGroup
{
}; // Size: 0x50

class UInterpGroupInst : public UObject
{
    class UInterpGroup* Group;                                                        // 0x0028 (size: 0x8)
    class AActor* GroupActor;                                                         // 0x0030 (size: 0x8)
    TArray<class UInterpTrackInst*> TrackInst;                                        // 0x0038 (size: 0x10)

}; // Size: 0x48

class UInterpGroupInstCamera : public UInterpGroupInst
{
}; // Size: 0x48

class UInterpGroupInstDirector : public UInterpGroupInst
{
}; // Size: 0x48

struct FInterpControlPoint
{
    FVector PositionControlPoint;                                                     // 0x0000 (size: 0xC)
    bool bPositionIsRelative;                                                         // 0x000C (size: 0x1)

}; // Size: 0x1C

class UInterpToMovementComponent : public UMovementComponent
{
    float Duration;                                                                   // 0x00F0 (size: 0x4)
    uint8 bPauseOnImpact;                                                             // 0x00F4 (size: 0x1)
    bool bSweep;                                                                      // 0x00F8 (size: 0x1)
    ETeleportType TeleportType;                                                       // 0x00F9 (size: 0x1)
    EInterpToBehaviourType BehaviourType;                                             // 0x00FA (size: 0x1)
    bool bCheckIfStillInWorld;                                                        // 0x00FB (size: 0x1)
    uint8 bForceSubStepping;                                                          // 0x00FC (size: 0x1)
    FInterpToMovementComponentOnInterpToReverse OnInterpToReverse;                    // 0x0100 (size: 0x10)
    void OnInterpToReverseDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnInterpToStop OnInterpToStop;                          // 0x0110 (size: 0x10)
    void OnInterpToStopDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnWaitBeginDelegate OnWaitBeginDelegate;                // 0x0120 (size: 0x10)
    void OnInterpToWaitBeginDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnWaitEndDelegate OnWaitEndDelegate;                    // 0x0130 (size: 0x10)
    void OnInterpToWaitEndDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnResetDelegate OnResetDelegate;                        // 0x0140 (size: 0x10)
    void OnInterpToResetDelegate(const FHitResult& ImpactResult, float Time);
    float MaxSimulationTimeStep;                                                      // 0x0150 (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x0154 (size: 0x4)
    TArray<FInterpControlPoint> ControlPoints;                                        // 0x0158 (size: 0x10)

    void StopSimulating(const FHitResult& HitResult);
    void RestartMovement(float InitialDirection);
    void ResetControlPoints();
    void OnInterpToWaitEndDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToWaitBeginDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToStopDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToReverseDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToResetDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void FinaliseControlPoints();
    void AddControlPointPosition(FVector Pos, bool bPositionIsRelative);
}; // Size: 0x190

class UInterpTrack : public UObject
{
    TArray<class UInterpTrack*> SubTracks;                                            // 0x0038 (size: 0x10)
    TSubclassOf<class UInterpTrackInst> TrackInstClass;                               // 0x0048 (size: 0x8)
    TEnumAsByte<ETrackActiveCondition> ActiveCondition;                               // 0x0050 (size: 0x1)
    FString TrackTitle;                                                               // 0x0058 (size: 0x10)
    uint8 bOnePerGroup;                                                               // 0x0068 (size: 0x1)
    uint8 bDirGroupOnly;                                                              // 0x0068 (size: 0x1)
    uint8 bDisableTrack;                                                              // 0x0068 (size: 0x1)
    uint8 bIsSelected;                                                                // 0x0068 (size: 0x1)
    uint8 bIsAnimControlTrack;                                                        // 0x0068 (size: 0x1)
    uint8 bSubTrackOnly;                                                              // 0x0068 (size: 0x1)
    uint8 bVisible;                                                                   // 0x0068 (size: 0x1)
    uint8 bIsRecording;                                                               // 0x0068 (size: 0x1)

}; // Size: 0x70

class UInterpTrackFloatBase : public UInterpTrack
{
    FInterpCurveFloat FloatTrack;                                                     // 0x0070 (size: 0x18)
    float CurveTension;                                                               // 0x0088 (size: 0x4)

}; // Size: 0x90

struct FAnimControlTrackKey
{
    float StartTime;                                                                  // 0x0000 (size: 0x4)
    class UAnimSequence* AnimSeq;                                                     // 0x0008 (size: 0x8)
    float AnimStartOffset;                                                            // 0x0010 (size: 0x4)
    float AnimEndOffset;                                                              // 0x0014 (size: 0x4)
    float AnimPlayRate;                                                               // 0x0018 (size: 0x4)
    uint8 bLooping;                                                                   // 0x001C (size: 0x1)
    uint8 bReverse;                                                                   // 0x001C (size: 0x1)

}; // Size: 0x20

class UInterpTrackAnimControl : public UInterpTrackFloatBase
{
    FName SlotName;                                                                   // 0x0090 (size: 0x8)
    TArray<FAnimControlTrackKey> AnimSeqs;                                            // 0x0098 (size: 0x10)
    uint8 bSkipAnimNotifiers;                                                         // 0x00A8 (size: 0x1)

}; // Size: 0xB0

class UInterpTrackVectorBase : public UInterpTrack
{
    FInterpCurveVector VectorTrack;                                                   // 0x0070 (size: 0x18)
    float CurveTension;                                                               // 0x0088 (size: 0x4)

}; // Size: 0x90

class UInterpTrackAudioMaster : public UInterpTrackVectorBase
{
}; // Size: 0x90

struct FBoolTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    uint8 Value;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

class UInterpTrackBoolProp : public UInterpTrack
{
    TArray<FBoolTrackKey> BoolTrack;                                                  // 0x0070 (size: 0x10)
    FName PropertyName;                                                               // 0x0080 (size: 0x8)

}; // Size: 0x88

class UInterpTrackColorProp : public UInterpTrackVectorBase
{
    FName PropertyName;                                                               // 0x0090 (size: 0x8)

}; // Size: 0x98

class UInterpTrackColorScale : public UInterpTrackVectorBase
{
}; // Size: 0x90

struct FDirectorTrackCut
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    float TransitionTime;                                                             // 0x0004 (size: 0x4)
    FName TargetCamGroup;                                                             // 0x0008 (size: 0x8)
    int32 ShotNumber;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x14

class UInterpTrackDirector : public UInterpTrack
{
    TArray<FDirectorTrackCut> CutTrack;                                               // 0x0070 (size: 0x10)
    uint8 bSimulateCameraCutsOnClients;                                               // 0x0080 (size: 0x1)

}; // Size: 0x88

struct FEventTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FName EventName;                                                                  // 0x0004 (size: 0x8)

}; // Size: 0xC

class UInterpTrackEvent : public UInterpTrack
{
    TArray<FEventTrackKey> EventTrack;                                                // 0x0070 (size: 0x10)
    uint8 bFireEventsWhenForwards;                                                    // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenBackwards;                                                   // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenJumpingForwards;                                             // 0x0080 (size: 0x1)
    uint8 bUseCustomEventName;                                                        // 0x0080 (size: 0x1)

}; // Size: 0x88

class UInterpTrackFade : public UInterpTrackFloatBase
{
    uint8 bPersistFade;                                                               // 0x0090 (size: 0x1)
    uint8 bFadeAudio;                                                                 // 0x0090 (size: 0x1)
    FLinearColor FadeColor;                                                           // 0x0094 (size: 0x10)

}; // Size: 0xA8

class UInterpTrackFloatAnimBPParam : public UInterpTrackFloatBase
{
    UClass* AnimBlueprintClass;                                                       // 0x0090 (size: 0x8)
    TSubclassOf<class UAnimInstance> AnimClass;                                       // 0x0098 (size: 0x8)
    FName ParamName;                                                                  // 0x00A0 (size: 0x8)

}; // Size: 0xB0

class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
    TArray<class UMaterialInterface*> TargetMaterials;                                // 0x0090 (size: 0x10)
    FName ParamName;                                                                  // 0x00A0 (size: 0x8)

}; // Size: 0xA8

class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase
{
    FName ParamName;                                                                  // 0x0090 (size: 0x8)

}; // Size: 0x98

class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
    FName PropertyName;                                                               // 0x0090 (size: 0x8)

}; // Size: 0x98

class UInterpTrackInst : public UObject
{
}; // Size: 0x28

class UInterpTrackInstAnimControl : public UInterpTrackInst
{
    float LastUpdatePosition;                                                         // 0x0028 (size: 0x4)

}; // Size: 0x30

class UInterpTrackInstAudioMaster : public UInterpTrackInst
{
}; // Size: 0x28

class UInterpTrackInstProperty : public UInterpTrackInst
{
    TFieldPath<FProperty> InterpProperty;                                             // 0x0028 (size: 0x20)
    class UObject* PropertyOuterObjectInst;                                           // 0x0048 (size: 0x8)

}; // Size: 0x50

class UInterpTrackInstBoolProp : public UInterpTrackInstProperty
{
    bool ResetBool;                                                                   // 0x0060 (size: 0x1)

}; // Size: 0x68

class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
    FColor ResetColor;                                                                // 0x0058 (size: 0x4)

}; // Size: 0x60

class UInterpTrackInstColorScale : public UInterpTrackInst
{
}; // Size: 0x28

class UInterpTrackInstDirector : public UInterpTrackInst
{
    class AActor* OldViewTarget;                                                      // 0x0028 (size: 0x8)

}; // Size: 0x30

class UInterpTrackInstEvent : public UInterpTrackInst
{
    float LastUpdatePosition;                                                         // 0x0028 (size: 0x4)

}; // Size: 0x30

class UInterpTrackInstFade : public UInterpTrackInst
{
}; // Size: 0x28

class UInterpTrackInstFloatAnimBPParam : public UInterpTrackInst
{
    class UAnimInstance* AnimScriptInstance;                                          // 0x0028 (size: 0x8)
    float ResetFloat;                                                                 // 0x0030 (size: 0x4)

}; // Size: 0x40

struct FPrimitiveMaterialRef
{
    class UPrimitiveComponent* Primitive;                                             // 0x0000 (size: 0x8)
    class UDecalComponent* Decal;                                                     // 0x0008 (size: 0x8)
    int32 ElementIndex;                                                               // 0x0010 (size: 0x4)

}; // Size: 0x18

class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
    TArray<class UMaterialInstanceDynamic*> MaterialInstances;                        // 0x0028 (size: 0x10)
    TArray<float> ResetFloats;                                                        // 0x0038 (size: 0x10)
    TArray<FPrimitiveMaterialRef> PrimitiveMaterialRefs;                              // 0x0048 (size: 0x10)
    class UInterpTrackFloatMaterialParam* InstancedTrack;                             // 0x0058 (size: 0x8)

}; // Size: 0x60

class UInterpTrackInstFloatParticleParam : public UInterpTrackInst
{
    float ResetFloat;                                                                 // 0x0028 (size: 0x4)

}; // Size: 0x30

class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
    float ResetFloat;                                                                 // 0x0058 (size: 0x4)

}; // Size: 0x60

class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty
{
    FLinearColor ResetColor;                                                          // 0x0058 (size: 0x10)

}; // Size: 0x68

class UInterpTrackInstMove : public UInterpTrackInst
{
    FVector ResetLocation;                                                            // 0x0028 (size: 0xC)
    FRotator ResetRotation;                                                           // 0x0034 (size: 0xC)

}; // Size: 0x40

class UInterpTrackInstParticleReplay : public UInterpTrackInst
{
    float LastUpdatePosition;                                                         // 0x0028 (size: 0x4)

}; // Size: 0x30

class UInterpTrackInstSlomo : public UInterpTrackInst
{
    float OldTimeDilation;                                                            // 0x0028 (size: 0x4)

}; // Size: 0x30

class UInterpTrackInstSound : public UInterpTrackInst
{
    float LastUpdatePosition;                                                         // 0x0028 (size: 0x4)
    class UAudioComponent* PlayAudioComp;                                             // 0x0030 (size: 0x8)

}; // Size: 0x38

class UInterpTrackInstToggle : public UInterpTrackInst
{
    TEnumAsByte<ETrackToggleAction> Action;                                           // 0x0028 (size: 0x1)
    float LastUpdatePosition;                                                         // 0x002C (size: 0x4)
    uint8 bSavedActiveState;                                                          // 0x0030 (size: 0x1)

}; // Size: 0x38

class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
    TArray<class UMaterialInstanceDynamic*> MaterialInstances;                        // 0x0028 (size: 0x10)
    TArray<FVector> ResetVectors;                                                     // 0x0038 (size: 0x10)
    TArray<FPrimitiveMaterialRef> PrimitiveMaterialRefs;                              // 0x0048 (size: 0x10)
    class UInterpTrackVectorMaterialParam* InstancedTrack;                            // 0x0058 (size: 0x8)

}; // Size: 0x60

class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
    FVector ResetVector;                                                              // 0x0058 (size: 0xC)

}; // Size: 0x68

class UInterpTrackInstVisibility : public UInterpTrackInst
{
    TEnumAsByte<EVisibilityTrackAction> Action;                                       // 0x0028 (size: 0x1)
    float LastUpdatePosition;                                                         // 0x002C (size: 0x4)

}; // Size: 0x30

class UInterpTrackLinearColorBase : public UInterpTrack
{
    FInterpCurveLinearColor LinearColorTrack;                                         // 0x0070 (size: 0x18)
    float CurveTension;                                                               // 0x0088 (size: 0x4)

}; // Size: 0x90

class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase
{
    FName PropertyName;                                                               // 0x0090 (size: 0x8)

}; // Size: 0x98

struct FInterpLookupPoint
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FInterpLookupTrack
{
    TArray<FInterpLookupPoint> Points;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

class UInterpTrackMove : public UInterpTrack
{
    FInterpCurveVector PosTrack;                                                      // 0x0070 (size: 0x18)
    FInterpCurveVector EulerTrack;                                                    // 0x0088 (size: 0x18)
    FInterpLookupTrack LookupTrack;                                                   // 0x00A0 (size: 0x10)
    FName LookAtGroupName;                                                            // 0x00B0 (size: 0x8)
    float LinCurveTension;                                                            // 0x00B8 (size: 0x4)
    float AngCurveTension;                                                            // 0x00BC (size: 0x4)
    uint8 bUseQuatInterpolation;                                                      // 0x00C0 (size: 0x1)
    uint8 bShowArrowAtKeys;                                                           // 0x00C0 (size: 0x1)
    uint8 bDisableMovement;                                                           // 0x00C0 (size: 0x1)
    uint8 bShowTranslationOnCurveEd;                                                  // 0x00C0 (size: 0x1)
    uint8 bShowRotationOnCurveEd;                                                     // 0x00C0 (size: 0x1)
    uint8 bHide3DTrack;                                                               // 0x00C0 (size: 0x1)
    TEnumAsByte<EInterpTrackMoveRotMode> RotMode;                                     // 0x00C4 (size: 0x1)

}; // Size: 0xC8

class UInterpTrackMoveAxis : public UInterpTrackFloatBase
{
    TEnumAsByte<EInterpMoveAxis> MoveAxis;                                            // 0x0090 (size: 0x1)
    FInterpLookupTrack LookupTrack;                                                   // 0x0098 (size: 0x10)

}; // Size: 0xA8

struct FParticleReplayTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    float Duration;                                                                   // 0x0004 (size: 0x4)
    int32 ClipIDNumber;                                                               // 0x0008 (size: 0x4)

}; // Size: 0xC

class UInterpTrackParticleReplay : public UInterpTrack
{
    TArray<FParticleReplayTrackKey> TrackKeys;                                        // 0x0070 (size: 0x10)

}; // Size: 0x80

class UInterpTrackSlomo : public UInterpTrackFloatBase
{
}; // Size: 0x90

struct FSoundTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    float Volume;                                                                     // 0x0004 (size: 0x4)
    float Pitch;                                                                      // 0x0008 (size: 0x4)
    class USoundBase* Sound;                                                          // 0x0010 (size: 0x8)

}; // Size: 0x18

class UInterpTrackSound : public UInterpTrackVectorBase
{
    TArray<FSoundTrackKey> Sounds;                                                    // 0x0090 (size: 0x10)
    uint8 bPlayOnReverse;                                                             // 0x00A0 (size: 0x1)
    uint8 bContinueSoundOnMatineeEnd;                                                 // 0x00A0 (size: 0x1)
    uint8 bSuppressSubtitles;                                                         // 0x00A0 (size: 0x1)
    uint8 bTreatAsDialogue;                                                           // 0x00A0 (size: 0x1)
    uint8 bAttach;                                                                    // 0x00A0 (size: 0x1)

}; // Size: 0xA8

struct FToggleTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    TEnumAsByte<ETrackToggleAction> ToggleAction;                                     // 0x0004 (size: 0x1)

}; // Size: 0x8

class UInterpTrackToggle : public UInterpTrack
{
    TArray<FToggleTrackKey> ToggleTrack;                                              // 0x0070 (size: 0x10)
    uint8 bActivateSystemEachUpdate;                                                  // 0x0080 (size: 0x1)
    uint8 bActivateWithJustAttachedFlag;                                              // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenForwards;                                                    // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenBackwards;                                                   // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenJumpingForwards;                                             // 0x0080 (size: 0x1)

}; // Size: 0x88

class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
    TArray<class UMaterialInterface*> TargetMaterials;                                // 0x0090 (size: 0x10)
    FName ParamName;                                                                  // 0x00A0 (size: 0x8)

}; // Size: 0xA8

class UInterpTrackVectorProp : public UInterpTrackVectorBase
{
    FName PropertyName;                                                               // 0x0090 (size: 0x8)

}; // Size: 0x98

struct FVisibilityTrackKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    TEnumAsByte<EVisibilityTrackAction> Action;                                       // 0x0004 (size: 0x1)
    TEnumAsByte<EVisibilityTrackCondition> ActiveCondition;                           // 0x0005 (size: 0x1)

}; // Size: 0x8

class UInterpTrackVisibility : public UInterpTrack
{
    TArray<FVisibilityTrackKey> VisibilityTrack;                                      // 0x0070 (size: 0x10)
    uint8 bFireEventsWhenForwards;                                                    // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenBackwards;                                                   // 0x0080 (size: 0x1)
    uint8 bFireEventsWhenJumpingForwards;                                             // 0x0080 (size: 0x1)

}; // Size: 0x88

class UIntSerialization : public UObject
{
    uint16 UnsignedInt16Variable;                                                     // 0x0028 (size: 0x2)
    uint32 UnsignedInt32Variable;                                                     // 0x002C (size: 0x4)
    uint64 UnsignedInt64Variable;                                                     // 0x0030 (size: 0x8)
    int8 SignedInt8Variable;                                                          // 0x0038 (size: 0x1)
    int16 SignedInt16Variable;                                                        // 0x003A (size: 0x2)
    int64 SignedInt64Variable;                                                        // 0x0040 (size: 0x8)
    uint8 UnsignedInt8Variable;                                                       // 0x0048 (size: 0x1)
    int32 SignedInt32Variable;                                                        // 0x004C (size: 0x4)

}; // Size: 0x50

class AKillZVolume : public APhysicsVolume
{
}; // Size: 0x270

class UKismetArrayLibrary : public UBlueprintFunctionLibrary
{

    void SetArrayPropertyByName(class UObject* Object, FName PropertyName, const TArray<int32>& Value);
    void FilterArray(const TArray<class AActor*>& TargetArray, TSubclassOf<class AActor> FilterClass, TArray<class AActor*>& FilteredArray);
    void Array_Swap(const TArray<int32>& TargetArray, int32 FirstIndex, int32 SecondIndex);
    void Array_Shuffle(const TArray<int32>& TargetArray);
    void Array_Set(const TArray<int32>& TargetArray, int32 Index, const int32& Item, bool bSizeToFit);
    void Array_Reverse(const TArray<int32>& TargetArray);
    void Array_Resize(const TArray<int32>& TargetArray, int32 Size);
    bool Array_RemoveItem(const TArray<int32>& TargetArray, const int32& Item);
    void Array_Remove(const TArray<int32>& TargetArray, int32 IndexToRemove);
    void Array_RandomFromStream(const TArray<int32>& TargetArray, FRandomStream& RandomStream, int32& OutItem, int32& OutIndex);
    void Array_Random(const TArray<int32>& TargetArray, int32& OutItem, int32& OutIndex);
    int32 Array_Length(const TArray<int32>& TargetArray);
    int32 Array_LastIndex(const TArray<int32>& TargetArray);
    bool Array_IsValidIndex(const TArray<int32>& TargetArray, int32 IndexToTest);
    void Array_Insert(const TArray<int32>& TargetArray, const int32& NewItem, int32 Index);
    bool Array_Identical(const TArray<int32>& ArrayA, const TArray<int32>& ArrayB);
    void Array_Get(const TArray<int32>& TargetArray, int32 Index, int32& Item);
    int32 Array_Find(const TArray<int32>& TargetArray, const int32& ItemToFind);
    bool Array_Contains(const TArray<int32>& TargetArray, const int32& ItemToFind);
    void Array_Clear(const TArray<int32>& TargetArray);
    void Array_Append(const TArray<int32>& TargetArray, const TArray<int32>& SourceArray);
    int32 Array_AddUnique(const TArray<int32>& TargetArray, const int32& NewItem);
    int32 Array_Add(const TArray<int32>& TargetArray, const int32& NewItem);
}; // Size: 0x28

class UKismetGuidLibrary : public UBlueprintFunctionLibrary
{

    void Parse_StringToGuid(FString GuidString, FGuid& OutGuid, bool& Success);
    bool NotEqual_GuidGuid(const FGuid& A, const FGuid& B);
    FGuid NewGuid();
    bool IsValid_Guid(const FGuid& InGuid);
    void Invalidate_Guid(FGuid& InGuid);
    bool EqualEqual_GuidGuid(const FGuid& A, const FGuid& B);
    FString Conv_GuidToString(const FGuid& InGuid);
}; // Size: 0x28

class UKismetInputLibrary : public UBlueprintFunctionLibrary
{

    bool PointerEvent_IsTouchEvent(const FPointerEvent& Input);
    bool PointerEvent_IsMouseButtonDown(const FPointerEvent& Input, FKey MouseButton);
    float PointerEvent_GetWheelDelta(const FPointerEvent& Input);
    int32 PointerEvent_GetUserIndex(const FPointerEvent& Input);
    int32 PointerEvent_GetTouchpadIndex(const FPointerEvent& Input);
    FVector2D PointerEvent_GetScreenSpacePosition(const FPointerEvent& Input);
    int32 PointerEvent_GetPointerIndex(const FPointerEvent& Input);
    FVector2D PointerEvent_GetLastScreenSpacePosition(const FPointerEvent& Input);
    ESlateGesture PointerEvent_GetGestureType(const FPointerEvent& Input);
    FVector2D PointerEvent_GetGestureDelta(const FPointerEvent& Input);
    FKey PointerEvent_GetEffectingButton(const FPointerEvent& Input);
    FVector2D PointerEvent_GetCursorDelta(const FPointerEvent& Input);
    bool Key_IsVectorAxis(const FKey& Key);
    bool Key_IsValid(const FKey& Key);
    bool Key_IsMouseButton(const FKey& Key);
    bool Key_IsModifierKey(const FKey& Key);
    bool Key_IsKeyboardKey(const FKey& Key);
    bool Key_IsGamepadKey(const FKey& Key);
    bool Key_IsDigital(const FKey& Key);
    bool Key_IsButtonAxis(const FKey& Key);
    bool Key_IsAxis3D(const FKey& Key);
    bool Key_IsAxis2D(const FKey& Key);
    bool Key_IsAxis1D(const FKey& Key);
    bool Key_IsAnalog(const FKey& Key);
    EUINavigation Key_GetNavigationDirectionFromKey(const FKeyEvent& InKeyEvent);
    EUINavigation Key_GetNavigationDirectionFromAnalog(const FAnalogInputEvent& InAnalogEvent);
    EUINavigationAction Key_GetNavigationActionFromKey(const FKeyEvent& InKeyEvent);
    EUINavigationAction Key_GetNavigationAction(const FKey& InKey);
    FText Key_GetDisplayName(const FKey& Key);
    bool InputEvent_IsShiftDown(const FInputEvent& Input);
    bool InputEvent_IsRightShiftDown(const FInputEvent& Input);
    bool InputEvent_IsRightControlDown(const FInputEvent& Input);
    bool InputEvent_IsRightCommandDown(const FInputEvent& Input);
    bool InputEvent_IsRightAltDown(const FInputEvent& Input);
    bool InputEvent_IsRepeat(const FInputEvent& Input);
    bool InputEvent_IsLeftShiftDown(const FInputEvent& Input);
    bool InputEvent_IsLeftControlDown(const FInputEvent& Input);
    bool InputEvent_IsLeftCommandDown(const FInputEvent& Input);
    bool InputEvent_IsLeftAltDown(const FInputEvent& Input);
    bool InputEvent_IsControlDown(const FInputEvent& Input);
    bool InputEvent_IsCommandDown(const FInputEvent& Input);
    bool InputEvent_IsAltDown(const FInputEvent& Input);
    FText InputChord_GetDisplayName(const FInputChord& Key);
    int32 GetUserIndex(const FKeyEvent& Input);
    FKey GetKey(const FKeyEvent& Input);
    float GetAnalogValue(const FAnalogInputEvent& Input);
    bool EqualEqual_KeyKey(FKey A, FKey B);
    bool EqualEqual_InputChordInputChord(FInputChord A, FInputChord B);
    void CalibrateTilt();
}; // Size: 0x28

class UKismetInternationalizationLibrary : public UBlueprintFunctionLibrary
{

    bool SetCurrentLocale(FString Culture, const bool SaveToConfig);
    bool SetCurrentLanguageAndLocale(FString Culture, const bool SaveToConfig);
    bool SetCurrentLanguage(FString Culture, const bool SaveToConfig);
    bool SetCurrentCulture(FString Culture, const bool SaveToConfig);
    bool SetCurrentAssetGroupCulture(const FName AssetGroup, FString Culture, const bool SaveToConfig);
    FString GetSuitableCulture(const TArray<FString>& AvailableCultures, FString CultureToMatch, FString FallbackCulture);
    FString GetNativeCulture(const ELocalizedTextSourceCategory TextCategory);
    TArray<FString> GetLocalizedCultures(const bool IncludeGame, const bool IncludeEngine, const bool IncludeEditor, const bool IncludeAdditional);
    FString GetCurrentLocale();
    FString GetCurrentLanguage();
    FString GetCurrentCulture();
    FString GetCurrentAssetGroupCulture(const FName AssetGroup);
    FString GetCultureDisplayName(FString Culture, const bool Localized);
    void ClearCurrentAssetGroupCulture(const FName AssetGroup, const bool SaveToConfig);
}; // Size: 0x28

class UKismetMaterialLibrary : public UBlueprintFunctionLibrary
{

    void SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName, const FLinearColor& ParameterValue);
    void SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue);
    FLinearColor GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName);
    float GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName);
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent, FName OptionalName, EMIDCreationFlags CreationFlags);
}; // Size: 0x28

struct FVectorSpringState
{
}; // Size: 0x18

struct FFloatSpringState
{
}; // Size: 0x8

class UKismetMathLibrary : public UBlueprintFunctionLibrary
{

    int32 Xor_IntInt(int32 A, int32 B);
    int64 Xor_Int64Int64(int64 A, int64 B);
    int32 Wrap(int32 Value, int32 Min, int32 Max);
    FVector WeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float Weight);
    FRotator WeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float Weight);
    float WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight);
    float VSizeXYSquared(FVector A);
    float VSizeXY(FVector A);
    float VSizeSquared(FVector A);
    float VSize2DSquared(FVector2D A);
    float VSize2D(FVector2D A);
    float VSize(FVector A);
    FVector VLerp(FVector A, FVector B, float Alpha);
    FVector VInterpTo_Constant(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    FVector VInterpTo(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    FVector VectorSpringInterp(FVector Current, FVector Target, FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
    FVector Vector_Zero();
    FVector Vector_Up();
    void Vector_UnwindEuler(FVector& A);
    FVector2D Vector_UnitCartesianToSpherical(FVector A);
    FVector Vector_ToRadians(FVector A);
    FVector Vector_ToDegrees(FVector A);
    FVector Vector_SnappedToGrid(FVector InVect, float InGridSize);
    void Vector_Set(FVector& A, float X, float Y, float Z);
    FVector Vector_Right();
    FVector Vector_Reciprocal(const FVector& A);
    FVector Vector_ProjectOnToNormal(FVector V, FVector InNormal);
    FVector Vector_One();
    FVector Vector_NormalUnsafe(const FVector& A);
    void Vector_Normalize(FVector& A, float Tolerance);
    FVector Vector_Normal2D(FVector A, float Tolerance);
    FVector Vector_MirrorByPlane(FVector A, const FPlane& InPlane);
    FVector Vector_Left();
    bool Vector_IsZero(const FVector& A);
    bool Vector_IsUnit(const FVector& A, float SquaredLenthTolerance);
    bool Vector_IsUniform(const FVector& A, float Tolerance);
    bool Vector_IsNormal(const FVector& A);
    bool Vector_IsNearlyZero(const FVector& A, float Tolerance);
    bool Vector_IsNAN(const FVector& A);
    float Vector_HeadingAngle(FVector A);
    FVector Vector_GetSignVector(FVector A);
    FVector Vector_GetProjection(FVector A);
    float Vector_GetAbsMin(FVector A);
    float Vector_GetAbsMax(FVector A);
    FVector Vector_GetAbs(FVector A);
    FVector Vector_Forward();
    FVector Vector_Down();
    float Vector_DistanceSquared(FVector v1, FVector v2);
    float Vector_Distance2DSquared(FVector v1, FVector v2);
    float Vector_Distance2D(FVector v1, FVector v2);
    float Vector_Distance(FVector v1, FVector v2);
    float Vector_CosineAngle2D(FVector A, FVector B);
    FVector Vector_ComponentMin(FVector A, FVector B);
    FVector Vector_ComponentMax(FVector A, FVector B);
    FVector Vector_ClampSizeMax2D(FVector A, float Max);
    FVector Vector_ClampSizeMax(FVector A, float Max);
    FVector Vector_ClampSize2D(FVector A, float Min, float Max);
    FVector Vector_BoundedToCube(FVector InVect, float InRadius);
    FVector Vector_BoundedToBox(FVector InVect, FVector InBoxMin, FVector InBoxMax);
    FVector Vector_Backward();
    void Vector_Assign(FVector& A, const FVector& InVector);
    void Vector_AddBounded(FVector& A, FVector InAddVect, float InRadius);
    FVector4 Vector4_Zero();
    float Vector4_SizeSquared3(const FVector4& A);
    float Vector4_SizeSquared(const FVector4& A);
    float Vector4_Size3(const FVector4& A);
    float Vector4_Size(const FVector4& A);
    void Vector4_Set(FVector4& A, float X, float Y, float Z, float W);
    FVector4 Vector4_NormalUnsafe3(const FVector4& A);
    void Vector4_Normalize3(FVector4& A, float Tolerance);
    FVector4 Vector4_Normal3(const FVector4& A, float Tolerance);
    FVector4 Vector4_Negated(const FVector4& A);
    FVector4 Vector4_MirrorByVector3(const FVector4& Direction, const FVector4& SurfaceNormal);
    bool Vector4_IsZero(const FVector4& A);
    bool Vector4_IsUnit3(const FVector4& A, float SquaredLenthTolerance);
    bool Vector4_IsNormal3(const FVector4& A);
    bool Vector4_IsNearlyZero3(const FVector4& A, float Tolerance);
    bool Vector4_IsNAN(const FVector4& A);
    float Vector4_DotProduct3(const FVector4& A, const FVector4& B);
    float Vector4_DotProduct(const FVector4& A, const FVector4& B);
    FVector4 Vector4_CrossProduct3(const FVector4& A, const FVector4& B);
    void Vector4_Assign(FVector4& A, const FVector4& InVector);
    FVector2D Vector2DInterpTo_Constant(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    FVector2D Vector2DInterpTo(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    FVector2D Vector2D_Zero();
    FVector2D Vector2D_Unit45Deg();
    FVector2D Vector2D_One();
    FVector VEase(FVector A, FVector B, float Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    FDateTime UtcNow();
    FVector4 TransformVector4(const FMatrix& Matrix, const FVector4& Vec4);
    FRotator TransformRotation(const FTransform& T, FRotator Rotation);
    FVector TransformLocation(const FTransform& T, FVector Location);
    FVector TransformDirection(const FTransform& T, FVector Direction);
    float Transform_Determinant(const FTransform& Transform);
    FVector2D ToSign2D(FVector2D A);
    FVector2D ToRounded2D(FVector2D A);
    void ToDirectionAndLength2D(FVector2D A, FVector2D& OutDir, float& OutLength);
    FDateTime Today();
    FTransform TLerp(const FTransform& A, const FTransform& B, float Alpha, TEnumAsByte<ELerpInterpolationMode::Type> InterpMode);
    FTransform TInterpTo(const FTransform& Current, const FTransform& Target, float DeltaTime, float InterpSpeed);
    FTimespan TimespanZeroValue();
    float TimespanRatio(FTimespan A, FTimespan B);
    FTimespan TimespanMinValue();
    FTimespan TimespanMaxValue();
    bool TimespanFromString(FString TimespanString, FTimespan& Result);
    FTransform TEase(const FTransform& A, const FTransform& B, float Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    float Tan(float A);
    FVector Subtract_VectorVector(FVector A, FVector B);
    FVector Subtract_VectorInt(FVector A, int32 B);
    FVector Subtract_VectorFloat(FVector A, float B);
    FVector4 Subtract_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Subtract_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Subtract_Vector2DFloat(FVector2D A, float B);
    FTimespan Subtract_TimespanTimespan(FTimespan A, FTimespan B);
    FQuat Subtract_QuatQuat(const FQuat& A, const FQuat& B);
    FLinearColor Subtract_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Subtract_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Subtract_IntPointInt(FIntPoint A, int32 B);
    int32 Subtract_IntInt(int32 A, int32 B);
    int64 Subtract_Int64Int64(int64 A, int64 B);
    float Subtract_FloatFloat(float A, float B);
    FDateTime Subtract_DateTimeTimespan(FDateTime A, FTimespan B);
    FTimespan Subtract_DateTimeDateTime(FDateTime A, FDateTime B);
    uint8 Subtract_ByteByte(uint8 A, uint8 B);
    float Square(float A);
    float Sqrt(float A);
    FVector Spherical2DToUnitCartesian(FVector2D A);
    float Sin(float A);
    int64 SignOfInteger64(int64 A);
    int32 SignOfInteger(int32 A);
    float SignOfFloat(float A);
    void SetRandomStreamSeed(FRandomStream& Stream, int32 NewSeed);
    void Set2D(FVector2D& A, float X, float Y);
    FVector SelectVector(FVector A, FVector B, bool bPickA);
    FTransform SelectTransform(const FTransform& A, const FTransform& B, bool bPickA);
    FString SelectString(FString A, FString B, bool bPickA);
    FRotator SelectRotator(FRotator A, FRotator B, bool bPickA);
    class UObject* SelectObject(class UObject* A, class UObject* B, bool bSelectA);
    int32 SelectInt(int32 A, int32 B, bool bPickA);
    float SelectFloat(float A, float B, bool bPickA);
    FLinearColor SelectColor(FLinearColor A, FLinearColor B, bool bPickA);
    UClass* SelectClass(UClass* A, UClass* B, bool bSelectA);
    void SeedRandomStream(FRandomStream& Stream);
    float SafeDivide(float A, float B);
    int64 Round64(float A);
    int32 Round(float A);
    FRotator RotatorFromAxisAndAngle(FVector Axis, float Angle);
    FVector RotateAngleAxis(FVector InVect, float AngleDeg, FVector Axis);
    FRotator RLerp(FRotator A, FRotator B, float Alpha, bool bShortestPath);
    FRotator RInterpTo_Constant(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    FRotator RInterpTo(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    void RGBToHSV_Vector(FLinearColor RGB, FLinearColor& HSV);
    void RGBToHSV(FLinearColor InColor, float& H, float& S, float& V, float& A);
    FLinearColor RGBLinearToHSV(FLinearColor RGB);
    void ResetVectorSpringState(FVectorSpringState& SpringState);
    void ResetRandomStream(const FRandomStream& Stream);
    void ResetFloatSpringState(FFloatSpringState& SpringState);
    FRotator REase(FRotator A, FRotator B, float Alpha, bool bShortestPath, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    FVector RandomUnitVectorInEllipticalConeInRadiansFromStream(const FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, const FRandomStream& Stream);
    FVector RandomUnitVectorInEllipticalConeInRadians(FVector ConeDir, float MaxYawInRadians, float MaxPitchInRadians);
    FVector RandomUnitVectorInEllipticalConeInDegreesFromStream(const FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, const FRandomStream& Stream);
    FVector RandomUnitVectorInEllipticalConeInDegrees(FVector ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees);
    FVector RandomUnitVectorInConeInRadiansFromStream(const FVector& ConeDir, float ConeHalfAngleInRadians, const FRandomStream& Stream);
    FVector RandomUnitVectorInConeInRadians(FVector ConeDir, float ConeHalfAngleInRadians);
    FVector RandomUnitVectorInConeInDegreesFromStream(const FVector& ConeDir, float ConeHalfAngleInDegrees, const FRandomStream& Stream);
    FVector RandomUnitVectorInConeInDegrees(FVector ConeDir, float ConeHalfAngleInDegrees);
    FVector RandomUnitVectorFromStream(const FRandomStream& Stream);
    FVector RandomUnitVector();
    FRotator RandomRotatorFromStream(bool bRoll, const FRandomStream& Stream);
    FRotator RandomRotator(bool bRoll);
    FVector RandomPointInBoundingBox(FVector Origin, FVector BoxExtent);
    int32 RandomIntegerInRangeFromStream(int32 Min, int32 Max, const FRandomStream& Stream);
    int32 RandomIntegerInRange(int32 Min, int32 Max);
    int32 RandomIntegerFromStream(int32 Max, const FRandomStream& Stream);
    int64 RandomInteger64InRange(int64 Min, int64 Max);
    int64 RandomInteger64(int64 Max);
    int32 RandomInteger(int32 Max);
    float RandomFloatInRangeFromStream(float Min, float Max, const FRandomStream& Stream);
    float RandomFloatInRange(float Min, float Max);
    float RandomFloatFromStream(const FRandomStream& Stream);
    float RandomFloat();
    bool RandomBoolWithWeightFromStream(float Weight, const FRandomStream& RandomStream);
    bool RandomBoolWithWeight(float Weight);
    bool RandomBoolFromStream(const FRandomStream& Stream);
    bool RandomBool();
    float RadiansToDegrees(float A);
    FVector Quat_VectorUp(const FQuat& Q);
    FVector Quat_VectorRight(const FQuat& Q);
    FVector Quat_VectorForward(const FQuat& Q);
    FVector Quat_UnrotateVector(const FQuat& Q, const FVector& V);
    float Quat_SizeSquared(const FQuat& Q);
    float Quat_Size(const FQuat& Q);
    void Quat_SetFromEuler(FQuat& Q, const FVector& Euler);
    void Quat_SetComponents(FQuat& Q, float X, float Y, float Z, float W);
    FRotator Quat_Rotator(const FQuat& Q);
    FVector Quat_RotateVector(const FQuat& Q, const FVector& V);
    FQuat Quat_Normalized(const FQuat& Q, float Tolerance);
    void Quat_Normalize(FQuat& Q, float Tolerance);
    FQuat Quat_MakeFromEuler(const FVector& Euler);
    FQuat Quat_Log(const FQuat& Q);
    bool Quat_IsNormalized(const FQuat& Q);
    bool Quat_IsNonFinite(const FQuat& Q);
    bool Quat_IsIdentity(const FQuat& Q, float Tolerance);
    bool Quat_IsFinite(const FQuat& Q);
    FQuat Quat_Inversed(const FQuat& Q);
    FQuat Quat_Identity();
    FVector Quat_GetRotationAxis(const FQuat& Q);
    FVector Quat_GetAxisZ(const FQuat& Q);
    FVector Quat_GetAxisY(const FQuat& Q);
    FVector Quat_GetAxisX(const FQuat& Q);
    float Quat_GetAngle(const FQuat& Q);
    FQuat Quat_Exp(const FQuat& Q);
    FVector Quat_Euler(const FQuat& Q);
    void Quat_EnforceShortestArcWith(FQuat& A, const FQuat& B);
    float Quat_AngularDistance(const FQuat& A, const FQuat& B);
    FVector ProjectVectorOnToVector(FVector V, FVector Target);
    FVector ProjectVectorOnToPlane(FVector V, FVector PlaneNormal);
    FVector ProjectPointOnToPlane(FVector Point, FVector PlaneBase, FVector PlaneNormal);
    bool PointsAreCoplanar(const TArray<FVector>& Points, float Tolerance);
    float PerlinNoise1D(const float Value);
    int32 Percent_IntInt(int32 A, int32 B);
    float Percent_FloatFloat(float A, float B);
    uint8 Percent_ByteByte(uint8 A, uint8 B);
    int32 Or_IntInt(int32 A, int32 B);
    int64 Or_Int64Int64(int64 A, int64 B);
    FDateTime Now();
    bool NotEqualExactly_VectorVector(FVector A, FVector B);
    bool NotEqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    bool NotEqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    bool NotEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    bool NotEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    bool NotEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    bool NotEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool NotEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    bool NotEqual_QuatQuat(const FQuat& A, const FQuat& B, float ErrorTolerance);
    bool NotEqual_ObjectObject(class UObject* A, class UObject* B);
    bool NotEqual_NameName(FName A, FName B);
    bool NotEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    bool NotEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    bool NotEqual_IntPointIntPoint(FIntPoint A, FIntPoint B);
    bool NotEqual_IntInt(int32 A, int32 B);
    bool NotEqual_Int64Int64(int64 A, int64 B);
    bool NotEqual_FloatFloat(float A, float B);
    bool NotEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool NotEqual_ClassClass(UClass* A, UClass* B);
    bool NotEqual_ByteByte(uint8 A, uint8 B);
    bool NotEqual_BoolBool(bool A, bool B);
    bool Not_PreBool(bool A);
    int64 Not_Int64(int64 A);
    int32 Not_Int(int32 A);
    FVector2D NormalSafe2D(FVector2D A, float Tolerance);
    float NormalizeToRange(float Value, float RangeMin, float RangeMax);
    FRotator NormalizedDeltaRotator(FRotator A, FRotator B);
    float NormalizeAxis(float Angle);
    void Normalize2D(FVector2D& A, float Tolerance);
    FVector2D Normal2D(FVector2D A);
    FVector Normal(FVector A, float Tolerance);
    FVector NegateVector(FVector A);
    FRotator NegateRotator(FRotator A);
    FVector2D Negated2D(const FVector2D& A);
    bool NearlyEqual_TransformTransform(const FTransform& A, const FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance);
    bool NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance);
    float MultiplyMultiply_FloatFloat(float Base, float Exp);
    float MultiplyByPi(float Value);
    FVector Multiply_VectorVector(FVector A, FVector B);
    FVector Multiply_VectorInt(FVector A, int32 B);
    FVector Multiply_VectorFloat(FVector A, float B);
    FVector4 Multiply_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Multiply_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Multiply_Vector2DFloat(FVector2D A, float B);
    FTimespan Multiply_TimespanFloat(FTimespan A, float Scalar);
    FRotator Multiply_RotatorInt(FRotator A, int32 B);
    FRotator Multiply_RotatorFloat(FRotator A, float B);
    FQuat Multiply_QuatQuat(const FQuat& A, const FQuat& B);
    FMatrix Multiply_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    FMatrix Multiply_MatrixFloat(const FMatrix& A, float B);
    FLinearColor Multiply_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FLinearColor Multiply_LinearColorFloat(FLinearColor A, float B);
    FIntPoint Multiply_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Multiply_IntPointInt(FIntPoint A, int32 B);
    int32 Multiply_IntInt(int32 A, int32 B);
    float Multiply_IntFloat(int32 A, float B);
    int64 Multiply_Int64Int64(int64 A, int64 B);
    float Multiply_FloatFloat(float A, float B);
    uint8 Multiply_ByteByte(uint8 A, uint8 B);
    FVector MirrorVectorByNormal(FVector InVect, FVector InNormal);
    void MinOfIntArray(const TArray<int32>& IntArray, int32& IndexOfMinValue, int32& MinValue);
    void MinOfFloatArray(const TArray<float>& FloatArray, int32& IndexOfMinValue, float& MinValue);
    void MinOfByteArray(const TArray<uint8>& ByteArray, int32& IndexOfMinValue, uint8& MinValue);
    int64 MinInt64(int64 A, int64 B);
    void MinimumAreaRectangle(class UObject* WorldContextObject, const TArray<FVector>& InVerts, const FVector& SampleSurfaceNormal, FVector& OutRectCenter, FRotator& OutRectRotation, float& OutSideLengthX, float& OutSideLengthY, bool bDebugDraw);
    int32 Min(int32 A, int32 B);
    void MaxOfIntArray(const TArray<int32>& IntArray, int32& IndexOfMaxValue, int32& MaxValue);
    void MaxOfFloatArray(const TArray<float>& FloatArray, int32& IndexOfMaxValue, float& MaxValue);
    void MaxOfByteArray(const TArray<uint8>& ByteArray, int32& IndexOfMaxValue, uint8& MaxValue);
    int64 MaxInt64(int64 A, int64 B);
    int32 Max(int32 A, int32 B);
    FVector4 Matrix_TransformVector4(const FMatrix& M, FVector4 V);
    FVector4 Matrix_TransformVector(const FMatrix& M, FVector V);
    FVector4 Matrix_TransformPosition(const FMatrix& M, FVector V);
    FQuat Matrix_ToQuat(const FMatrix& M);
    void Matrix_SetOrigin(FMatrix& M, FVector NewOrigin);
    void Matrix_SetColumn(FMatrix& M, TEnumAsByte<EMatrixColumns::Type> Column, FVector Value);
    void Matrix_SetAxis(FMatrix& M, TEnumAsByte<EAxis::Type> Axis, FVector AxisVector);
    FMatrix Matrix_ScaleTranslation(const FMatrix& M, FVector Scale3D);
    FMatrix Matrix_RemoveTranslation(const FMatrix& M);
    void Matrix_RemoveScaling(FMatrix& M, float Tolerance);
    FMatrix Matrix_Mirror(const FMatrix& M, TEnumAsByte<EAxis::Type> MirrorAxis, TEnumAsByte<EAxis::Type> FlipAxis);
    FVector Matrix_InverseTransformVector(const FMatrix& M, FVector V);
    FVector Matrix_InverseTransformPosition(const FMatrix& M, FVector V);
    FMatrix Matrix_Identity();
    FVector Matrix_GetUnitAxis(const FMatrix& M, TEnumAsByte<EAxis::Type> Axis);
    void Matrix_GetUnitAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    FMatrix Matrix_GetTransposed(const FMatrix& M);
    FMatrix Matrix_GetTransposeAdjoint(const FMatrix& M);
    FVector Matrix_GetScaleVector(const FMatrix& M, float Tolerance);
    FVector Matrix_GetScaledAxis(const FMatrix& M, TEnumAsByte<EAxis::Type> Axis);
    void Matrix_GetScaledAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    float Matrix_GetRotDeterminant(const FMatrix& M);
    FRotator Matrix_GetRotator(const FMatrix& M);
    FVector Matrix_GetOrigin(const FMatrix& InMatrix);
    float Matrix_GetMaximumAxisScale(const FMatrix& M);
    FMatrix Matrix_GetMatrixWithoutScale(const FMatrix& M, float Tolerance);
    FMatrix Matrix_GetInverse(const FMatrix& M);
    bool Matrix_GetFrustumTopPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumRightPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumNearPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumLeftPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumFarPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumBottomPlane(const FMatrix& M, FPlane& OutPlane);
    float Matrix_GetDeterminant(const FMatrix& M);
    FVector Matrix_GetColumn(const FMatrix& M, TEnumAsByte<EMatrixColumns::Type> Column);
    bool Matrix_ContainsNaN(const FMatrix& M);
    FMatrix Matrix_ConcatenateTranslation(const FMatrix& M, FVector Translation);
    FMatrix Matrix_ApplyScale(const FMatrix& M, float Scale);
    float MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
    float MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB);
    FVector4 MakeVector4(float X, float Y, float Z, float W);
    FVector2D MakeVector2D(float X, float Y);
    FVector MakeVector(float X, float Y, float Z);
    FTransform MakeTransform(FVector Location, FRotator Rotation, FVector Scale);
    FTimespan MakeTimespan2(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 FractionNano);
    FTimespan MakeTimespan(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 MilliSeconds);
    FRotator MakeRotFromZY(const FVector& Z, const FVector& Y);
    FRotator MakeRotFromZX(const FVector& Z, const FVector& X);
    FRotator MakeRotFromZ(const FVector& Z);
    FRotator MakeRotFromYZ(const FVector& Y, const FVector& Z);
    FRotator MakeRotFromYX(const FVector& Y, const FVector& X);
    FRotator MakeRotFromY(const FVector& Y);
    FRotator MakeRotFromXZ(const FVector& X, const FVector& Z);
    FRotator MakeRotFromXY(const FVector& X, const FVector& Y);
    FRotator MakeRotFromX(const FVector& X);
    FRotator MakeRotator(float Roll, float Pitch, float Yaw);
    FRotator MakeRotationFromAxes(FVector Forward, FVector Right, FVector Up);
    FTransform MakeRelativeTransform(const FTransform& A, const FTransform& RelativeTo);
    FRandomStream MakeRandomStream(int32 InitialSeed);
    FQualifiedFrameTime MakeQualifiedFrameTime(FFrameNumber Frame, FFrameRate FrameRate, float SubFrame);
    float MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase);
    FPlane MakePlaneFromPointAndNormal(FVector Point, FVector Normal);
    FFrameRate MakeFrameRate(int32 Numerator, int32 Denominator);
    FDateTime MakeDateTime(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond);
    FLinearColor MakeColor(float R, float G, float B, float A);
    FBox2D MakeBox2D(FVector2D Min, FVector2D Max);
    FBox MakeBox(FVector Min, FVector Max);
    float Loge(float A);
    float Log(float A, float Base);
    bool LinePlaneIntersection_OriginNormal(const FVector& LineStart, const FVector& LineEnd, FVector PlaneOrigin, FVector PlaneNormal, float& T, FVector& Intersection);
    bool LinePlaneIntersection(const FVector& LineStart, const FVector& LineEnd, const FPlane& APlane, float& T, FVector& Intersection);
    FLinearColor LinearColorLerpUsingHSV(FLinearColor A, FLinearColor B, float Alpha);
    FLinearColor LinearColorLerp(FLinearColor A, FLinearColor B, float Alpha);
    FLinearColor LinearColor_Yellow();
    FLinearColor LinearColor_White();
    FLinearColor LinearColor_Transparent();
    FColor LinearColor_ToRGBE(FLinearColor InLinearColor);
    FLinearColor LinearColor_ToNewOpacity(FLinearColor InColor, float InOpacity);
    void LinearColor_SetTemperature(FLinearColor& InOutColor, float InTemperature);
    void LinearColor_SetRGBA(FLinearColor& InOutColor, float R, float G, float B, float A);
    void LinearColor_SetRandomHue(FLinearColor& InOutColor);
    void LinearColor_SetFromSRGB(FLinearColor& InOutColor, const FColor& InSRGB);
    void LinearColor_SetFromPow22(FLinearColor& InOutColor, const FColor& InColor);
    void LinearColor_SetFromHSV(FLinearColor& InOutColor, float H, float S, float V, float A);
    void LinearColor_Set(FLinearColor& InOutColor, FLinearColor InColor);
    FLinearColor LinearColor_Red();
    FColor LinearColor_QuantizeRound(FLinearColor InColor);
    FColor LinearColor_Quantize(FLinearColor InColor);
    bool LinearColor_IsNearEqual(FLinearColor A, FLinearColor B, float Tolerance);
    FLinearColor LinearColor_Green();
    FLinearColor LinearColor_Gray();
    float LinearColor_GetMin(FLinearColor InColor);
    float LinearColor_GetMax(FLinearColor InColor);
    float LinearColor_GetLuminance(FLinearColor InColor);
    float LinearColor_Distance(FLinearColor C1, FLinearColor C2);
    FLinearColor LinearColor_Desaturated(FLinearColor InColor, float InDesaturation);
    FLinearColor LinearColor_Blue();
    FLinearColor LinearColor_Black();
    FVector LessLess_VectorRotator(FVector A, FRotator B);
    bool LessEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool LessEqual_IntInt(int32 A, int32 B);
    bool LessEqual_Int64Int64(int64 A, int64 B);
    bool LessEqual_FloatFloat(float A, float B);
    bool LessEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool LessEqual_ByteByte(uint8 A, uint8 B);
    bool Less_TimespanTimespan(FTimespan A, FTimespan B);
    bool Less_IntInt(int32 A, int32 B);
    bool Less_Int64Int64(int64 A, int64 B);
    bool Less_FloatFloat(float A, float B);
    bool Less_DateTimeDateTime(FDateTime A, FDateTime B);
    bool Less_ByteByte(uint8 A, uint8 B);
    float Lerp(float A, float B, float Alpha);
    bool IsZero2D(const FVector2D& A);
    bool IsPointInBoxWithTransform(FVector Point, const FTransform& BoxWorldTransform, FVector BoxExtent);
    bool IsPointInBox(FVector Point, FVector BoxOrigin, FVector BoxExtent);
    bool IsNearlyZero2D(const FVector2D& A, float Tolerance);
    bool IsMorning(FDateTime A);
    bool IsLeapYear(int32 Year);
    bool IsAfternoon(FDateTime A);
    FTransform InvertTransform(const FTransform& T);
    FRotator InverseTransformRotation(const FTransform& T, FRotator Rotation);
    FVector InverseTransformLocation(const FTransform& T, FVector Location);
    FVector InverseTransformDirection(const FTransform& T, FVector Direction);
    FIntPoint IntPoint_Zero();
    FIntPoint IntPoint_Up();
    FIntPoint IntPoint_Right();
    FIntPoint IntPoint_One();
    FIntPoint IntPoint_Left();
    FIntPoint IntPoint_Down();
    bool InRange_IntInt(int32 Value, int32 Min, int32 Max, bool InclusiveMin, bool InclusiveMax);
    bool InRange_Int64Int64(int64 Value, int64 Min, int64 Max, bool InclusiveMin, bool InclusiveMax);
    bool InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax);
    float Hypotenuse(float Width, float Height);
    FLinearColor HSVToRGBLinear(FLinearColor HSV);
    void HSVToRGB_Vector(FLinearColor HSV, FLinearColor& RGB);
    FLinearColor HSVToRGB(float H, float S, float V, float A);
    float GridSnap_Float(float Location, float GridSize);
    FVector GreaterGreater_VectorRotator(FVector A, FRotator B);
    bool GreaterEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool GreaterEqual_IntInt(int32 A, int32 B);
    bool GreaterEqual_Int64Int64(int64 A, int64 B);
    bool GreaterEqual_FloatFloat(float A, float B);
    bool GreaterEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool GreaterEqual_ByteByte(uint8 A, uint8 B);
    bool Greater_TimespanTimespan(FTimespan A, FTimespan B);
    bool Greater_IntInt(int32 A, int32 B);
    bool Greater_Int64Int64(int64 A, int64 B);
    bool Greater_FloatFloat(float A, float B);
    bool Greater_DateTimeDateTime(FDateTime A, FDateTime B);
    bool Greater_ByteByte(uint8 A, uint8 B);
    int32 GetYear(FDateTime A);
    void GetYawPitchFromVector(FVector InVec, float& Yaw, float& Pitch);
    FVector GetVectorArrayAverage(const TArray<FVector>& Vectors);
    FVector GetUpVector(FRotator InRot);
    float GetTotalSeconds(FTimespan A);
    float GetTotalMinutes(FTimespan A);
    float GetTotalMilliseconds(FTimespan A);
    float GetTotalHours(FTimespan A);
    float GetTotalDays(FTimespan A);
    FTimespan GetTimeOfDay(FDateTime A);
    float GetTAU();
    void GetSlopeDegreeAngles(const FVector& MyRightYAxis, const FVector& FloorNormal, const FVector& UpVector, float& OutSlopePitchDegreeAngle, float& OutSlopeRollDegreeAngle);
    int32 GetSeconds(FTimespan A);
    int32 GetSecond(FDateTime A);
    FVector2D GetRotated2D(FVector2D A, float AngleDeg);
    FVector GetRightVector(FRotator InRot);
    FVector GetReflectionVector(FVector Direction, FVector SurfaceNormal);
    float GetPointDistanceToSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    float GetPointDistanceToLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    float GetPI();
    int32 GetMonth(FDateTime A);
    int32 GetMinutes(FTimespan A);
    int32 GetMinute(FDateTime A);
    float GetMinElement(FVector A);
    float GetMin2D(FVector2D A);
    int32 GetMilliseconds(FTimespan A);
    int32 GetMillisecond(FDateTime A);
    float GetMaxElement(FVector A);
    float GetMax2D(FVector2D A);
    int32 GetHours(FTimespan A);
    int32 GetHour12(FDateTime A);
    int32 GetHour(FDateTime A);
    FVector GetForwardVector(FRotator InRot);
    FTimespan GetDuration(FTimespan A);
    FVector GetDirectionUnitVector(FVector From, FVector To);
    int32 GetDays(FTimespan A);
    int32 GetDayOfYear(FDateTime A);
    int32 GetDay(FDateTime A);
    FDateTime GetDate(FDateTime A);
    void GetAzimuthAndElevation(FVector InDirection, const FTransform& ReferenceFrame, float& Azimuth, float& Elevation);
    void GetAxes(FRotator A, FVector& X, FVector& Y, FVector& Z);
    float GetAbsMax2D(FVector2D A);
    FVector2D GetAbs2D(FVector2D A);
    float FWrap(float Value, float Min, float Max);
    FIntVector FTruncVector(const FVector& InVector);
    int64 FTrunc64(float A);
    int32 FTrunc(float A);
    FTimespan FromSeconds(float Seconds);
    FTimespan FromMinutes(float Minutes);
    FTimespan FromMilliseconds(float MilliSeconds);
    FTimespan FromHours(float Hours);
    FTimespan FromDays(float Days);
    float Fraction(float A);
    int32 FMod(float Dividend, float Divisor, float& Remainder);
    float FMin(float A, float B);
    float FMax(float A, float B);
    float FloatSpringInterp(float Current, float Target, FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass);
    float FixedTurn(float InCurrent, float InDesired, float InDeltaRate);
    float FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed);
    float FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed);
    float FInterpEaseInOut(float A, float B, float Alpha, float Exponent);
    void FindNearestPointsOnLineSegments(FVector Segment1Start, FVector Segment1End, FVector Segment2Start, FVector Segment2End, FVector& Segment1Point, FVector& Segment2Point);
    FRotator FindLookAtRotation(const FVector& Start, const FVector& Target);
    FVector FindClosestPointOnSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    FVector FindClosestPointOnLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    int64 FFloor64(float A);
    int32 FFloor(float A);
    float FClamp(float Value, float Min, float Max);
    int64 FCeil64(float A);
    int32 FCeil(float A);
    float Exp(float A);
    bool EqualExactly_VectorVector(FVector A, FVector B);
    bool EqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    bool EqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    bool EqualEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    bool EqualEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    bool EqualEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    bool EqualEqual_TransformTransform(const FTransform& A, const FTransform& B);
    bool EqualEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool EqualEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    bool EqualEqual_QuatQuat(const FQuat& A, const FQuat& B, float Tolerance);
    bool EqualEqual_ObjectObject(class UObject* A, class UObject* B);
    bool EqualEqual_NameName(FName A, FName B);
    bool EqualEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    bool EqualEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    bool EqualEqual_IntInt(int32 A, int32 B);
    bool EqualEqual_Int64Int64(int64 A, int64 B);
    bool EqualEqual_FloatFloat(float A, float B);
    bool EqualEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool EqualEqual_ClassClass(UClass* A, UClass* B);
    bool EqualEqual_ByteByte(uint8 A, uint8 B);
    bool EqualEqual_BoolBool(bool A, bool B);
    bool Equal_IntPointIntPoint(FIntPoint A, FIntPoint B);
    float Ease(float A, float B, float Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    FVector DynamicWeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    FRotator DynamicWeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    float DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    float DotProduct2D(FVector2D A, FVector2D B);
    float Dot_VectorVector(FVector A, FVector B);
    FVector Divide_VectorVector(FVector A, FVector B);
    FVector Divide_VectorInt(FVector A, int32 B);
    FVector Divide_VectorFloat(FVector A, float B);
    FVector4 Divide_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Divide_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Divide_Vector2DFloat(FVector2D A, float B);
    FTimespan Divide_TimespanFloat(FTimespan A, float Scalar);
    FLinearColor Divide_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Divide_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Divide_IntPointInt(FIntPoint A, int32 B);
    int32 Divide_IntInt(int32 A, int32 B);
    int64 Divide_Int64Int64(int64 A, int64 B);
    float Divide_FloatFloat(float A, float B);
    uint8 Divide_ByteByte(uint8 A, uint8 B);
    float DistanceSquared2D(FVector2D v1, FVector2D v2);
    float Distance2D(FVector2D v1, FVector2D v2);
    float DegTan(float A);
    float DegSin(float A);
    float DegreesToRadians(float A);
    float DegCos(float A);
    float DegAtan2(float Y, float X);
    float DegAtan(float A);
    float DegAsin(float A);
    float DegAcos(float A);
    int32 DaysInYear(int32 Year);
    int32 DaysInMonth(int32 Year, int32 Month);
    FDateTime DateTimeMinValue();
    FDateTime DateTimeMaxValue();
    bool DateTimeFromString(FString DateTimeString, FDateTime& Result);
    bool DateTimeFromIsoString(FString IsoString, FDateTime& Result);
    float CrossProduct2D(FVector2D A, FVector2D B);
    FVector Cross_VectorVector(FVector A, FVector B);
    FVector CreateVectorFromYawPitch(float Yaw, float Pitch, float Length);
    float Cos(float A);
    FTransform ConvertTransformToRelative(const FTransform& Transform, const FTransform& ParentTransform);
    FVector2D Conv_VectorToVector2D(FVector InVector);
    FTransform Conv_VectorToTransform(FVector InLocation);
    FRotator Conv_VectorToRotator(FVector InVec);
    FQuat Conv_VectorToQuaternion(FVector InVec);
    FLinearColor Conv_VectorToLinearColor(FVector InVec);
    FVector Conv_Vector4ToVector(const FVector4& InVector4);
    FRotator Conv_Vector4ToRotator(const FVector4& InVec);
    FQuat Conv_Vector4ToQuaternion(const FVector4& InVec);
    FVector Conv_Vector2DToVector(FVector2D InVector2D, float Z);
    FIntPoint Conv_Vector2DToIntPoint(FVector2D InVector2D);
    FMatrix Conv_TransformToMatrix(const FTransform& Transform);
    FVector Conv_RotatorToVector(FRotator InRot);
    FTransform Conv_RotatorToTransform(const FRotator& InRotator);
    FTransform Conv_MatrixToTransform(const FMatrix& InMatrix);
    FRotator Conv_MatrixToRotator(const FMatrix& InMatrix);
    FVector Conv_LinearColorToVector(FLinearColor InLinearColor);
    FColor Conv_LinearColorToColor(FLinearColor InLinearColor, bool InUseSRGB);
    FVector Conv_IntVectorToVector(const FIntVector& InIntVector);
    FIntVector Conv_IntToIntVector(int32 inInt);
    int64 Conv_IntToInt64(int32 inInt);
    float Conv_IntToFloat(int32 inInt);
    uint8 Conv_IntToByte(int32 inInt);
    bool Conv_IntToBool(int32 inInt);
    FVector2D Conv_IntPointToVector2D(FIntPoint InIntPoint);
    int32 Conv_Int64ToInt(int64 inInt);
    uint8 Conv_Int64ToByte(int64 inInt);
    FVector Conv_FloatToVector(float InFloat);
    FLinearColor Conv_FloatToLinearColor(float InFloat);
    FLinearColor Conv_ColorToLinearColor(FColor InColor);
    int32 Conv_ByteToInt(uint8 InByte);
    float Conv_ByteToFloat(uint8 InByte);
    int32 Conv_BoolToInt(bool InBool);
    float Conv_BoolToFloat(bool InBool);
    uint8 Conv_BoolToByte(bool InBool);
    FTransform ComposeTransforms(const FTransform& A, const FTransform& B);
    FRotator ComposeRotators(FRotator A, FRotator B);
    bool ClassIsChildOf(UClass* TestClass, UClass* ParentClass);
    FVector ClampVectorSize(FVector A, float Min, float Max);
    int64 ClampInt64(int64 Value, int64 Min, int64 Max);
    float ClampAxis(float Angle);
    FVector2D ClampAxes2D(FVector2D A, float MinAxisVal, float MaxAxisVal);
    float ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees);
    int32 Clamp(int32 Value, int32 Min, int32 Max);
    FLinearColor CInterpTo(FLinearColor Current, FLinearColor Target, float DeltaTime, float InterpSpeed);
    void BreakVector4(const FVector4& InVec, float& X, float& Y, float& Z, float& W);
    void BreakVector2D(FVector2D InVec, float& X, float& Y);
    void BreakVector(FVector InVec, float& X, float& Y, float& Z);
    void BreakTransform(const FTransform& InTransform, FVector& Location, FRotator& Rotation, FVector& Scale);
    void BreakTimespan2(FTimespan InTimespan, int32& Days, int32& Hours, int32& Minutes, int32& Seconds, int32& FractionNano);
    void BreakTimespan(FTimespan InTimespan, int32& Days, int32& Hours, int32& Minutes, int32& Seconds, int32& MilliSeconds);
    void BreakRotIntoAxes(const FRotator& InRot, FVector& X, FVector& Y, FVector& Z);
    void BreakRotator(FRotator InRot, float& Roll, float& Pitch, float& Yaw);
    void BreakRandomStream(const FRandomStream& InRandomStream, int32& InitialSeed);
    void BreakQualifiedFrameTime(const FQualifiedFrameTime& InFrameTime, FFrameNumber& Frame, FFrameRate& FrameRate, float& SubFrame);
    void BreakFrameRate(const FFrameRate& InFrameRate, int32& Numerator, int32& Denominator);
    void BreakDateTime(FDateTime InDateTime, int32& Year, int32& Month, int32& Day, int32& Hour, int32& Minute, int32& Second, int32& Millisecond);
    void BreakColor(FLinearColor InColor, float& R, float& G, float& B, float& A);
    bool BooleanXOR(bool A, bool B);
    bool BooleanOR(bool A, bool B);
    bool BooleanNOR(bool A, bool B);
    bool BooleanNAND(bool A, bool B);
    bool BooleanAND(bool A, bool B);
    uint8 BMin(uint8 A, uint8 B);
    uint8 BMax(uint8 A, uint8 B);
    float Atan2(float Y, float X);
    float Atan(float A);
    float Asin(float A);
    int32 And_IntInt(int32 A, int32 B);
    int64 And_Int64Int64(int64 A, int64 B);
    FVector Add_VectorVector(FVector A, FVector B);
    FVector Add_VectorInt(FVector A, int32 B);
    FVector Add_VectorFloat(FVector A, float B);
    FVector4 Add_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Add_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Add_Vector2DFloat(FVector2D A, float B);
    FTimespan Add_TimespanTimespan(FTimespan A, FTimespan B);
    FQuat Add_QuatQuat(const FQuat& A, const FQuat& B);
    FMatrix Add_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    FLinearColor Add_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Add_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Add_IntPointInt(FIntPoint A, int32 B);
    int32 Add_IntInt(int32 A, int32 B);
    int64 Add_Int64Int64(int64 A, int64 B);
    float Add_FloatFloat(float A, float B);
    FDateTime Add_DateTimeTimespan(FDateTime A, FTimespan B);
    FDateTime Add_DateTimeDateTime(FDateTime A, FDateTime B);
    uint8 Add_ByteByte(uint8 A, uint8 B);
    float Acos(float A);
    int64 Abs_Int64(int64 A);
    int32 Abs_Int(int32 A);
    float Abs(float A);
}; // Size: 0x28

class UKismetNodeHelperLibrary : public UBlueprintFunctionLibrary
{

    void MarkBit(int32& Data, int32 Index);
    bool HasUnmarkedBit(int32 Data, int32 NumBits);
    bool HasMarkedBit(int32 Data, int32 NumBits);
    uint8 GetValidValue(const class UEnum* Enum, uint8 EnumeratorValue);
    int32 GetUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits, bool bRandom);
    int32 GetRandomUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
    int32 GetFirstUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
    uint8 GetEnumeratorValueFromIndex(const class UEnum* Enum, uint8 EnumeratorIndex);
    FString GetEnumeratorUserFriendlyName(const class UEnum* Enum, uint8 EnumeratorValue);
    FName GetEnumeratorName(const class UEnum* Enum, uint8 EnumeratorValue);
    void ClearBit(int32& Data, int32 Index);
    void ClearAllBits(int32& Data);
    bool BitIsMarked(int32 Data, int32 Index);
}; // Size: 0x28

struct FDrawToRenderTargetContext
{
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x0000 (size: 0x8)

}; // Size: 0x10

class UKismetRenderingLibrary : public UBlueprintFunctionLibrary
{

    void SetCastInsetShadowForAllAttachments(class UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup);
    class UTexture2D* RenderTargetCreateStaticTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, FString Name, TEnumAsByte<TextureCompressionSettings> CompressionSettings, TEnumAsByte<TextureMipGenSettings> MipSettings);
    void ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget);
    FColor ReadRenderTargetUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V);
    FLinearColor ReadRenderTargetRawUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V);
    FLinearColor ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y);
    FColor ReadRenderTargetPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y);
    FSkelMeshSkinWeightInfo MakeSkinWeightInfo(int32 Bone0, uint8 Weight0, int32 Bone1, uint8 Weight1, int32 Bone2, uint8 Weight2, int32 Bone3, uint8 Weight3);
    class UTexture2D* ImportFileAsTexture2D(class UObject* WorldContextObject, FString Filename);
    class UTexture2D* ImportBufferAsTexture2D(class UObject* WorldContextObject, const TArray<uint8>& Buffer);
    void ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, FString FilePath, FString Filename);
    void ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, FString FilePath, FString Filename);
    void EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const FDrawToRenderTargetContext& Context);
    void DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material);
    class UTextureRenderTargetVolume* CreateRenderTargetVolume(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Depth, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    class UTextureRenderTarget2DArray* CreateRenderTarget2DArray(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Slices, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    class UTextureRenderTarget2D* CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps);
    void ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture);
    void ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, FLinearColor ClearColor);
    void BreakSkinWeightInfo(FSkelMeshSkinWeightInfo InWeight, int32& Bone0, uint8& Weight0, int32& Bone1, uint8& Weight1, int32& Bone2, uint8& Weight2, int32& Bone3, uint8& Weight3);
    void BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas*& Canvas, FVector2D& Size, FDrawToRenderTargetContext& Context);
}; // Size: 0x28

class UKismetStringLibrary : public UBlueprintFunctionLibrary
{

    FString TrimTrailing(FString SourceString);
    FString Trim(FString SourceString);
    FString ToUpper(FString SourceString);
    FString ToLower(FString SourceString);
    FString TimeSecondsToString(float InSeconds);
    bool StartsWith(FString SourceString, FString InPrefix, TEnumAsByte<ESearchCase::Type> SearchCase);
    bool Split(FString SourceString, FString InStr, FString& LeftS, FString& RightS, TEnumAsByte<ESearchCase::Type> SearchCase, TEnumAsByte<ESearchDir::Type> SearchDir);
    FString RightPad(FString SourceString, int32 ChCount);
    FString RightChop(FString SourceString, int32 Count);
    FString Right(FString SourceString, int32 Count);
    FString Reverse(FString SourceString);
    int32 ReplaceInline(FString& SourceString, FString SearchText, FString ReplacementText, TEnumAsByte<ESearchCase::Type> SearchCase);
    FString Replace(FString SourceString, FString From, FString To, TEnumAsByte<ESearchCase::Type> SearchCase);
    TArray<FString> ParseIntoArray(FString SourceString, FString Delimiter, const bool CullEmptyStrings);
    bool NotEqual_StrStr(FString A, FString B);
    bool NotEqual_StriStri(FString A, FString B);
    FString Mid(FString SourceString, int32 Start, int32 Count);
    bool MatchesWildcard(FString SourceString, FString Wildcard, TEnumAsByte<ESearchCase::Type> SearchCase);
    int32 Len(FString S);
    FString LeftPad(FString SourceString, int32 ChCount);
    FString LeftChop(FString SourceString, int32 Count);
    FString Left(FString SourceString, int32 Count);
    FString JoinStringArray(const TArray<FString>& SourceArray, FString Separator);
    bool IsNumeric(FString SourceString);
    bool IsEmpty(FString inString);
    FString GetSubstring(FString SourceString, int32 StartIndex, int32 Length);
    int32 GetCharacterAsNumber(FString SourceString, int32 Index);
    TArray<FString> GetCharacterArrayFromString(FString SourceString);
    int32 FindSubstring(FString SearchIn, FString SubString, bool bUseCase, bool bSearchFromEnd, int32 StartPosition);
    bool EqualEqual_StrStr(FString A, FString B);
    bool EqualEqual_StriStri(FString A, FString B);
    bool EndsWith(FString SourceString, FString InSuffix, TEnumAsByte<ESearchCase::Type> SearchCase);
    int32 CullArray(FString SourceString, TArray<FString>& inArray);
    FString Conv_VectorToString(FVector InVec);
    FString Conv_Vector2dToString(FVector2D InVec);
    FString Conv_TransformToString(const FTransform& InTrans);
    void Conv_StringToVector2D(FString inString, FVector2D& OutConvertedVector2D, bool& OutIsValid);
    void Conv_StringToVector(FString inString, FVector& OutConvertedVector, bool& OutIsValid);
    void Conv_StringToRotator(FString inString, FRotator& OutConvertedRotator, bool& OutIsValid);
    FName Conv_StringToName(FString inString);
    int32 Conv_StringToInt(FString inString);
    float Conv_StringToFloat(FString inString);
    void Conv_StringToColor(FString inString, FLinearColor& OutConvertedColor, bool& OutIsValid);
    FString Conv_RotatorToString(FRotator InRot);
    FString Conv_ObjectToString(class UObject* InObj);
    FString Conv_NameToString(FName InName);
    FString Conv_MatrixToString(const FMatrix& InMatrix);
    FString Conv_IntVectorToString(FIntVector InIntVec);
    FString Conv_IntToString(int32 inInt);
    FString Conv_IntPointToString(FIntPoint InIntPoint);
    FString Conv_FloatToString(float InFloat);
    FString Conv_ColorToString(FLinearColor InColor);
    FString Conv_ByteToString(uint8 InByte);
    FString Conv_BoolToString(bool InBool);
    bool Contains(FString SearchIn, FString SubString, bool bUseCase, bool bSearchFromEnd);
    FString Concat_StrStr(FString A, FString B);
    FString BuildString_Vector2d(FString AppendTo, FString Prefix, FVector2D InVector2D, FString Suffix);
    FString BuildString_Vector(FString AppendTo, FString Prefix, FVector InVector, FString Suffix);
    FString BuildString_Rotator(FString AppendTo, FString Prefix, FRotator InRot, FString Suffix);
    FString BuildString_Object(FString AppendTo, FString Prefix, class UObject* InObj, FString Suffix);
    FString BuildString_Name(FString AppendTo, FString Prefix, FName InName, FString Suffix);
    FString BuildString_IntVector(FString AppendTo, FString Prefix, FIntVector InIntVector, FString Suffix);
    FString BuildString_Int(FString AppendTo, FString Prefix, int32 inInt, FString Suffix);
    FString BuildString_Float(FString AppendTo, FString Prefix, float InFloat, FString Suffix);
    FString BuildString_Color(FString AppendTo, FString Prefix, FLinearColor InColor, FString Suffix);
    FString BuildString_Bool(FString AppendTo, FString Prefix, bool InBool, FString Suffix);
}; // Size: 0x28

class UKismetStringTableLibrary : public UBlueprintFunctionLibrary
{

    bool IsRegisteredTableId(const FName TableId);
    bool IsRegisteredTableEntry(const FName TableId, FString Key);
    FString GetTableNamespace(const FName TableId);
    FString GetTableEntrySourceString(const FName TableId, FString Key);
    FString GetTableEntryMetaData(const FName TableId, FString Key, const FName MetaDataId);
    TArray<FName> GetRegisteredStringTables();
    TArray<FName> GetMetaDataIdsFromStringTableEntry(const FName TableId, FString Key);
    TArray<FString> GetKeysFromStringTable(const FName TableId);
}; // Size: 0x28

struct FUserActivity
{
    FString ActionName;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FGenericStruct
{
    int32 Data;                                                                       // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FDebugFloatHistory
{
    TArray<float> Samples;                                                            // 0x0000 (size: 0x10)
    float MaxSamples;                                                                 // 0x0010 (size: 0x4)
    float MinValue;                                                                   // 0x0014 (size: 0x4)
    float MaxValue;                                                                   // 0x0018 (size: 0x4)
    bool bAutoAdjustMinMax;                                                           // 0x001C (size: 0x1)

}; // Size: 0x20

class UKismetSystemLibrary : public UBlueprintFunctionLibrary
{

    void UnregisterForRemoteNotifications();
    void UnloadPrimaryAssetList(const TArray<FPrimaryAssetId>& PrimaryAssetIdList);
    void UnloadPrimaryAsset(FPrimaryAssetId PrimaryAssetId);
    void TransactObject(class UObject* Object);
    void StackTrace();
    bool SphereTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereOverlapComponents(const class UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool SphereOverlapActors(const class UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    void SnapshotObject(class UObject* Object);
    void ShowPlatformSpecificLeaderboardScreen(FString CategoryName);
    void ShowPlatformSpecificAchievementsScreen(const class APlayerController* SpecificPlayer);
    void ShowInterstitialAd();
    void ShowAdBanner(int32 AdIdIndex, bool bShowOnBottomOfScreen);
    void SetWindowTitle(const FText& Title);
    void SetVolumeButtonsHandledBySystem(bool bEnabled);
    void SetVectorPropertyByName(class UObject* Object, FName PropertyName, const FVector& Value);
    void SetUserActivity(const FUserActivity& UserActivity);
    void SetTransformPropertyByName(class UObject* Object, FName PropertyName, const FTransform& Value);
    void SetTextPropertyByName(class UObject* Object, FName PropertyName, const FText& Value);
    void SetSuppressViewportTransitionMessage(const class UObject* WorldContextObject, bool bState);
    void SetStructurePropertyByName(class UObject* Object, FName PropertyName, const FGenericStruct& Value);
    void SetStringPropertyByName(class UObject* Object, FName PropertyName, FString Value);
    void SetSoftObjectPropertyByName(class UObject* Object, FName PropertyName, const TSoftObjectPtr<UObject>& Value);
    void SetSoftClassPropertyByName(class UObject* Object, FName PropertyName, const TSoftClassPtr<UObject>& Value);
    void SetRotatorPropertyByName(class UObject* Object, FName PropertyName, const FRotator& Value);
    void SetObjectPropertyByName(class UObject* Object, FName PropertyName, class UObject* Value);
    void SetNamePropertyByName(class UObject* Object, FName PropertyName, const FName& Value);
    void SetLinearColorPropertyByName(class UObject* Object, FName PropertyName, const FLinearColor& Value);
    void SetIntPropertyByName(class UObject* Object, FName PropertyName, int32 Value);
    void SetInterfacePropertyByName(class UObject* Object, FName PropertyName, const FScriptInterface& Value);
    void SetInt64PropertyByName(class UObject* Object, FName PropertyName, int64 Value);
    void SetGamepadsBlockDeviceFeedback(bool bBlock);
    void SetFloatPropertyByName(class UObject* Object, FName PropertyName, float Value);
    void SetFieldPathPropertyByName(class UObject* Object, FName PropertyName, const TFieldPath<FField>& Value);
    void SetColorPropertyByName(class UObject* Object, FName PropertyName, const FColor& Value);
    void SetCollisionProfileNameProperty(class UObject* Object, FName PropertyName, const FCollisionProfileName& Value);
    void SetClassPropertyByName(class UObject* Object, FName PropertyName, UClass* Value);
    void SetBytePropertyByName(class UObject* Object, FName PropertyName, uint8 Value);
    void SetBoolPropertyByName(class UObject* Object, FName PropertyName, bool Value);
    void RetriggerableDelay(const class UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    void ResetGamepadAssignmentToController(int32 ControllerId);
    void ResetGamepadAssignments();
    void RegisterForRemoteNotifications();
    void QuitGame(const class UObject* WorldContextObject, class APlayerController* SpecificPlayer, TEnumAsByte<EQuitPreference::Type> QuitPreference, bool bIgnorePlatformRestrictions);
    void PrintWarning(FString inString);
    void PrintText(const class UObject* WorldContextObject, const FText InText, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    void PrintString(const class UObject* WorldContextObject, FString inString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration);
    bool ParseParamValue(FString inString, FString InParam, FString& OutValue);
    bool ParseParam(FString inString, FString InParam);
    void ParseCommandLine(FString InCmdLine, TArray<FString>& OutTokens, TArray<FString>& OutSwitches, TMap<class FString, class FString>& OutParams);
    void OnAssetLoaded__DelegateSignature(class UObject* Loaded);
    void OnAssetClassLoaded__DelegateSignature(UClass* Loaded);
    bool NotEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    bool NotEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    bool NotEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    bool NotEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    FString NormalizeFilename(FString InFilename);
    void MoveComponentTo(class USceneComponent* Component, FVector TargetRelativeLocation, FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, TEnumAsByte<EMoveComponentAction::Type> MoveAction, FLatentActionInfo LatentInfo);
    FSoftObjectPath MakeSoftObjectPath(FString PathString);
    FSoftClassPath MakeSoftClassPath(FString PathString);
    FText MakeLiteralText(FText Value);
    FString MakeLiteralString(FString Value);
    FName MakeLiteralName(FName Value);
    int32 MakeLiteralInt(int32 Value);
    float MakeLiteralFloat(float Value);
    uint8 MakeLiteralByte(uint8 Value);
    bool MakeLiteralBool(bool Value);
    void LoadInterstitialAd(int32 AdIdIndex);
    UClass* LoadClassAsset_Blocking(TSoftClassPtr<UObject> AssetClass);
    void LoadAssetClass(const class UObject* WorldContextObject, TSoftClassPtr<UObject> AssetClass, FLoadAssetClassOnLoaded OnLoaded, FLatentActionInfo LatentInfo);
    class UObject* LoadAsset_Blocking(TSoftObjectPtr<UObject> Asset);
    void LoadAsset(const class UObject* WorldContextObject, TSoftObjectPtr<UObject> Asset, FLoadAssetOnLoaded OnLoaded, FLatentActionInfo LatentInfo);
    bool LineTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    void LaunchURL(FString URL);
    void K2_UnPauseTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_UnPauseTimerDelegate(FK2_UnPauseTimerDelegateDelegate Delegate);
    void K2_UnPauseTimer(class UObject* Object, FString FunctionName);
    bool K2_TimerExistsHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_TimerExistsDelegate(FK2_TimerExistsDelegateDelegate Delegate);
    bool K2_TimerExists(class UObject* Object, FString FunctionName);
    FTimerHandle K2_SetTimerDelegate(FK2_SetTimerDelegateDelegate Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
    FTimerHandle K2_SetTimer(class UObject* Object, FString FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance);
    void K2_PauseTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_PauseTimerDelegate(FK2_PauseTimerDelegateDelegate Delegate);
    void K2_PauseTimer(class UObject* Object, FString FunctionName);
    bool K2_IsValidTimerHandle(FTimerHandle Handle);
    bool K2_IsTimerPausedHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_IsTimerPausedDelegate(FK2_IsTimerPausedDelegateDelegate Delegate);
    bool K2_IsTimerPaused(class UObject* Object, FString FunctionName);
    bool K2_IsTimerActiveHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_IsTimerActiveDelegate(FK2_IsTimerActiveDelegateDelegate Delegate);
    bool K2_IsTimerActive(class UObject* Object, FString FunctionName);
    FTimerHandle K2_InvalidateTimerHandle(FTimerHandle& Handle);
    float K2_GetTimerRemainingTimeHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    float K2_GetTimerRemainingTimeDelegate(FK2_GetTimerRemainingTimeDelegateDelegate Delegate);
    float K2_GetTimerRemainingTime(class UObject* Object, FString FunctionName);
    float K2_GetTimerElapsedTimeHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    float K2_GetTimerElapsedTimeDelegate(FK2_GetTimerElapsedTimeDelegateDelegate Delegate);
    float K2_GetTimerElapsedTime(class UObject* Object, FString FunctionName);
    void K2_ClearTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_ClearTimerDelegate(FK2_ClearTimerDelegateDelegate Delegate);
    void K2_ClearTimer(class UObject* Object, FString FunctionName);
    void K2_ClearAndInvalidateTimerHandle(const class UObject* WorldContextObject, FTimerHandle& Handle);
    bool IsValidSoftObjectReference(const TSoftObjectPtr<UObject>& SoftObjectReference);
    bool IsValidSoftClassReference(const TSoftClassPtr<UObject>& SoftClassReference);
    bool IsValidPrimaryAssetType(FPrimaryAssetType PrimaryAssetType);
    bool IsValidPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    bool IsValidClass(UClass* Class);
    bool IsValid(const class UObject* Object);
    bool IsUnattended();
    bool IsStandAlone(const class UObject* WorldContextObject);
    bool IsSplitScreen(const class UObject* WorldContextObject);
    bool IsServer(const class UObject* WorldContextObject);
    bool IsScreensaverEnabled();
    bool IsPackagedForDistribution();
    bool IsLoggedIn(const class APlayerController* SpecificPlayer);
    bool IsInterstitialAdRequested();
    bool IsInterstitialAdAvailable();
    bool IsDedicatedServer(const class UObject* WorldContextObject);
    bool IsControllerAssignedToGamepad(int32 ControllerId);
    void HideAdBanner();
    bool GetVolumeButtonsHandledBySystem();
    FString GetUniqueDeviceId();
    FString GetSystemPath(const class UObject* Object);
    bool GetSupportedFullscreenResolutions(TArray<FIntPoint>& Resolutions);
    TSoftObjectPtr<UObject> GetSoftObjectReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    TSoftClassPtr<UObject> GetSoftClassReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    int32 GetRenderingMaterialQualityLevel();
    int32 GetRenderingDetailMode();
    FString GetProjectSavedDirectory();
    FString GetProjectDirectory();
    FString GetProjectContentDirectory();
    void GetPrimaryAssetsWithBundleState(const TArray<FName>& RequiredBundles, const TArray<FName>& ExcludedBundles, const TArray<FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    void GetPrimaryAssetIdList(FPrimaryAssetType PrimaryAssetType, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    FPrimaryAssetId GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<UObject> SoftObjectReference);
    FPrimaryAssetId GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<UObject> SoftClassReference);
    FPrimaryAssetId GetPrimaryAssetIdFromObject(class UObject* Object);
    FPrimaryAssetId GetPrimaryAssetIdFromClass(UClass* Class);
    TArray<FString> GetPreferredLanguages();
    FString GetPlatformUserName();
    FString GetPlatformUserDir();
    FString GetPathName(const class UObject* Object);
    class UObject* GetOuterObject(const class UObject* Object);
    FString GetObjectName(const class UObject* Object);
    class UObject* GetObjectFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    int32 GetMinYResolutionForUI();
    int32 GetMinYResolutionFor3DView();
    FString GetLocalCurrencySymbol();
    FString GetLocalCurrencyCode();
    float GetGameTimeInSeconds(const class UObject* WorldContextObject);
    FString GetGamepadControllerName(int32 ControllerId);
    class UTexture2D* GetGamepadButtonGlyph(FString ButtonKey, int32 ControllerIndex);
    FString GetGameName();
    FString GetGameBundleId();
    int64 GetFrameCount();
    FString GetEngineVersion();
    FString GetDisplayName(const class UObject* Object);
    FString GetDeviceId();
    FString GetDefaultLocale();
    FString GetDefaultLanguage();
    bool GetCurrentBundleState(FPrimaryAssetId PrimaryAssetId, bool bForceCurrentState, TArray<FName>& OutBundles);
    bool GetConvenientWindowedResolutions(TArray<FIntPoint>& Resolutions);
    int32 GetConsoleVariableIntValue(FString VariableName);
    float GetConsoleVariableFloatValue(FString VariableName);
    bool GetConsoleVariableBoolValue(FString VariableName);
    void GetComponentBounds(const class USceneComponent* Component, FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    FString GetCommandLine();
    UClass* GetClassFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    FString GetClassDisplayName(UClass* Class);
    int32 GetAdIDCount();
    void GetActorListFromComponentList(const TArray<class UPrimitiveComponent*>& ComponentList, UClass* ActorClassFilter, TArray<class AActor*>& OutActorList);
    void GetActorBounds(const class AActor* Actor, FVector& Origin, FVector& BoxExtent);
    void ForceCloseAdBanner();
    void FlushPersistentDebugLines(const class UObject* WorldContextObject);
    void FlushDebugStrings(const class UObject* WorldContextObject);
    void ExecuteConsoleCommand(const class UObject* WorldContextObject, FString Command, class APlayerController* SpecificPlayer);
    bool EqualEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    bool EqualEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    bool EqualEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    bool EqualEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    int32 EndTransaction();
    void DrawDebugString(const class UObject* WorldContextObject, const FVector TextLocation, FString Text, class AActor* TestBaseActor, FLinearColor TextColor, float Duration);
    void DrawDebugSphere(const class UObject* WorldContextObject, const FVector Center, float Radius, int32 Segments, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugPoint(const class UObject* WorldContextObject, const FVector Position, float Size, FLinearColor PointColor, float Duration);
    void DrawDebugPlane(const class UObject* WorldContextObject, const FPlane& PlaneCoordinates, const FVector Location, float Size, FLinearColor PlaneColor, float Duration);
    void DrawDebugLine(const class UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugFrustum(const class UObject* WorldContextObject, const FTransform& FrustumTransform, FLinearColor FrustumColor, float Duration, float Thickness);
    void DrawDebugFloatHistoryTransform(const class UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, const FTransform& DrawTransform, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    void DrawDebugFloatHistoryLocation(const class UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, FVector DrawLocation, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    void DrawDebugCylinder(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, int32 Segments, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCoordinateSystem(const class UObject* WorldContextObject, const FVector AxisLoc, const FRotator AxisRot, float Scale, float Duration, float Thickness);
    void DrawDebugConeInDegrees(const class UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCone(const class UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCircle(const class UObject* WorldContextObject, FVector Center, float Radius, int32 NumSegments, FLinearColor LineColor, float Duration, float Thickness, FVector YAxis, FVector ZAxis, bool bDrawAxis);
    void DrawDebugCapsule(const class UObject* WorldContextObject, const FVector Center, float HalfHeight, float Radius, const FRotator Rotation, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCamera(const class ACameraActor* CameraActor, FLinearColor CameraColor, float Duration);
    void DrawDebugBox(const class UObject* WorldContextObject, const FVector Center, FVector Extent, FLinearColor LineColor, const FRotator Rotation, float Duration, float Thickness);
    void DrawDebugArrow(const class UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor LineColor, float Duration, float Thickness);
    bool DoesImplementInterface(const class UObject* TestObject, TSubclassOf<class UInterface> Interface);
    void Delay(const class UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    void CreateCopyForUndoBuffer(class UObject* ObjectToModify);
    FString ConvertToRelativePath(FString Filename);
    FString ConvertToAbsolutePath(FString Filename);
    TSoftObjectPtr<UObject> Conv_SoftObjPathToSoftObjRef(const FSoftObjectPath& SoftObjectPath);
    FString Conv_SoftObjectReferenceToString(const TSoftObjectPtr<UObject>& SoftObjectReference);
    class UObject* Conv_SoftObjectReferenceToObject(const TSoftObjectPtr<UObject>& SoftObject);
    FString Conv_SoftClassReferenceToString(const TSoftClassPtr<UObject>& SoftClassReference);
    UClass* Conv_SoftClassReferenceToClass(const TSoftClassPtr<UObject>& SoftClass);
    TSoftClassPtr<UObject> Conv_SoftClassPathToSoftClassRef(const FSoftClassPath& SoftClassPath);
    FString Conv_PrimaryAssetTypeToString(FPrimaryAssetType PrimaryAssetType);
    FString Conv_PrimaryAssetIdToString(FPrimaryAssetId PrimaryAssetId);
    TSoftObjectPtr<UObject> Conv_ObjectToSoftObjectReference(class UObject* Object);
    class UObject* Conv_InterfaceToObject(const FScriptInterface& Interface);
    TSoftClassPtr<UObject> Conv_ClassToSoftClassReference(const UClass*& Class);
    void ControlScreensaver(bool bAllowScreenSaver);
    bool ComponentOverlapComponents(class UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool ComponentOverlapActors(class UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    void CollectGarbage();
    bool CapsuleTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleOverlapComponents(const class UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool CapsuleOverlapActors(const class UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    bool CanLaunchURL(FString URL);
    void CancelTransaction(const int32 Index);
    void BreakSoftObjectPath(FSoftObjectPath InSoftObjectPath, FString& PathString);
    void BreakSoftClassPath(FSoftClassPath InSoftClassPath, FString& PathString);
    bool BoxTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxOverlapComponents(const class UObject* WorldContextObject, const FVector BoxPos, FVector Extent, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool BoxOverlapActors(const class UObject* WorldContextObject, const FVector BoxPos, FVector BoxExtent, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    int32 BeginTransaction(FString Context, FText Description, class UObject* PrimaryObject);
    FDebugFloatHistory AddFloatHistorySample(float Value, const FDebugFloatHistory& FloatHistory);
}; // Size: 0x28

struct FFormatArgumentData
{
    FString ArgumentName;                                                             // 0x0000 (size: 0x10)
    TEnumAsByte<EFormatArgumentType::Type> ArgumentValueType;                         // 0x0010 (size: 0x1)
    FText ArgumentValue;                                                              // 0x0018 (size: 0x18)
    int32 ArgumentValueInt;                                                           // 0x0030 (size: 0x4)
    float ArgumentValueFloat;                                                         // 0x0034 (size: 0x4)
    ETextGender ArgumentValueGender;                                                  // 0x0038 (size: 0x1)

}; // Size: 0x40

class UKismetTextLibrary : public UBlueprintFunctionLibrary
{

    FText TextTrimTrailing(const FText& InText);
    FText TextTrimPrecedingAndTrailing(const FText& InText);
    FText TextTrimPreceding(const FText& InText);
    FText TextToUpper(const FText& InText);
    FText TextToLower(const FText& InText);
    bool TextIsTransient(const FText& InText);
    bool TextIsFromStringTable(const FText& Text);
    bool TextIsEmpty(const FText& InText);
    bool TextIsCultureInvariant(const FText& InText);
    FText TextFromStringTable(const FName TableId, FString Key);
    bool StringTableIdAndKeyFromText(FText Text, FName& OutTableId, FString& OutKey);
    FText PolyglotDataToText(const FPolyglotTextData& PolyglotData);
    bool NotEqual_TextText(const FText& A, const FText& B);
    bool NotEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    void IsPolyglotDataValid(const FPolyglotTextData& PolyglotData, bool& IsValid, FText& ErrorMessage);
    FText GetEmptyText();
    FText Format(FText InPattern, TArray<FFormatArgumentData> InArgs);
    bool FindTextInLocalizationTable(FString Namespace, FString Key, FText& OutText);
    bool EqualEqual_TextText(const FText& A, const FText& B);
    bool EqualEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    FText Conv_VectorToText(FVector InVec);
    FText Conv_Vector2dToText(FVector2D InVec);
    FText Conv_TransformToText(const FTransform& InTrans);
    FString Conv_TextToString(const FText& InText);
    FText Conv_StringToText(FString inString);
    FText Conv_RotatorToText(FRotator InRot);
    FText Conv_ObjectToText(class UObject* InObj);
    FText Conv_NameToText(FName InName);
    FText Conv_IntToText(int32 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
    FText Conv_Int64ToText(int64 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
    FText Conv_FloatToText(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
    FText Conv_ColorToText(FLinearColor InColor);
    FText Conv_ByteToText(uint8 Value);
    FText Conv_BoolToText(bool InBool);
    FText AsTimeZoneTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimeZoneDateTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimeZoneDate_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimespan_Timespan(const FTimespan& InTimespan);
    FText AsTime_DateTime(const FDateTime& In);
    FText AsPercent_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
    FText AsDateTime_DateTime(const FDateTime& In);
    FText AsDate_DateTime(const FDateTime& InDateTime);
    FText AsCurrencyBase(int32 BaseValue, FString CurrencyCode);
    FText AsCurrency_Integer(int32 Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, FString CurrencyCode);
    FText AsCurrency_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, FString CurrencyCode);
}; // Size: 0x28

struct FLayerActorStats
{
    UClass* Type;                                                                     // 0x0000 (size: 0x8)
    int32 Total;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0x10

class ULayer : public UObject
{
    FName LayerName;                                                                  // 0x0028 (size: 0x8)
    uint8 bIsVisible;                                                                 // 0x0030 (size: 0x1)
    TArray<FLayerActorStats> ActorStats;                                              // 0x0038 (size: 0x10)

}; // Size: 0x48

class ILevelPartitionInterface : public IInterface
{
}; // Size: 0x28

struct FReplicatedStaticActorDestructionInfo
{
    UClass* ObjClass;                                                                 // 0x0030 (size: 0x8)

}; // Size: 0x38

class ULevel : public UObject
{
    class UWorld* OwningWorld;                                                        // 0x00B8 (size: 0x8)
    class UModel* Model;                                                              // 0x00C0 (size: 0x8)
    TArray<class UModelComponent*> ModelComponents;                                   // 0x00C8 (size: 0x10)
    class ULevelActorContainer* ActorCluster;                                         // 0x00D8 (size: 0x8)
    int32 NumTextureStreamingUnbuiltComponents;                                       // 0x00E0 (size: 0x4)
    int32 NumTextureStreamingDirtyResources;                                          // 0x00E4 (size: 0x4)
    class ALevelScriptActor* LevelScriptActor;                                        // 0x00E8 (size: 0x8)
    class ANavigationObjectBase* NavListStart;                                        // 0x00F0 (size: 0x8)
    class ANavigationObjectBase* NavListEnd;                                          // 0x00F8 (size: 0x8)
    TArray<class UNavigationDataChunk*> NavDataChunks;                                // 0x0100 (size: 0x10)
    float LightmapTotalSize;                                                          // 0x0110 (size: 0x4)
    float ShadowmapTotalSize;                                                         // 0x0114 (size: 0x4)
    TArray<FVector> StaticNavigableGeometry;                                          // 0x0118 (size: 0x10)
    TArray<FGuid> StreamingTextureGuids;                                              // 0x0128 (size: 0x10)
    FGuid LevelBuildDataId;                                                           // 0x01D0 (size: 0x10)
    class UMapBuildDataRegistry* MapBuildData;                                        // 0x01E0 (size: 0x8)
    FIntVector LightBuildLevelOffset;                                                 // 0x01E8 (size: 0xC)
    uint8 bIsLightingScenario;                                                        // 0x01F4 (size: 0x1)
    uint8 bTextureStreamingRotationChanged;                                           // 0x01F4 (size: 0x1)
    uint8 bStaticComponentsRegisteredInStreamingManager;                              // 0x01F4 (size: 0x1)
    uint8 bIsVisible;                                                                 // 0x01F4 (size: 0x1)
    class AWorldSettings* WorldSettings;                                              // 0x0258 (size: 0x8)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0268 (size: 0x10)
    TArray<FReplicatedStaticActorDestructionInfo> DestroyedReplicatedStaticActors;    // 0x0288 (size: 0x10)
    TArray<class AActor*> ActorsToPreInitialize;                                      // 0x02A0 (size: 0x10)
    TArray<class AActor*> ActorsToInitialize;                                         // 0x02B0 (size: 0x10)
    TArray<class AActor*> ActorsToBeginPlay;                                          // 0x02C0 (size: 0x10)

}; // Size: 0x2D0

class ULevelActorContainer : public UObject
{
    TArray<class AActor*> Actors;                                                     // 0x0028 (size: 0x10)

}; // Size: 0x38

class ALevelBounds : public AActor
{
    class UBoxComponent* BoxComponent;                                                // 0x0228 (size: 0x8)
    bool bAutoUpdateBounds;                                                           // 0x0230 (size: 0x1)

}; // Size: 0x238

class ALevelScriptActor : public AActor
{
    uint8 bInputEnabled;                                                              // 0x0228 (size: 0x1)

    void WorldOriginLocationChanged(FIntVector OldOriginLocation, FIntVector NewOriginLocation);
    void SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    bool RemoteEvent(FName EventName);
    void LevelReset();
}; // Size: 0x230

class ULevelScriptBlueprint : public UBlueprint
{
}; // Size: 0xA0

struct FStreamingLevelsToConsider
{
    TArray<class ULevelStreaming*> StreamingLevels;                                   // 0x0000 (size: 0x10)

}; // Size: 0x28

struct FLevelCollection
{
    class AGameStateBase* GameState;                                                  // 0x0008 (size: 0x8)
    class UNetDriver* NetDriver;                                                      // 0x0010 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x0018 (size: 0x8)
    class ULevel* PersistentLevel;                                                    // 0x0020 (size: 0x8)
    TSet<ULevel*> Levels;                                                             // 0x0028 (size: 0x50)

}; // Size: 0x78

struct FPSCPoolElem
{
    class UParticleSystemComponent* PSC;                                              // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FPSCPool
{
    TArray<FPSCPoolElem> FreeElements;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FWorldPSCPool
{
    TMap<class UParticleSystem*, class FPSCPool> WorldParticleSystemPools;            // 0x0000 (size: 0x50)

}; // Size: 0x58

class UWorld : public UObject
{
    class ULevel* PersistentLevel;                                                    // 0x0030 (size: 0x8)
    class UNetDriver* NetDriver;                                                      // 0x0038 (size: 0x8)
    class ULineBatchComponent* LineBatcher;                                           // 0x0040 (size: 0x8)
    class ULineBatchComponent* PersistentLineBatcher;                                 // 0x0048 (size: 0x8)
    class ULineBatchComponent* ForegroundLineBatcher;                                 // 0x0050 (size: 0x8)
    class AGameNetworkManager* NetworkManager;                                        // 0x0058 (size: 0x8)
    class UPhysicsCollisionHandler* PhysicsCollisionHandler;                          // 0x0060 (size: 0x8)
    TArray<class UObject*> ExtraReferencedObjects;                                    // 0x0068 (size: 0x10)
    TArray<class UObject*> PerModuleDataObjects;                                      // 0x0078 (size: 0x10)
    TArray<class ULevelStreaming*> StreamingLevels;                                   // 0x0088 (size: 0x10)
    FStreamingLevelsToConsider StreamingLevelsToConsider;                             // 0x0098 (size: 0x28)
    FString StreamingLevelsPrefix;                                                    // 0x00C0 (size: 0x10)
    class ULevel* CurrentLevelPendingVisibility;                                      // 0x00D0 (size: 0x8)
    class ULevel* CurrentLevelPendingInvisibility;                                    // 0x00D8 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x00E0 (size: 0x8)
    class AParticleEventManager* MyParticleEventManager;                              // 0x00E8 (size: 0x8)
    class APhysicsVolume* DefaultPhysicsVolume;                                       // 0x00F0 (size: 0x8)
    uint8 bAreConstraintsDirty;                                                       // 0x010E (size: 0x1)
    class UNavigationSystemBase* NavigationSystem;                                    // 0x0110 (size: 0x8)
    class AGameModeBase* AuthorityGameMode;                                           // 0x0118 (size: 0x8)
    class AGameStateBase* GameState;                                                  // 0x0120 (size: 0x8)
    class UAISystemBase* AISystem;                                                    // 0x0128 (size: 0x8)
    class UAvoidanceManager* AvoidanceManager;                                        // 0x0130 (size: 0x8)
    TArray<class ULevel*> Levels;                                                     // 0x0138 (size: 0x10)
    TArray<FLevelCollection> LevelCollections;                                        // 0x0148 (size: 0x10)
    class UGameInstance* OwningGameInstance;                                          // 0x0180 (size: 0x8)
    TArray<class UMaterialParameterCollectionInstance*> ParameterCollectionInstances; // 0x0188 (size: 0x10)
    class UCanvas* CanvasForRenderingToTarget;                                        // 0x0198 (size: 0x8)
    class UCanvas* CanvasForDrawMaterialToRenderTarget;                               // 0x01A0 (size: 0x8)
    class UPhysicsFieldComponent* PhysicsField;                                       // 0x01F8 (size: 0x8)
    TSet<UActorComponent*> ComponentsThatNeedPreEndOfFrameSync;                       // 0x0200 (size: 0x50)
    TArray<class UActorComponent*> ComponentsThatNeedEndOfFrameUpdate;                // 0x0250 (size: 0x10)
    TArray<class UActorComponent*> ComponentsThatNeedEndOfFrameUpdate_OnGameThread;   // 0x0260 (size: 0x10)
    class UWorldComposition* WorldComposition;                                        // 0x05E0 (size: 0x8)
    FWorldPSCPool PSCPool;                                                            // 0x0678 (size: 0x58)

    class AWorldSettings* K2_GetWorldSettings();
    void HandleTimelineScrubbed();
}; // Size: 0x798

class ULevelStreaming : public UObject
{
    TSoftObjectPtr<UWorld> WorldAsset;                                                // 0x0028 (size: 0x28)
    FName PackageNameToLoad;                                                          // 0x0050 (size: 0x8)
    TArray<FName> LODPackageNames;                                                    // 0x0058 (size: 0x10)
    FTransform LevelTransform;                                                        // 0x0080 (size: 0x30)
    int32 LevelLODIndex;                                                              // 0x00B0 (size: 0x4)
    int32 StreamingPriority;                                                          // 0x00B4 (size: 0x4)
    uint8 bShouldBeVisible;                                                           // 0x00BA (size: 0x1)
    uint8 bShouldBeLoaded;                                                            // 0x00BA (size: 0x1)
    uint8 bLocked;                                                                    // 0x00BA (size: 0x1)
    uint8 bIsStatic;                                                                  // 0x00BA (size: 0x1)
    uint8 bShouldBlockOnLoad;                                                         // 0x00BA (size: 0x1)
    uint8 bShouldBlockOnUnload;                                                       // 0x00BB (size: 0x1)
    uint8 bDisableDistanceStreaming;                                                  // 0x00BB (size: 0x1)
    uint8 bDrawOnLevelStatusMap;                                                      // 0x00BB (size: 0x1)
    FLinearColor LevelColor;                                                          // 0x00BC (size: 0x10)
    TArray<class ALevelStreamingVolume*> EditorStreamingVolumes;                      // 0x00D0 (size: 0x10)
    float MinTimeBetweenVolumeUnloadRequests;                                         // 0x00E0 (size: 0x4)
    FLevelStreamingOnLevelLoaded OnLevelLoaded;                                       // 0x00E8 (size: 0x10)
    void LevelStreamingLoadedStatus();
    FLevelStreamingOnLevelUnloaded OnLevelUnloaded;                                   // 0x00F8 (size: 0x10)
    void LevelStreamingLoadedStatus();
    FLevelStreamingOnLevelShown OnLevelShown;                                         // 0x0108 (size: 0x10)
    void LevelStreamingVisibilityStatus();
    FLevelStreamingOnLevelHidden OnLevelHidden;                                       // 0x0118 (size: 0x10)
    void LevelStreamingVisibilityStatus();
    class ULevel* LoadedLevel;                                                        // 0x0128 (size: 0x8)
    class ULevel* PendingUnloadLevel;                                                 // 0x0130 (size: 0x8)

    bool ShouldBeLoaded();
    void SetShouldBeVisible(bool bInShouldBeVisible);
    void SetShouldBeLoaded(bool bInShouldBeLoaded);
    void SetPriority(int32 NewPriority);
    void SetLevelLODIndex(int32 LODIndex);
    void SetIsRequestingUnloadAndRemoval(bool bInIsRequestingUnloadAndRemoval);
    bool IsStreamingStatePending();
    bool IsLevelVisible();
    bool IsLevelLoaded();
    FName GetWorldAssetPackageFName();
    class ULevel* GetLoadedLevel();
    class ALevelScriptActor* GetLevelScriptActor();
    bool GetIsRequestingUnloadAndRemoval();
    class ULevelStreaming* CreateInstance(FString UniqueInstanceName);
}; // Size: 0x150

class ULevelStreamingAlwaysLoaded : public ULevelStreaming
{
}; // Size: 0x150

class ULevelStreamingDynamic : public ULevelStreaming
{
    uint8 bInitiallyLoaded;                                                           // 0x0148 (size: 0x1)
    uint8 bInitiallyVisible;                                                          // 0x0148 (size: 0x1)

    class ULevelStreamingDynamic* LoadLevelInstanceBySoftObjectPtr(class UObject* WorldContextObject, TSoftObjectPtr<UWorld> Level, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride);
    class ULevelStreamingDynamic* LoadLevelInstance(class UObject* WorldContextObject, FString LevelName, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride);
}; // Size: 0x150

class ULevelStreamingPersistent : public ULevelStreaming
{
}; // Size: 0x150

class ALevelStreamingVolume : public AVolume
{
    TArray<FName> StreamingLevelNames;                                                // 0x0260 (size: 0x10)
    uint8 bEditorPreVisOnly;                                                          // 0x0270 (size: 0x1)
    uint8 bDisabled;                                                                  // 0x0270 (size: 0x1)
    TEnumAsByte<EStreamingVolumeUsage> StreamingUsage;                                // 0x0274 (size: 0x1)

}; // Size: 0x278

class ULightmappedSurfaceCollection : public UObject
{
    class UModel* SourceModel;                                                        // 0x0028 (size: 0x8)
    TArray<int32> Surfaces;                                                           // 0x0030 (size: 0x10)

}; // Size: 0x40

class ULightMapTexture2D : public UTexture2D
{
}; // Size: 0x1B0

class ULightMapVirtualTexture2D : public UTexture2D
{
    TArray<int8> TypeToLayer;                                                         // 0x01A0 (size: 0x10)

}; // Size: 0x1C0

class ALightmassCharacterIndirectDetailVolume : public AVolume
{
}; // Size: 0x260

class ALightmassImportanceVolume : public AVolume
{
}; // Size: 0x260

class ALightmassPortal : public AActor
{
    class ULightmassPortalComponent* PortalComponent;                                 // 0x0228 (size: 0x8)

}; // Size: 0x230

class ULightmassPortalComponent : public USceneComponent
{
    class UBoxComponent* PreviewBox;                                                  // 0x01F8 (size: 0x8)

}; // Size: 0x200

class ULightmassPrimitiveSettingsObject : public UObject
{
    FLightmassPrimitiveSettings LightmassSettings;                                    // 0x0028 (size: 0x18)

}; // Size: 0x40

class ULineBatchComponent : public UPrimitiveComponent
{
}; // Size: 0x490

class ULocalPlayer : public UPlayer
{
    class UGameViewportClient* ViewportClient;                                        // 0x0070 (size: 0x8)
    TEnumAsByte<EAspectRatioAxisConstraint> AspectRatioAxisConstraint;                // 0x0094 (size: 0x1)
    TSubclassOf<class APlayerController> PendingLevelPlayerControllerClass;           // 0x0098 (size: 0x8)
    uint8 bSentSplitJoin;                                                             // 0x00A0 (size: 0x1)
    int32 ControllerId;                                                               // 0x00B8 (size: 0x4)

}; // Size: 0x258

class ULocalPlayerSubsystem : public USubsystem
{
}; // Size: 0x30

struct FHLODInstancingKey
{
    class UStaticMesh* StaticMesh;                                                    // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

class ALODActor : public AActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0228 (size: 0x8)
    TMap<class FHLODInstancingKey, class UInstancedStaticMeshComponent*> InstancedStaticMeshComponents; // 0x0230 (size: 0x50)
    class UHLODProxy* Proxy;                                                          // 0x0280 (size: 0x8)
    FName Key;                                                                        // 0x0288 (size: 0x8)
    float LODDrawDistance;                                                            // 0x0290 (size: 0x4)
    int32 LODLevel;                                                                   // 0x0294 (size: 0x4)
    TArray<class AActor*> SubActors;                                                  // 0x0298 (size: 0x10)
    uint8 CachedNumHLODLevels;                                                        // 0x02A8 (size: 0x1)

}; // Size: 0x2B0

struct FComponentSync
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    ESyncOption SyncOption;                                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FLODMappingData
{
    TArray<int32> Mapping;                                                            // 0x0000 (size: 0x10)
    TArray<int32> InverseMapping;                                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

class ULODSyncComponent : public UActorComponent
{
    int32 NumLODs;                                                                    // 0x00B0 (size: 0x4)
    int32 ForcedLOD;                                                                  // 0x00B4 (size: 0x4)
    TArray<FComponentSync> ComponentsToSync;                                          // 0x00B8 (size: 0x10)
    TMap<class FName, class FLODMappingData> CustomLODMapping;                        // 0x00C8 (size: 0x50)
    int32 CurrentLOD;                                                                 // 0x0118 (size: 0x4)
    int32 CurrentNumLODs;                                                             // 0x011C (size: 0x4)
    TArray<class UPrimitiveComponent*> DriveComponents;                               // 0x0120 (size: 0x10)
    TArray<class UPrimitiveComponent*> SubComponents;                                 // 0x0130 (size: 0x10)

    FString GetLODSyncDebugText();
}; // Size: 0x140

class ILODSyncInterface : public IInterface
{
}; // Size: 0x28

class UMapBuildDataRegistry : public UObject
{
    TEnumAsByte<ELightingBuildQuality> LevelLightingQuality;                          // 0x0028 (size: 0x1)

}; // Size: 0x238

struct FMaterialInput
{
    int32 OutputIndex;                                                                // 0x0000 (size: 0x4)
    FName InputName;                                                                  // 0x0004 (size: 0x8)
    FName ExpressionName;                                                             // 0x000C (size: 0x8)

}; // Size: 0x14

struct FScalarMaterialInput : public FMaterialInput
{
}; // Size: 0x14

struct FVectorMaterialInput : public FMaterialInput
{
}; // Size: 0x14

struct FColorMaterialInput : public FMaterialInput
{
}; // Size: 0x14

struct FMaterialShadingModelField
{
    uint16 ShadingModelField;                                                         // 0x0000 (size: 0x2)

}; // Size: 0x2

struct FMaterialAttributesInput : public FExpressionInput
{
    int32 PropertyConnectedBitmask;                                                   // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FShadingModelMaterialInput : public FMaterialInput
{
}; // Size: 0x14

struct FMaterialFunctionInfo
{
    FGuid StateId;                                                                    // 0x0000 (size: 0x10)
    class UMaterialFunctionInterface* Function;                                       // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMaterialParameterCollectionInfo
{
    FGuid StateId;                                                                    // 0x0000 (size: 0x10)
    class UMaterialParameterCollection* ParameterCollection;                          // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMaterialCachedExpressionData
{
    FMaterialCachedParameters Parameters;                                             // 0x0000 (size: 0x150)
    TArray<class UObject*> ReferencedTextures;                                        // 0x0150 (size: 0x10)
    TArray<FMaterialFunctionInfo> FunctionInfos;                                      // 0x0160 (size: 0x10)
    TArray<FMaterialParameterCollectionInfo> ParameterCollectionInfos;                // 0x0170 (size: 0x10)
    TArray<class UMaterialFunctionInterface*> DefaultLayers;                          // 0x0180 (size: 0x10)
    TArray<class UMaterialFunctionInterface*> DefaultLayerBlends;                     // 0x0190 (size: 0x10)
    TArray<class ULandscapeGrassType*> GrassTypes;                                    // 0x01A0 (size: 0x10)
    TArray<FName> DynamicParameterNames;                                              // 0x01B0 (size: 0x10)
    TArray<bool> QualityLevelsUsed;                                                   // 0x01C0 (size: 0x10)
    uint8 bHasRuntimeVirtualTextureOutput;                                            // 0x01D0 (size: 0x1)
    uint8 bHasSceneColor;                                                             // 0x01D0 (size: 0x1)

}; // Size: 0x1D8

class UMaterial : public UMaterialInterface
{
    class UPhysicalMaterial* PhysMaterial;                                            // 0x0088 (size: 0x8)
    class UPhysicalMaterialMask* PhysMaterialMask;                                    // 0x0090 (size: 0x8)
    class UPhysicalMaterial* PhysicalMaterialMap;                                     // 0x0098 (size: 0x40)
    FScalarMaterialInput Metallic;                                                    // 0x00D8 (size: 0x14)
    FScalarMaterialInput Specular;                                                    // 0x00EC (size: 0x14)
    FScalarMaterialInput Anisotropy;                                                  // 0x0100 (size: 0x14)
    FVectorMaterialInput Normal;                                                      // 0x0114 (size: 0x14)
    FVectorMaterialInput Tangent;                                                     // 0x0128 (size: 0x14)
    FColorMaterialInput EmissiveColor;                                                // 0x013C (size: 0x14)
    TEnumAsByte<EMaterialDomain> MaterialDomain;                                      // 0x0150 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x0151 (size: 0x1)
    TEnumAsByte<EDecalBlendMode> DecalBlendMode;                                      // 0x0152 (size: 0x1)
    TEnumAsByte<EMaterialDecalResponse> MaterialDecalResponse;                        // 0x0153 (size: 0x1)
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x0154 (size: 0x1)
    uint8 bCastDynamicShadowAsMasked;                                                 // 0x0155 (size: 0x1)
    FMaterialShadingModelField ShadingModels;                                         // 0x0156 (size: 0x2)
    float OpacityMaskClipValue;                                                       // 0x0158 (size: 0x4)
    FVectorMaterialInput WorldPositionOffset;                                         // 0x015C (size: 0x14)
    FScalarMaterialInput Refraction;                                                  // 0x0170 (size: 0x14)
    FMaterialAttributesInput MaterialAttributes;                                      // 0x0184 (size: 0x18)
    FScalarMaterialInput PixelDepthOffset;                                            // 0x019C (size: 0x14)
    FShadingModelMaterialInput ShadingModelFromMaterialExpression;                    // 0x01B0 (size: 0x14)
    uint8 bEnableSeparateTranslucency;                                                // 0x01C4 (size: 0x1)
    uint8 bEnableResponsiveAA;                                                        // 0x01C4 (size: 0x1)
    uint8 bScreenSpaceReflections;                                                    // 0x01C4 (size: 0x1)
    uint8 bContactShadows;                                                            // 0x01C4 (size: 0x1)
    uint8 TwoSided;                                                                   // 0x01C4 (size: 0x1)
    uint8 DitheredLODTransition;                                                      // 0x01C4 (size: 0x1)
    uint8 DitherOpacityMask;                                                          // 0x01C4 (size: 0x1)
    uint8 bAllowNegativeEmissiveColor;                                                // 0x01C4 (size: 0x1)
    TEnumAsByte<ETranslucencyLightingMode> TranslucencyLightingMode;                  // 0x01C5 (size: 0x1)
    uint8 bEnableMobileSeparateTranslucency;                                          // 0x01C6 (size: 0x1)
    int32 NumCustomizedUVs;                                                           // 0x01C8 (size: 0x4)
    float TranslucencyDirectionalLightingIntensity;                                   // 0x01CC (size: 0x4)
    float TranslucentShadowDensityScale;                                              // 0x01D0 (size: 0x4)
    float TranslucentSelfShadowDensityScale;                                          // 0x01D4 (size: 0x4)
    float TranslucentSelfShadowSecondDensityScale;                                    // 0x01D8 (size: 0x4)
    float TranslucentSelfShadowSecondOpacity;                                         // 0x01DC (size: 0x4)
    float TranslucentBackscatteringExponent;                                          // 0x01E0 (size: 0x4)
    FLinearColor TranslucentMultipleScatteringExtinction;                             // 0x01E4 (size: 0x10)
    float TranslucentShadowStartOffset;                                               // 0x01F4 (size: 0x4)
    uint8 bDisableDepthTest;                                                          // 0x01F8 (size: 0x1)
    uint8 bWriteOnlyAlpha;                                                            // 0x01F8 (size: 0x1)
    uint8 bGenerateSphericalParticleNormals;                                          // 0x01F8 (size: 0x1)
    uint8 bTangentSpaceNormal;                                                        // 0x01F8 (size: 0x1)
    uint8 bUseEmissiveForDynamicAreaLighting;                                         // 0x01F8 (size: 0x1)
    uint8 bBlockGI;                                                                   // 0x01F8 (size: 0x1)
    uint8 bUsedAsSpecialEngineMaterial;                                               // 0x01F8 (size: 0x1)
    uint8 bUsedWithSkeletalMesh;                                                      // 0x01F8 (size: 0x1)
    uint8 bUsedWithEditorCompositing;                                                 // 0x01F9 (size: 0x1)
    uint8 bUsedWithParticleSprites;                                                   // 0x01F9 (size: 0x1)
    uint8 bUsedWithBeamTrails;                                                        // 0x01F9 (size: 0x1)
    uint8 bUsedWithMeshParticles;                                                     // 0x01F9 (size: 0x1)
    uint8 bUsedWithNiagaraSprites;                                                    // 0x01F9 (size: 0x1)
    uint8 bUsedWithNiagaraRibbons;                                                    // 0x01F9 (size: 0x1)
    uint8 bUsedWithNiagaraMeshParticles;                                              // 0x01F9 (size: 0x1)
    uint8 bUsedWithGeometryCache;                                                     // 0x01F9 (size: 0x1)
    uint8 bUsedWithStaticLighting;                                                    // 0x01FA (size: 0x1)
    uint8 bUsedWithMorphTargets;                                                      // 0x01FA (size: 0x1)
    uint8 bUsedWithSplineMeshes;                                                      // 0x01FA (size: 0x1)
    uint8 bUsedWithInstancedStaticMeshes;                                             // 0x01FA (size: 0x1)
    uint8 bUsedWithGeometryCollections;                                               // 0x01FA (size: 0x1)
    uint8 bUsesDistortion;                                                            // 0x01FA (size: 0x1)
    uint8 bUsedWithClothing;                                                          // 0x01FA (size: 0x1)
    uint8 bUsedWithWater;                                                             // 0x01FC (size: 0x1)
    uint8 bUsedWithHairStrands;                                                       // 0x01FC (size: 0x1)
    uint8 bUsedWithLidarPointCloud;                                                   // 0x01FC (size: 0x1)
    uint8 bUsedWithVirtualHeightfieldMesh;                                            // 0x01FC (size: 0x1)
    uint8 bUsedWithUI;                                                                // 0x0200 (size: 0x1)
    uint8 bAutomaticallySetUsageInEditor;                                             // 0x0200 (size: 0x1)
    uint8 bFullyRough;                                                                // 0x0200 (size: 0x1)
    uint8 bUseFullPrecision;                                                          // 0x0200 (size: 0x1)
    uint8 bUseLightmapDirectionality;                                                 // 0x0200 (size: 0x1)
    uint8 bUseAlphaToCoverage;                                                        // 0x0200 (size: 0x1)
    uint8 bForwardRenderUsePreintegratedGFForSimpleIBL;                               // 0x0204 (size: 0x1)
    uint8 bUseHQForwardReflections;                                                   // 0x0208 (size: 0x1)
    uint8 bForwardBlendsSkyLightCubemaps;                                             // 0x0208 (size: 0x1)
    uint8 bUsePlanarForwardReflections;                                               // 0x0208 (size: 0x1)
    uint8 bNormalCurvatureToRoughness;                                                // 0x0208 (size: 0x1)
    TEnumAsByte<EMaterialTessellationMode> D3D11TessellationMode;                     // 0x0209 (size: 0x1)
    uint8 bEnableCrackFreeDisplacement;                                               // 0x020A (size: 0x1)
    uint8 bEnableAdaptiveTessellation;                                                // 0x020A (size: 0x1)
    uint8 AllowTranslucentCustomDepthWrites;                                          // 0x020A (size: 0x1)
    uint8 Wireframe;                                                                  // 0x020A (size: 0x1)
    uint8 WriteDepthToTranslucentMaterial;                                            // 0x020A (size: 0x1)
    TEnumAsByte<EMaterialShadingRate> ShadingRate;                                    // 0x020B (size: 0x1)
    uint8 bCanMaskedBeAssumedOpaque;                                                  // 0x020C (size: 0x1)
    uint8 bIsMasked;                                                                  // 0x020C (size: 0x1)
    uint8 bIsPreviewMaterial;                                                         // 0x020C (size: 0x1)
    uint8 bIsFunctionPreviewMaterial;                                                 // 0x020C (size: 0x1)
    uint8 bUseMaterialAttributes;                                                     // 0x020C (size: 0x1)
    uint8 bCastRayTracedShadows;                                                      // 0x020C (size: 0x1)
    uint8 bUseTranslucencyVertexFog;                                                  // 0x020C (size: 0x1)
    uint8 bApplyCloudFogging;                                                         // 0x020C (size: 0x1)
    uint8 bIsSky;                                                                     // 0x020D (size: 0x1)
    uint8 bComputeFogPerPixel;                                                        // 0x020D (size: 0x1)
    uint8 bOutputTranslucentVelocity;                                                 // 0x020D (size: 0x1)
    uint8 bAllowDevelopmentShaderCompile;                                             // 0x020D (size: 0x1)
    uint8 bIsMaterialEditorStatsMaterial;                                             // 0x020D (size: 0x1)
    TEnumAsByte<EBlendableLocation> BlendableLocation;                                // 0x020E (size: 0x1)
    uint8 BlendableOutputAlpha;                                                       // 0x020F (size: 0x1)
    uint8 bEnableStencilTest;                                                         // 0x020F (size: 0x1)
    TEnumAsByte<EMaterialStencilCompare> StencilCompare;                              // 0x0210 (size: 0x1)
    uint8 StencilRefValue;                                                            // 0x0211 (size: 0x1)
    TEnumAsByte<ERefractionMode> RefractionMode;                                      // 0x0212 (size: 0x1)
    int32 BlendablePriority;                                                          // 0x0214 (size: 0x4)
    uint8 bIsBlendable;                                                               // 0x0218 (size: 0x1)
    uint32 UsageFlagWarnings;                                                         // 0x021C (size: 0x4)
    float RefractionDepthBias;                                                        // 0x0220 (size: 0x4)
    FGuid StateId;                                                                    // 0x0224 (size: 0x10)
    float MaxDisplacement;                                                            // 0x0234 (size: 0x4)
    FMaterialCachedExpressionData CachedExpressionData;                               // 0x0268 (size: 0x1D8)

}; // Size: 0x440

struct FMaterialSpriteElement
{
    class UMaterialInterface* Material;                                               // 0x0000 (size: 0x8)
    class UCurveFloat* DistanceToOpacityCurve;                                        // 0x0008 (size: 0x8)
    uint8 bSizeIsInScreenSpace;                                                       // 0x0010 (size: 0x1)
    float BaseSizeX;                                                                  // 0x0014 (size: 0x4)
    float BaseSizeY;                                                                  // 0x0018 (size: 0x4)
    class UCurveFloat* DistanceToSizeCurve;                                           // 0x0020 (size: 0x8)

}; // Size: 0x28

class UMaterialBillboardComponent : public UPrimitiveComponent
{
    TArray<FMaterialSpriteElement> Elements;                                          // 0x0450 (size: 0x10)

    void SetElements(const TArray<FMaterialSpriteElement>& NewElements);
    void AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve);
}; // Size: 0x460

class UMaterialExpressionAbs : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionActorPositionWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionAdd : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionTextureBase : public UMaterialExpression
{
    class UTexture* Texture;                                                          // 0x0040 (size: 0x8)

}; // Size: 0x48

class UMaterialExpressionTextureSample : public UMaterialExpressionTextureBase
{
    FExpressionInput Coordinates;                                                     // 0x0048 (size: 0x14)

}; // Size: 0x60

class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
    FName ParameterName;                                                              // 0x0060 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0068 (size: 0x10)
    FName Group;                                                                      // 0x0078 (size: 0x8)

}; // Size: 0x80

class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x80

class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
    float Threshold;                                                                  // 0x0080 (size: 0x4)
    TEnumAsByte<ETextureColorChannel> Channel;                                        // 0x0084 (size: 0x1)

}; // Size: 0x88

class UMaterialExpressionAppendVector : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionArccosine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionArccosineFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionArcsine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionArcsineFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionArctangent : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionArctangent2 : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x0040 (size: 0x14)
    FExpressionInput X;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionArctangent2Fast : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x0040 (size: 0x14)
    FExpressionInput X;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionArctangentFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionAtmosphericFogColor : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionAtmosphericLightColor : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionAtmosphericLightVector : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionBentNormalCustomOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionBlackBody : public UMaterialExpression
{
    FExpressionInput Temp;                                                            // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionBlendMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput A;                                                       // 0x0040 (size: 0x18)
    FMaterialAttributesInput B;                                                       // 0x0058 (size: 0x18)
    FExpressionInput Alpha;                                                           // 0x0070 (size: 0x14)
    TEnumAsByte<EMaterialAttributeBlend::Type> PixelAttributeBlendType;               // 0x0084 (size: 0x1)
    TEnumAsByte<EMaterialAttributeBlend::Type> VertexAttributeBlendType;              // 0x0085 (size: 0x1)

}; // Size: 0x88

class UMaterialExpressionBreakMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput MaterialAttributes;                                      // 0x0040 (size: 0x18)

}; // Size: 0x58

class UMaterialExpressionBumpOffset : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x0040 (size: 0x14)
    FExpressionInput Height;                                                          // 0x0054 (size: 0x14)
    FExpressionInput HeightRatioInput;                                                // 0x0068 (size: 0x14)
    float HeightRatio;                                                                // 0x007C (size: 0x4)
    float ReferencePlane;                                                             // 0x0080 (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x0084 (size: 0x4)

}; // Size: 0x88

class UMaterialExpressionCameraPositionWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionCameraVectorWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionCeil : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionParameter : public UMaterialExpression
{
    FName ParameterName;                                                              // 0x0040 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0048 (size: 0x10)

}; // Size: 0x58

class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
    FLinearColor DefaultValue;                                                        // 0x0058 (size: 0x10)
    bool bUseCustomPrimitiveData;                                                     // 0x0068 (size: 0x1)
    uint8 PrimitiveDataIndex;                                                         // 0x0069 (size: 0x1)

}; // Size: 0x70

class UMaterialExpressionChannelMaskParameter : public UMaterialExpressionVectorParameter
{
    TEnumAsByte<EChannelMaskParameterColor::Type> MaskChannel;                        // 0x0070 (size: 0x1)

}; // Size: 0x78

class UMaterialExpressionClamp : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    FExpressionInput Min;                                                             // 0x0054 (size: 0x14)
    FExpressionInput Max;                                                             // 0x0068 (size: 0x14)
    TEnumAsByte<EClampMode> ClampMode;                                                // 0x007C (size: 0x1)
    float MinDefault;                                                                 // 0x0080 (size: 0x4)
    float MaxDefault;                                                                 // 0x0084 (size: 0x4)

}; // Size: 0x88

class UMaterialExpressionClearCoatNormalCustomOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionCloudSampleAttribute : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionCollectionParameter : public UMaterialExpression
{
    class UMaterialParameterCollection* Collection;                                   // 0x0040 (size: 0x8)
    FName ParameterName;                                                              // 0x0048 (size: 0x8)
    FGuid ParameterId;                                                                // 0x0050 (size: 0x10)

}; // Size: 0x60

class UMaterialExpressionComment : public UMaterialExpression
{
    int32 SizeX;                                                                      // 0x0040 (size: 0x4)
    int32 SizeY;                                                                      // 0x0044 (size: 0x4)
    FString Text;                                                                     // 0x0048 (size: 0x10)
    FLinearColor CommentColor;                                                        // 0x0058 (size: 0x10)
    int32 FontSize;                                                                   // 0x0068 (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionComponentMask : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    uint8 R;                                                                          // 0x0054 (size: 0x1)
    uint8 G;                                                                          // 0x0054 (size: 0x1)
    uint8 B;                                                                          // 0x0054 (size: 0x1)
    uint8 A;                                                                          // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionConstant : public UMaterialExpression
{
    float R;                                                                          // 0x0040 (size: 0x4)

}; // Size: 0x48

class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
    float R;                                                                          // 0x0040 (size: 0x4)
    float G;                                                                          // 0x0044 (size: 0x4)

}; // Size: 0x48

class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
    FLinearColor Constant;                                                            // 0x0040 (size: 0x10)

}; // Size: 0x50

class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
    FLinearColor Constant;                                                            // 0x0040 (size: 0x10)

}; // Size: 0x50

class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    float Bias;                                                                       // 0x0054 (size: 0x4)
    float Scale;                                                                      // 0x0058 (size: 0x4)

}; // Size: 0x60

class UMaterialExpressionCosine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    float Period;                                                                     // 0x0054 (size: 0x4)

}; // Size: 0x58

class UMaterialExpressionCrossProduct : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
    float DefaultValue;                                                               // 0x0058 (size: 0x4)
    bool bUseCustomPrimitiveData;                                                     // 0x005C (size: 0x1)
    uint8 PrimitiveDataIndex;                                                         // 0x005D (size: 0x1)

}; // Size: 0x60

class UMaterialExpressionCurveAtlasRowParameter : public UMaterialExpressionScalarParameter
{
    class UCurveLinearColor* Curve;                                                   // 0x0060 (size: 0x8)
    class UCurveLinearColorAtlas* Atlas;                                              // 0x0068 (size: 0x8)
    FExpressionInput InputTime;                                                       // 0x0070 (size: 0x14)

}; // Size: 0x88

struct FCustomInput
{
    FName InputName;                                                                  // 0x0000 (size: 0x8)
    FExpressionInput Input;                                                           // 0x0008 (size: 0x14)

}; // Size: 0x1C

struct FCustomOutput
{
    FName OutputName;                                                                 // 0x0000 (size: 0x8)
    TEnumAsByte<ECustomMaterialOutputType> OutputType;                                // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FCustomDefine
{
    FString DefineName;                                                               // 0x0000 (size: 0x10)
    FString DefineValue;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

class UMaterialExpressionCustom : public UMaterialExpression
{
    FString Code;                                                                     // 0x0040 (size: 0x10)
    TEnumAsByte<ECustomMaterialOutputType> OutputType;                                // 0x0050 (size: 0x1)
    FString Description;                                                              // 0x0058 (size: 0x10)
    TArray<FCustomInput> Inputs;                                                      // 0x0068 (size: 0x10)
    TArray<FCustomOutput> AdditionalOutputs;                                          // 0x0078 (size: 0x10)
    TArray<FCustomDefine> AdditionalDefines;                                          // 0x0088 (size: 0x10)
    TArray<FString> IncludeFilePaths;                                                 // 0x0098 (size: 0x10)

}; // Size: 0xA8

class UMaterialExpressionDDX : public UMaterialExpression
{
    FExpressionInput Value;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDDY : public UMaterialExpression
{
    FExpressionInput Value;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDecalDerivative : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionDecalLifetimeOpacity : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionDecalMipmapLevel : public UMaterialExpression
{
    FExpressionInput TextureSize;                                                     // 0x0040 (size: 0x14)
    float ConstWidth;                                                                 // 0x0054 (size: 0x4)
    float ConstHeight;                                                                // 0x0058 (size: 0x4)

}; // Size: 0x60

class UMaterialExpressionDeltaTime : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionDepthFade : public UMaterialExpression
{
    FExpressionInput InOpacity;                                                       // 0x0040 (size: 0x14)
    FExpressionInput FadeDistance;                                                    // 0x0054 (size: 0x14)
    float OpacityDefault;                                                             // 0x0068 (size: 0x4)
    float FadeDistanceDefault;                                                        // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
    TEnumAsByte<EDepthOfFieldFunctionValue> FunctionValue;                            // 0x0040 (size: 0x1)
    FExpressionInput Depth;                                                           // 0x0044 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
    FExpressionInput InXY;                                                            // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDesaturation : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    FExpressionInput Fraction;                                                        // 0x0054 (size: 0x14)
    FLinearColor LuminanceFactors;                                                    // 0x0068 (size: 0x10)

}; // Size: 0x78

class UMaterialExpressionDistance : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionDistanceCullFade : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionDistanceFieldGradient : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDistanceFieldsRenderingSwitch : public UMaterialExpression
{
    FExpressionInput no;                                                              // 0x0040 (size: 0x14)
    FExpressionInput Yes;                                                             // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionDistanceToNearestSurface : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionDivide : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionDotProduct : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
    TArray<FString> ParamNames;                                                       // 0x0040 (size: 0x10)
    FLinearColor DefaultValue;                                                        // 0x0050 (size: 0x10)
    uint32 ParameterIndex;                                                            // 0x0060 (size: 0x4)

}; // Size: 0x68

class UMaterialExpressionEyeAdaptation : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionFeatureLevelSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionFloor : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionFmod : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionFontSample : public UMaterialExpression
{
    class UFont* Font;                                                                // 0x0040 (size: 0x8)
    int32 FontTexturePage;                                                            // 0x0048 (size: 0x4)

}; // Size: 0x50

class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
    FName ParameterName;                                                              // 0x0050 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0058 (size: 0x10)
    FName Group;                                                                      // 0x0068 (size: 0x8)

}; // Size: 0x70

class UMaterialExpressionFrac : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionFresnel : public UMaterialExpression
{
    FExpressionInput ExponentIn;                                                      // 0x0040 (size: 0x14)
    float Exponent;                                                                   // 0x0054 (size: 0x4)
    FExpressionInput BaseReflectFractionIn;                                           // 0x0058 (size: 0x14)
    float BaseReflectFraction;                                                        // 0x006C (size: 0x4)
    FExpressionInput Normal;                                                          // 0x0070 (size: 0x14)

}; // Size: 0x88

class UMaterialExpressionFunctionInput : public UMaterialExpression
{
    FExpressionInput Preview;                                                         // 0x0040 (size: 0x14)
    FName InputName;                                                                  // 0x0054 (size: 0x8)
    FString Description;                                                              // 0x0060 (size: 0x10)
    FGuid ID;                                                                         // 0x0070 (size: 0x10)
    TEnumAsByte<EFunctionInputType> InputType;                                        // 0x0080 (size: 0x1)
    FVector4 PreviewValue;                                                            // 0x0090 (size: 0x10)
    uint8 bUsePreviewValueAsDefault;                                                  // 0x00A0 (size: 0x1)
    int32 SortPriority;                                                               // 0x00A4 (size: 0x4)
    uint8 bCompilingFunctionPreview;                                                  // 0x00A8 (size: 0x1)

}; // Size: 0xC0

class UMaterialExpressionFunctionOutput : public UMaterialExpression
{
    FName OutputName;                                                                 // 0x0040 (size: 0x8)
    FString Description;                                                              // 0x0048 (size: 0x10)
    int32 SortPriority;                                                               // 0x0058 (size: 0x4)
    FExpressionInput A;                                                               // 0x005C (size: 0x14)
    uint8 bLastPreviewed;                                                             // 0x0070 (size: 0x1)
    FGuid ID;                                                                         // 0x0074 (size: 0x10)

}; // Size: 0x88

class UMaterialExpressionGetMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput MaterialAttributes;                                      // 0x0040 (size: 0x18)
    TArray<FGuid> AttributeGetTypes;                                                  // 0x0058 (size: 0x10)

}; // Size: 0x68

class UMaterialExpressionGIReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput StaticIndirect;                                                  // 0x0054 (size: 0x14)
    FExpressionInput DynamicIndirect;                                                 // 0x0068 (size: 0x14)

}; // Size: 0x80

class UMaterialExpressionHairAttributes : public UMaterialExpression
{
    uint8 bUseTangentSpace;                                                           // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMaterialExpressionHairColor : public UMaterialExpression
{
    FExpressionInput Melanin;                                                         // 0x0040 (size: 0x14)
    FExpressionInput Redness;                                                         // 0x0054 (size: 0x14)
    FExpressionInput DyeColor;                                                        // 0x0068 (size: 0x14)

}; // Size: 0x80

class UMaterialExpressionIf : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    FExpressionInput AGreaterThanB;                                                   // 0x0068 (size: 0x14)
    FExpressionInput AEqualsB;                                                        // 0x007C (size: 0x14)
    FExpressionInput ALessThanB;                                                      // 0x0090 (size: 0x14)
    float EqualsThreshold;                                                            // 0x00A4 (size: 0x4)
    float ConstB;                                                                     // 0x00A8 (size: 0x4)
    float ConstAEqualsB;                                                              // 0x00AC (size: 0x4)

}; // Size: 0xB0

class UMaterialExpressionInverseLinearInterpolate : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    FExpressionInput Value;                                                           // 0x0068 (size: 0x14)
    float ConstA;                                                                     // 0x007C (size: 0x4)
    float ConstB;                                                                     // 0x0080 (size: 0x4)
    float ConstValue;                                                                 // 0x0084 (size: 0x4)
    bool bClampResult;                                                                // 0x0088 (size: 0x1)

}; // Size: 0x90

class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
    FExpressionInput Realtime;                                                        // 0x0040 (size: 0x14)
    FExpressionInput Lightmass;                                                       // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionLightVector : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    FExpressionInput Alpha;                                                           // 0x0068 (size: 0x14)
    float ConstA;                                                                     // 0x007C (size: 0x4)
    float ConstB;                                                                     // 0x0080 (size: 0x4)
    float ConstAlpha;                                                                 // 0x0084 (size: 0x4)

}; // Size: 0x88

class UMaterialExpressionLogarithm10 : public UMaterialExpression
{
    FExpressionInput X;                                                               // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionLogarithm2 : public UMaterialExpression
{
    FExpressionInput X;                                                               // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionMakeMaterialAttributes : public UMaterialExpression
{
    FExpressionInput BaseColor;                                                       // 0x0040 (size: 0x14)
    FExpressionInput Metallic;                                                        // 0x0054 (size: 0x14)
    FExpressionInput Specular;                                                        // 0x0068 (size: 0x14)
    FExpressionInput Roughness;                                                       // 0x007C (size: 0x14)
    FExpressionInput Anisotropy;                                                      // 0x0090 (size: 0x14)
    FExpressionInput EmissiveColor;                                                   // 0x00A4 (size: 0x14)
    FExpressionInput Opacity;                                                         // 0x00B8 (size: 0x14)
    FExpressionInput OpacityMask;                                                     // 0x00CC (size: 0x14)
    FExpressionInput Normal;                                                          // 0x00E0 (size: 0x14)
    FExpressionInput Tangent;                                                         // 0x00F4 (size: 0x14)
    FExpressionInput WorldPositionOffset;                                             // 0x0108 (size: 0x14)
    FExpressionInput WorldDisplacement;                                               // 0x011C (size: 0x14)
    FExpressionInput TessellationMultiplier;                                          // 0x0130 (size: 0x14)
    FExpressionInput SubsurfaceColor;                                                 // 0x0144 (size: 0x14)
    FExpressionInput ClearCoat;                                                       // 0x0158 (size: 0x14)
    FExpressionInput ClearCoatRoughness;                                              // 0x016C (size: 0x14)
    FExpressionInput AmbientOcclusion;                                                // 0x0180 (size: 0x14)
    FExpressionInput Refraction;                                                      // 0x0194 (size: 0x14)
    FExpressionInput CustomizedUVs;                                                   // 0x01A8 (size: 0xA0)
    FExpressionInput PixelDepthOffset;                                                // 0x0248 (size: 0x14)
    FExpressionInput ShadingModel;                                                    // 0x025C (size: 0x14)

}; // Size: 0x270

class UMaterialExpressionMapARPassthroughCameraUV : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionMaterialAttributeLayers : public UMaterialExpression
{
    FName ParameterName;                                                              // 0x0040 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0048 (size: 0x10)
    FMaterialAttributesInput Input;                                                   // 0x0058 (size: 0x18)
    FMaterialLayersFunctions DefaultLayers;                                           // 0x0070 (size: 0x40)
    TArray<class UMaterialExpressionMaterialFunctionCall*> LayerCallers;              // 0x00B0 (size: 0x10)
    int32 NumActiveLayerCallers;                                                      // 0x00C0 (size: 0x4)
    TArray<class UMaterialExpressionMaterialFunctionCall*> BlendCallers;              // 0x00C8 (size: 0x10)
    int32 NumActiveBlendCallers;                                                      // 0x00D8 (size: 0x4)
    bool bIsLayerGraphBuilt;                                                          // 0x00DC (size: 0x1)

}; // Size: 0xE8

class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression
{
    class UMaterialFunctionInterface* MaterialFunction;                               // 0x0040 (size: 0x8)
    FMaterialParameterInfo FunctionParameterInfo;                                     // 0x0048 (size: 0x10)

}; // Size: 0x58

class UMaterialExpressionMaterialLayerOutput : public UMaterialExpressionFunctionOutput
{
}; // Size: 0x88

class UMaterialExpressionMaterialProxyReplace : public UMaterialExpression
{
    FExpressionInput Realtime;                                                        // 0x0040 (size: 0x14)
    FExpressionInput MaterialProxy;                                                   // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionMax : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionMin : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionMultiply : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionRerouteBase : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionNamedRerouteBase : public UMaterialExpressionRerouteBase
{
}; // Size: 0x40

class UMaterialExpressionNamedRerouteDeclaration : public UMaterialExpressionNamedRerouteBase
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    FName Name;                                                                       // 0x0054 (size: 0x8)
    FGuid VariableGuid;                                                               // 0x005C (size: 0x10)

}; // Size: 0x70

class UMaterialExpressionNamedRerouteUsage : public UMaterialExpressionNamedRerouteBase
{
    class UMaterialExpressionNamedRerouteDeclaration* Declaration;                    // 0x0040 (size: 0x8)
    FGuid DeclarationGuid;                                                            // 0x0048 (size: 0x10)

}; // Size: 0x58

class UMaterialExpressionNoise : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x0040 (size: 0x14)
    FExpressionInput FilterWidth;                                                     // 0x0054 (size: 0x14)
    float Scale;                                                                      // 0x0068 (size: 0x4)
    int32 Quality;                                                                    // 0x006C (size: 0x4)
    TEnumAsByte<ENoiseFunction> NoiseFunction;                                        // 0x0070 (size: 0x1)
    uint8 bTurbulence;                                                                // 0x0074 (size: 0x1)
    int32 Levels;                                                                     // 0x0078 (size: 0x4)
    float OutputMin;                                                                  // 0x007C (size: 0x4)
    float OutputMax;                                                                  // 0x0080 (size: 0x4)
    float LevelScale;                                                                 // 0x0084 (size: 0x4)
    uint8 bTiling;                                                                    // 0x0088 (size: 0x1)
    uint32 RepeatSize;                                                                // 0x008C (size: 0x4)

}; // Size: 0x90

class UMaterialExpressionNormalize : public UMaterialExpression
{
    FExpressionInput VectorInput;                                                     // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionObjectBounds : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionObjectPositionWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionObjectRadius : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionOneMinus : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionPanner : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x0040 (size: 0x14)
    FExpressionInput Time;                                                            // 0x0054 (size: 0x14)
    FExpressionInput Speed;                                                           // 0x0068 (size: 0x14)
    float SpeedX;                                                                     // 0x007C (size: 0x4)
    float SpeedY;                                                                     // 0x0080 (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x0084 (size: 0x4)
    bool bFractionalPart;                                                             // 0x0088 (size: 0x1)

}; // Size: 0x90

class UMaterialExpressionParticleColor : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleDirection : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleMotionBlurFade : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticlePositionWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleRadius : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleRandom : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleRelativeTime : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleSize : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleSpeed : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
    uint8 bBlend;                                                                     // 0x0060 (size: 0x1)

}; // Size: 0x68

class UMaterialExpressionParticleSubUVProperties : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPerInstanceCustomData : public UMaterialExpression
{
    FExpressionInput DefaultValue;                                                    // 0x0040 (size: 0x14)
    float ConstDefaultValue;                                                          // 0x0054 (size: 0x4)
    uint32 DataIndex;                                                                 // 0x0058 (size: 0x4)

}; // Size: 0x60

class UMaterialExpressionPerInstanceFadeAmount : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPixelDepth : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPixelNormalWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPower : public UMaterialExpression
{
    FExpressionInput Base;                                                            // 0x0040 (size: 0x14)
    FExpressionInput Exponent;                                                        // 0x0054 (size: 0x14)
    float ConstExponent;                                                              // 0x0068 (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionPrecomputedAOMask : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPreSkinnedLocalBounds : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPreSkinnedNormal : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPreSkinnedPosition : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionPreviousFrameSwitch : public UMaterialExpression
{
    FExpressionInput CurrentFrame;                                                    // 0x0040 (size: 0x14)
    FExpressionInput PreviousFrame;                                                   // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionQualitySwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput Inputs;                                                          // 0x0054 (size: 0x50)

}; // Size: 0xA8

class UMaterialExpressionRayTracingQualitySwitch : public UMaterialExpression
{
    FExpressionInput Normal;                                                          // 0x0040 (size: 0x14)
    FExpressionInput RayTraced;                                                       // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionReflectionCapturePassSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput Reflection;                                                      // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionReflectionVectorWS : public UMaterialExpression
{
    FExpressionInput CustomWorldNormal;                                               // 0x0040 (size: 0x14)
    uint8 bNormalizeCustomWorldNormal;                                                // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionReroute : public UMaterialExpressionRerouteBase
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
    FExpressionInput NormalizedRotationAxis;                                          // 0x0040 (size: 0x14)
    FExpressionInput RotationAngle;                                                   // 0x0054 (size: 0x14)
    FExpressionInput PivotPoint;                                                      // 0x0068 (size: 0x14)
    FExpressionInput Position;                                                        // 0x007C (size: 0x14)
    float Period;                                                                     // 0x0090 (size: 0x4)

}; // Size: 0x98

class UMaterialExpressionRotator : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x0040 (size: 0x14)
    FExpressionInput Time;                                                            // 0x0054 (size: 0x14)
    float CenterX;                                                                    // 0x0068 (size: 0x4)
    float CenterY;                                                                    // 0x006C (size: 0x4)
    float Speed;                                                                      // 0x0070 (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x0074 (size: 0x4)

}; // Size: 0x78

class UMaterialExpressionRound : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionRuntimeVirtualTextureOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput BaseColor;                                                       // 0x0040 (size: 0x14)
    FExpressionInput Specular;                                                        // 0x0054 (size: 0x14)
    FExpressionInput Roughness;                                                       // 0x0068 (size: 0x14)
    FExpressionInput Normal;                                                          // 0x007C (size: 0x14)
    FExpressionInput WorldHeight;                                                     // 0x0090 (size: 0x14)
    FExpressionInput Opacity;                                                         // 0x00A4 (size: 0x14)
    FExpressionInput Mask;                                                            // 0x00B8 (size: 0x14)

}; // Size: 0xD0

class UMaterialExpressionRuntimeVirtualTextureReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput VirtualTextureOutput;                                            // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionRuntimeVirtualTextureSample : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x0040 (size: 0x14)
    FExpressionInput WorldPosition;                                                   // 0x0054 (size: 0x14)
    FExpressionInput MipValue;                                                        // 0x0068 (size: 0x14)
    class URuntimeVirtualTexture* VirtualTexture;                                     // 0x0080 (size: 0x8)
    ERuntimeVirtualTextureMaterialType MaterialType;                                  // 0x0088 (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x0089 (size: 0x1)
    bool bAdaptive;                                                                   // 0x008A (size: 0x1)
    TEnumAsByte<ERuntimeVirtualTextureMipValueMode> MipValueMode;                     // 0x008B (size: 0x1)
    TEnumAsByte<ERuntimeVirtualTextureTextureAddressMode> TextureAddressMode;         // 0x008C (size: 0x1)

}; // Size: 0x90

class UMaterialExpressionRuntimeVirtualTextureSampleParameter : public UMaterialExpressionRuntimeVirtualTextureSample
{
    FName ParameterName;                                                              // 0x0090 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0098 (size: 0x10)
    FName Group;                                                                      // 0x00A8 (size: 0x8)

}; // Size: 0xB0

class UMaterialExpressionSamplePhysicsVectorField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x0040 (size: 0x14)
    TEnumAsByte<EFieldVectorType> FieldTarget;                                        // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionSamplePhysicsScalarField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x0040 (size: 0x14)
    TEnumAsByte<EFieldScalarType> FieldTarget;                                        // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionSamplePhysicsIntegerField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x0040 (size: 0x14)
    TEnumAsByte<EFieldIntegerType> FieldTarget;                                       // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionSaturate : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionSceneColor : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x0040 (size: 0x1)
    FExpressionInput Input;                                                           // 0x0044 (size: 0x14)
    FExpressionInput OffsetFraction;                                                  // 0x0058 (size: 0x14)
    FVector2D ConstInput;                                                             // 0x006C (size: 0x8)

}; // Size: 0x78

class UMaterialExpressionSceneDepth : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x0040 (size: 0x1)
    FExpressionInput Input;                                                           // 0x0044 (size: 0x14)
    FExpressionInput Coordinates;                                                     // 0x0058 (size: 0x14)
    FVector2D ConstInput;                                                             // 0x006C (size: 0x8)

}; // Size: 0x78

class UMaterialExpressionSceneDepthWithoutWater : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x0040 (size: 0x1)
    FExpressionInput Input;                                                           // 0x0044 (size: 0x14)
    FVector2D ConstInput;                                                             // 0x0058 (size: 0x8)
    float FallbackDepth;                                                              // 0x0060 (size: 0x4)

}; // Size: 0x68

class UMaterialExpressionSceneTexelSize : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionSceneTexture : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x0040 (size: 0x14)
    TEnumAsByte<ESceneTextureId> SceneTextureId;                                      // 0x0054 (size: 0x1)
    bool bFiltered;                                                                   // 0x0055 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionScreenPosition : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionSetMaterialAttributes : public UMaterialExpression
{
    TArray<FExpressionInput> Inputs;                                                  // 0x0040 (size: 0x10)
    TArray<FGuid> AttributeSetTypes;                                                  // 0x0050 (size: 0x10)

}; // Size: 0x60

class UMaterialExpressionShaderStageSwitch : public UMaterialExpression
{
    FExpressionInput PixelShader;                                                     // 0x0040 (size: 0x14)
    FExpressionInput VertexShader;                                                    // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionShadingModel : public UMaterialExpression
{
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMaterialExpressionShadingPathSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput Inputs;                                                          // 0x0054 (size: 0x3C)

}; // Size: 0x90

class UMaterialExpressionShadowReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x0040 (size: 0x14)
    FExpressionInput Shadow;                                                          // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionSign : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionSine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    float Period;                                                                     // 0x0054 (size: 0x4)

}; // Size: 0x58

class UMaterialExpressionSingleLayerWaterMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput ScatteringCoefficients;                                          // 0x0040 (size: 0x14)
    FExpressionInput AbsorptionCoefficients;                                          // 0x0054 (size: 0x14)
    FExpressionInput PhaseG;                                                          // 0x0068 (size: 0x14)
    FExpressionInput ColorScaleBehindWater;                                           // 0x007C (size: 0x14)

}; // Size: 0x90

class UMaterialExpressionSkinningVertexOffsets : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionSkyAtmosphereLightDirection : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x0040 (size: 0x4)

}; // Size: 0x48

class UMaterialExpressionSkyAtmosphereLightIlluminance : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x0040 (size: 0x4)
    FExpressionInput WorldPosition;                                                   // 0x0044 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionSkyAtmosphereLightDiskLuminance : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x0040 (size: 0x4)

}; // Size: 0x48

class UMaterialExpressionSkyAtmosphereAerialPerspective : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionSkyAtmosphereDistantLightScatteredLuminance : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionSkyAtmosphereViewLuminance : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionSmoothStep : public UMaterialExpression
{
    FExpressionInput Min;                                                             // 0x0040 (size: 0x14)
    FExpressionInput Max;                                                             // 0x0054 (size: 0x14)
    FExpressionInput Value;                                                           // 0x0068 (size: 0x14)
    float ConstMin;                                                                   // 0x007C (size: 0x4)
    float ConstMax;                                                                   // 0x0080 (size: 0x4)
    float ConstValue;                                                                 // 0x0084 (size: 0x4)

}; // Size: 0x88

class UMaterialExpressionSobol : public UMaterialExpression
{
    FExpressionInput Cell;                                                            // 0x0040 (size: 0x14)
    FExpressionInput Index;                                                           // 0x0054 (size: 0x14)
    FExpressionInput Seed;                                                            // 0x0068 (size: 0x14)
    uint32 ConstIndex;                                                                // 0x007C (size: 0x4)
    FVector2D ConstSeed;                                                              // 0x0080 (size: 0x8)

}; // Size: 0x88

class UMaterialExpressionSpeedTree : public UMaterialExpression
{
    FExpressionInput GeometryInput;                                                   // 0x0040 (size: 0x14)
    FExpressionInput WindInput;                                                       // 0x0054 (size: 0x14)
    FExpressionInput LODInput;                                                        // 0x0068 (size: 0x14)
    FExpressionInput ExtraBendWS;                                                     // 0x007C (size: 0x14)
    TEnumAsByte<ESpeedTreeGeometryType> GeometryType;                                 // 0x0090 (size: 0x1)
    TEnumAsByte<ESpeedTreeWindType> WindType;                                         // 0x0091 (size: 0x1)
    TEnumAsByte<ESpeedTreeLODType> LODType;                                           // 0x0092 (size: 0x1)
    float BillboardThreshold;                                                         // 0x0094 (size: 0x4)
    bool bAccurateWindVelocities;                                                     // 0x0098 (size: 0x1)

}; // Size: 0xA0

class UMaterialExpressionSphereMask : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    FExpressionInput Radius;                                                          // 0x0068 (size: 0x14)
    FExpressionInput Hardness;                                                        // 0x007C (size: 0x14)
    float AttenuationRadius;                                                          // 0x0090 (size: 0x4)
    float HardnessPercent;                                                            // 0x0094 (size: 0x4)

}; // Size: 0x98

class UMaterialExpressionSphericalParticleOpacity : public UMaterialExpression
{
    FExpressionInput Density;                                                         // 0x0040 (size: 0x14)
    float ConstantDensity;                                                            // 0x0054 (size: 0x4)

}; // Size: 0x58

class UMaterialExpressionSquareRoot : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionStaticBool : public UMaterialExpression
{
    uint8 Value;                                                                      // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
    uint8 DefaultValue;                                                               // 0x0058 (size: 0x1)

}; // Size: 0x60

class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
    uint8 DefaultR;                                                                   // 0x0058 (size: 0x1)
    uint8 DefaultG;                                                                   // 0x0058 (size: 0x1)
    uint8 DefaultB;                                                                   // 0x0058 (size: 0x1)
    uint8 DefaultA;                                                                   // 0x0058 (size: 0x1)

}; // Size: 0x60

class UMaterialExpressionStaticSwitch : public UMaterialExpression
{
    uint8 DefaultValue;                                                               // 0x0040 (size: 0x1)
    FExpressionInput A;                                                               // 0x0044 (size: 0x14)
    FExpressionInput B;                                                               // 0x0058 (size: 0x14)
    FExpressionInput Value;                                                           // 0x006C (size: 0x14)

}; // Size: 0x80

class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter
{
}; // Size: 0x60

class UMaterialExpressionStep : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x0040 (size: 0x14)
    FExpressionInput X;                                                               // 0x0054 (size: 0x14)
    float ConstY;                                                                     // 0x0068 (size: 0x4)
    float ConstX;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionSubtract : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x0040 (size: 0x14)
    FExpressionInput B;                                                               // 0x0054 (size: 0x14)
    float ConstA;                                                                     // 0x0068 (size: 0x4)
    float ConstB;                                                                     // 0x006C (size: 0x4)

}; // Size: 0x70

class UMaterialExpressionTangent : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    float Period;                                                                     // 0x0054 (size: 0x4)

}; // Size: 0x58

class UMaterialExpressionTangentOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionTemporalSobol : public UMaterialExpression
{
    FExpressionInput Index;                                                           // 0x0040 (size: 0x14)
    FExpressionInput Seed;                                                            // 0x0054 (size: 0x14)
    uint32 ConstIndex;                                                                // 0x0068 (size: 0x4)
    FVector2D ConstSeed;                                                              // 0x006C (size: 0x8)

}; // Size: 0x78

class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
    int32 CoordinateIndex;                                                            // 0x0040 (size: 0x4)
    float UTiling;                                                                    // 0x0044 (size: 0x4)
    float VTiling;                                                                    // 0x0048 (size: 0x4)
    uint8 UnMirrorU;                                                                  // 0x004C (size: 0x1)
    uint8 UnMirrorV;                                                                  // 0x004C (size: 0x1)

}; // Size: 0x50

class UMaterialExpressionTextureObject : public UMaterialExpressionTextureBase
{
}; // Size: 0x48

class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x80

class UMaterialExpressionTextureProperty : public UMaterialExpression
{
    FExpressionInput TextureObject;                                                   // 0x0040 (size: 0x14)
    TEnumAsByte<EMaterialExposedTextureProperty> Property;                            // 0x0054 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionTextureSampleParameter2DArray : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x80

class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x80

class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
    uint8 bBlend;                                                                     // 0x0080 (size: 0x1)

}; // Size: 0x88

class UMaterialExpressionTextureSampleParameterVolume : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x80

class UMaterialExpressionThinTranslucentMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput TransmittanceColor;                                              // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionTime : public UMaterialExpression
{
    uint8 bIgnorePause;                                                               // 0x0040 (size: 0x1)
    uint8 bOverride_Period;                                                           // 0x0040 (size: 0x1)
    float Period;                                                                     // 0x0044 (size: 0x4)

}; // Size: 0x48

class UMaterialExpressionTransform : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    TEnumAsByte<EMaterialVectorCoordTransformSource> TransformSourceType;             // 0x0054 (size: 0x1)
    TEnumAsByte<EMaterialVectorCoordTransform> TransformType;                         // 0x0055 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionTransformPosition : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)
    TEnumAsByte<EMaterialPositionTransformSource> TransformSourceType;                // 0x0054 (size: 0x1)
    TEnumAsByte<EMaterialPositionTransformSource> TransformType;                      // 0x0055 (size: 0x1)

}; // Size: 0x58

class UMaterialExpressionTruncate : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x58

class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionVectorNoise : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x0040 (size: 0x14)
    TEnumAsByte<EVectorNoiseFunction> NoiseFunction;                                  // 0x0054 (size: 0x1)
    int32 Quality;                                                                    // 0x0058 (size: 0x4)
    uint8 bTiling;                                                                    // 0x005C (size: 0x1)
    uint32 TileSize;                                                                  // 0x0060 (size: 0x4)

}; // Size: 0x68

class UMaterialExpressionVertexColor : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionVertexInterpolator : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x0040 (size: 0x14)

}; // Size: 0x60

class UMaterialExpressionVertexNormalWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionVertexTangentWS : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionViewProperty : public UMaterialExpression
{
    TEnumAsByte<EMaterialExposedViewProperty> Property;                               // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMaterialExpressionViewSize : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionVirtualTextureFeatureSwitch : public UMaterialExpression
{
    FExpressionInput no;                                                              // 0x0040 (size: 0x14)
    FExpressionInput Yes;                                                             // 0x0054 (size: 0x14)

}; // Size: 0x68

class UMaterialExpressionVolumetricAdvancedMaterialInput : public UMaterialExpression
{
}; // Size: 0x40

class UMaterialExpressionVolumetricAdvancedMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput PhaseG;                                                          // 0x0040 (size: 0x14)
    FExpressionInput PhaseG2;                                                         // 0x0054 (size: 0x14)
    FExpressionInput PhaseBlend;                                                      // 0x0068 (size: 0x14)
    FExpressionInput MultiScatteringContribution;                                     // 0x007C (size: 0x14)
    FExpressionInput MultiScatteringOcclusion;                                        // 0x0090 (size: 0x14)
    FExpressionInput MultiScatteringEccentricity;                                     // 0x00A4 (size: 0x14)
    FExpressionInput ConservativeDensity;                                             // 0x00B8 (size: 0x14)
    float ConstPhaseG;                                                                // 0x00CC (size: 0x4)
    float ConstPhaseG2;                                                               // 0x00D0 (size: 0x4)
    float ConstPhaseBlend;                                                            // 0x00D4 (size: 0x4)
    bool PerSamplePhaseEvaluation;                                                    // 0x00D8 (size: 0x1)
    uint32 MultiScatteringApproximationOctaveCount;                                   // 0x00DC (size: 0x4)
    float ConstMultiScatteringContribution;                                           // 0x00E0 (size: 0x4)
    float ConstMultiScatteringOcclusion;                                              // 0x00E4 (size: 0x4)
    float ConstMultiScatteringEccentricity;                                           // 0x00E8 (size: 0x4)
    bool bGroundContribution;                                                         // 0x00EC (size: 0x1)
    bool bGrayScaleMaterial;                                                          // 0x00ED (size: 0x1)
    bool bRayMarchVolumeShadow;                                                       // 0x00EE (size: 0x1)

}; // Size: 0xF0

class UMaterialExpressionWorldPosition : public UMaterialExpression
{
    TEnumAsByte<EWorldPositionIncludedOffsets> WorldPositionShaderOffset;             // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMaterialFunctionInterface : public UObject
{
    FGuid StateId;                                                                    // 0x0028 (size: 0x10)
    EMaterialFunctionUsage MaterialFunctionUsage;                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class UMaterialFunction : public UMaterialFunctionInterface
{
    FString Description;                                                              // 0x0040 (size: 0x10)
    uint8 bExposeToLibrary;                                                           // 0x0050 (size: 0x1)
    uint8 bPrefixParameterNames;                                                      // 0x0050 (size: 0x1)

}; // Size: 0x58

class UMaterialFunctionInstance : public UMaterialFunctionInterface
{
    class UMaterialFunctionInterface* Parent;                                         // 0x0040 (size: 0x8)
    class UMaterialFunctionInterface* Base;                                           // 0x0048 (size: 0x8)
    TArray<FScalarParameterValue> ScalarParameterValues;                              // 0x0050 (size: 0x10)
    TArray<FVectorParameterValue> VectorParameterValues;                              // 0x0060 (size: 0x10)
    TArray<FTextureParameterValue> TextureParameterValues;                            // 0x0070 (size: 0x10)
    TArray<FFontParameterValue> FontParameterValues;                                  // 0x0080 (size: 0x10)
    TArray<FStaticSwitchParameter> StaticSwitchParameterValues;                       // 0x0090 (size: 0x10)
    TArray<FStaticComponentMaskParameter> StaticComponentMaskParameterValues;         // 0x00A0 (size: 0x10)
    TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues; // 0x00B0 (size: 0x10)

}; // Size: 0xC0

class UMaterialFunctionMaterialLayer : public UMaterialFunction
{
}; // Size: 0x58

class UMaterialFunctionMaterialLayerInstance : public UMaterialFunctionInstance
{
}; // Size: 0xC0

class UMaterialFunctionMaterialLayerBlend : public UMaterialFunction
{
}; // Size: 0x58

class UMaterialFunctionMaterialLayerBlendInstance : public UMaterialFunctionInstance
{
}; // Size: 0xC0

class AMaterialInstanceActor : public AActor
{
    TArray<class AActor*> TargetActors;                                               // 0x0228 (size: 0x10)

}; // Size: 0x238

class UMaterialInstanceDynamic : public UMaterialInstance
{

    void SetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, FLinearColor Value);
    void SetVectorParameterValue(FName ParameterName, FLinearColor Value);
    void SetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, class UTexture* Value);
    void SetTextureParameterValue(FName ParameterName, class UTexture* Value);
    void SetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, float Value);
    void SetScalarParameterValue(FName ParameterName, float Value);
    void K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha);
    FLinearColor K2_GetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
    class UTexture* K2_GetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    class UTexture* K2_GetTextureParameterValue(FName ParameterName);
    float K2_GetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    float K2_GetScalarParameterValue(FName ParameterName);
    void K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source, bool bQuickParametersOnly);
    void CopyParameterOverrides(class UMaterialInstance* MaterialInstance);
    void CopyInterpParameters(class UMaterialInstance* Source);
}; // Size: 0x360

struct FCollectionParameterBase
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    FGuid ID;                                                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCollectionScalarParameter : public FCollectionParameterBase
{
    float DefaultValue;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FCollectionVectorParameter : public FCollectionParameterBase
{
    FLinearColor DefaultValue;                                                        // 0x0018 (size: 0x10)

}; // Size: 0x28

class UMaterialParameterCollection : public UObject
{
    FGuid StateId;                                                                    // 0x0028 (size: 0x10)
    TArray<FCollectionScalarParameter> ScalarParameters;                              // 0x0038 (size: 0x10)
    TArray<FCollectionVectorParameter> VectorParameters;                              // 0x0048 (size: 0x10)

}; // Size: 0x70

class UMaterialParameterCollectionInstance : public UObject
{
    class UMaterialParameterCollection* Collection;                                   // 0x0030 (size: 0x8)

}; // Size: 0x120

struct FInterpGroupActorInfo
{
    FName ObjectName;                                                                 // 0x0000 (size: 0x8)
    TArray<class AActor*> Actors;                                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCameraCutInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    float Timestamp;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

class AMatineeActor : public AActor
{
    class UInterpData* MatineeData;                                                   // 0x0228 (size: 0x8)
    FName MatineeControllerName;                                                      // 0x0230 (size: 0x8)
    float PlayRate;                                                                   // 0x0238 (size: 0x4)
    uint8 bPlayOnLevelLoad;                                                           // 0x023C (size: 0x1)
    uint8 bForceStartPos;                                                             // 0x023C (size: 0x1)
    float ForceStartPosition;                                                         // 0x0240 (size: 0x4)
    uint8 bLooping;                                                                   // 0x0244 (size: 0x1)
    uint8 bRewindOnPlay;                                                              // 0x0244 (size: 0x1)
    uint8 bNoResetOnRewind;                                                           // 0x0244 (size: 0x1)
    uint8 bRewindIfAlreadyPlaying;                                                    // 0x0244 (size: 0x1)
    uint8 bDisableRadioFilter;                                                        // 0x0244 (size: 0x1)
    uint8 bClientSideOnly;                                                            // 0x0244 (size: 0x1)
    uint8 bSkipUpdateIfNotVisible;                                                    // 0x0244 (size: 0x1)
    uint8 bIsSkippable;                                                               // 0x0244 (size: 0x1)
    int32 PreferredSplitScreenNum;                                                    // 0x0248 (size: 0x4)
    uint8 bDisableMovementInput;                                                      // 0x024C (size: 0x1)
    uint8 bDisableLookAtInput;                                                        // 0x024C (size: 0x1)
    uint8 bHidePlayer;                                                                // 0x024C (size: 0x1)
    uint8 bHideHud;                                                                   // 0x024C (size: 0x1)
    TArray<FInterpGroupActorInfo> GroupActorInfos;                                    // 0x0250 (size: 0x10)
    uint8 bShouldShowGore;                                                            // 0x0260 (size: 0x1)
    TArray<class UInterpGroupInst*> GroupInst;                                        // 0x0268 (size: 0x10)
    TArray<FCameraCutInfo> CameraCuts;                                                // 0x0278 (size: 0x10)
    uint8 bIsPlaying;                                                                 // 0x0288 (size: 0x1)
    uint8 bReversePlayback;                                                           // 0x0288 (size: 0x1)
    uint8 bPaused;                                                                    // 0x0288 (size: 0x1)
    uint8 bPendingStop;                                                               // 0x0288 (size: 0x1)
    float InterpPosition;                                                             // 0x028C (size: 0x4)
    uint8 ReplicationForceIsPlaying;                                                  // 0x0294 (size: 0x1)
    FMatineeActorOnPlay OnPlay;                                                       // 0x0298 (size: 0x10)
    void OnMatineeEvent();
    FMatineeActorOnStop OnStop;                                                       // 0x02A8 (size: 0x10)
    void OnMatineeEvent();
    FMatineeActorOnPause OnPause;                                                     // 0x02B8 (size: 0x10)
    void OnMatineeEvent();

    void Stop();
    void SetPosition(float newPosition, bool bJump);
    void SetLoopingState(bool bNewLooping);
    void Reverse();
    void Play();
    void Pause();
    void EnableGroupByName(FString GroupName, bool bEnable);
    void ChangePlaybackDirection();
}; // Size: 0x2D0

class AMatineeActorCameraAnim : public AMatineeActor
{
    class UCameraAnim* CameraAnim;                                                    // 0x02D0 (size: 0x8)

}; // Size: 0x2D8

class IMatineeAnimInterface : public IInterface
{
}; // Size: 0x28

class IMatineeInterface : public IInterface
{
}; // Size: 0x28

class AMeshMergeCullingVolume : public AVolume
{
}; // Size: 0x260

class UMeshSimplificationSettings : public UDeveloperSettings
{
    FName MeshReductionModuleName;                                                    // 0x0038 (size: 0x8)

}; // Size: 0x40

class UMeshVertexPainterKismetLibrary : public UBlueprintFunctionLibrary
{

    void RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent);
    void PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, const FLinearColor& FillColor, bool bConvertToSRGB);
    void PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, const FLinearColor& StartColor, const FLinearColor& EndColor, EVertexPaintAxis Axis, bool bConvertToSRGB);
}; // Size: 0x28

struct FPurchaseInfo
{
    FString Identifier;                                                               // 0x0000 (size: 0x10)
    FString DisplayName;                                                              // 0x0010 (size: 0x10)
    FString DisplayDescription;                                                       // 0x0020 (size: 0x10)
    FString DisplayPrice;                                                             // 0x0030 (size: 0x10)

}; // Size: 0x40

class UMicroTransactionBase : public UPlatformInterfaceBase
{
    TArray<FPurchaseInfo> AvailableProducts;                                          // 0x0038 (size: 0x10)
    FString LastError;                                                                // 0x0048 (size: 0x10)
    FString LastErrorSolution;                                                        // 0x0058 (size: 0x10)

}; // Size: 0x68

class UModelComponent : public UPrimitiveComponent
{
    class UBodySetup* ModelBodySetup;                                                 // 0x0468 (size: 0x8)

}; // Size: 0x490

class UMorphTarget : public UObject
{
    class USkeletalMesh* BaseSkelMesh;                                                // 0x0028 (size: 0x8)

}; // Size: 0x40

class INavAgentInterface : public IInterface
{
}; // Size: 0x28

class UNavAreaBase : public UObject
{
}; // Size: 0x30

class UNavCollisionBase : public UObject
{
    uint8 bIsDynamicObstacle;                                                         // 0x0028 (size: 0x1)

}; // Size: 0x70

class INavEdgeProviderInterface : public IInterface
{
}; // Size: 0x28

class UNavigationDataChunk : public UObject
{
    FName NavigationDataName;                                                         // 0x0028 (size: 0x8)

}; // Size: 0x30

class INavigationDataInterface : public IInterface
{
}; // Size: 0x28

class UNavigationSystemBase : public UObject
{
}; // Size: 0x28

struct FNavAgentSelector
{
    uint8 bSupportsAgent0;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent1;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent2;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent3;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent4;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent5;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent6;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent7;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent8;                                                            // 0x0001 (size: 0x1)
    uint8 bSupportsAgent9;                                                            // 0x0001 (size: 0x1)
    uint8 bSupportsAgent10;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent11;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent12;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent13;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent14;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent15;                                                           // 0x0001 (size: 0x1)

}; // Size: 0x4

class UNavigationSystemConfig : public UObject
{
    FSoftClassPath NavigationSystemClass;                                             // 0x0028 (size: 0x18)
    FNavAgentSelector SupportedAgentsMask;                                            // 0x0040 (size: 0x4)
    FName DefaultAgentName;                                                           // 0x0044 (size: 0x8)
    uint8 bIsOverriden;                                                               // 0x004C (size: 0x1)

}; // Size: 0x50

class UNullNavSysConfig : public UNavigationSystemConfig
{
}; // Size: 0x50

struct FNavigationLinkBase
{
    float LeftProjectHeight;                                                          // 0x0000 (size: 0x4)
    float MaxFallDownLength;                                                          // 0x0004 (size: 0x4)
    float SnapRadius;                                                                 // 0x000C (size: 0x4)
    float SnapHeight;                                                                 // 0x0010 (size: 0x4)
    FNavAgentSelector SupportedAgents;                                                // 0x0014 (size: 0x4)
    uint8 bSupportsAgent0;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent1;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent2;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent3;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent4;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent5;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent6;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent7;                                                            // 0x0018 (size: 0x1)
    uint8 bSupportsAgent8;                                                            // 0x0019 (size: 0x1)
    uint8 bSupportsAgent9;                                                            // 0x0019 (size: 0x1)
    uint8 bSupportsAgent10;                                                           // 0x0019 (size: 0x1)
    uint8 bSupportsAgent11;                                                           // 0x0019 (size: 0x1)
    uint8 bSupportsAgent12;                                                           // 0x0019 (size: 0x1)
    uint8 bSupportsAgent13;                                                           // 0x0019 (size: 0x1)
    uint8 bSupportsAgent14;                                                           // 0x0019 (size: 0x1)
    uint8 bSupportsAgent15;                                                           // 0x0019 (size: 0x1)
    TEnumAsByte<ENavLinkDirection::Type> Direction;                                   // 0x001C (size: 0x1)
    uint8 bUseSnapHeight;                                                             // 0x001D (size: 0x1)
    uint8 bSnapToCheapestArea;                                                        // 0x001D (size: 0x1)
    uint8 bCustomFlag0;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag1;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag2;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag3;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag4;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag5;                                                               // 0x001D (size: 0x1)
    uint8 bCustomFlag6;                                                               // 0x001E (size: 0x1)
    uint8 bCustomFlag7;                                                               // 0x001E (size: 0x1)
    TSubclassOf<class UNavAreaBase> AreaClass;                                        // 0x0020 (size: 0x8)

}; // Size: 0x30

struct FNavigationLink : public FNavigationLinkBase
{
    FVector Left;                                                                     // 0x0030 (size: 0xC)
    FVector Right;                                                                    // 0x003C (size: 0xC)

}; // Size: 0x48

struct FNavigationSegmentLink : public FNavigationLinkBase
{
    FVector LeftStart;                                                                // 0x0030 (size: 0xC)
    FVector LeftEnd;                                                                  // 0x003C (size: 0xC)
    FVector RightStart;                                                               // 0x0048 (size: 0xC)
    FVector RightEnd;                                                                 // 0x0054 (size: 0xC)

}; // Size: 0x60

class UNavLinkDefinition : public UObject
{
    TArray<FNavigationLink> Links;                                                    // 0x0028 (size: 0x10)
    TArray<FNavigationSegmentLink> SegmentLinks;                                      // 0x0038 (size: 0x10)

}; // Size: 0x50

class INavPathObserverInterface : public IInterface
{
}; // Size: 0x28

class INavRelevantInterface : public IInterface
{
}; // Size: 0x28

class USimulatedClientNetConnection : public UNetConnection
{
}; // Size: 0x1BA8

class UNetPushModelHelpers : public UBlueprintFunctionLibrary
{

    void MarkPropertyDirtyFromRepIndex(class UObject* Object, int32 RepIndex, FName PropertyName);
    void MarkPropertyDirty(class UObject* Object, FName PropertyName);
}; // Size: 0x28

class INetworkPredictionInterface : public IInterface
{
}; // Size: 0x28

struct FNetworkEmulationProfileDescription
{
    FString ProfileName;                                                              // 0x0000 (size: 0x10)
    FString Tooltip;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

class UNetworkSettings : public UDeveloperSettings
{
    uint8 bVerifyPeer;                                                                // 0x0038 (size: 0x1)
    uint8 bEnableMultiplayerWorldOriginRebasing;                                      // 0x0038 (size: 0x1)
    int32 MaxRepArraySize;                                                            // 0x003C (size: 0x4)
    int32 MaxRepArrayMemory;                                                          // 0x0040 (size: 0x4)
    TArray<FNetworkEmulationProfileDescription> NetworkEmulationProfiles;             // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FNodeItem
{
    FName ParentName;                                                                 // 0x0000 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)

}; // Size: 0x40

class UNodeMappingContainer : public UObject
{
    TMap<class FName, class FNodeItem> SourceItems;                                   // 0x0028 (size: 0x50)
    TMap<class FName, class FNodeItem> TargetItems;                                   // 0x0078 (size: 0x50)
    TMap<class FName, class FName> SourceToTarget;                                    // 0x00C8 (size: 0x50)
    TSoftObjectPtr<UObject> SourceAsset;                                              // 0x0118 (size: 0x28)
    TSoftObjectPtr<UObject> TargetAsset;                                              // 0x0140 (size: 0x28)

}; // Size: 0x168

class INodeMappingProviderInterface : public IInterface
{
}; // Size: 0x28

class ANote : public AActor
{
}; // Size: 0x228

class UObjectLibrary : public UObject
{
    UClass* ObjectBaseClass;                                                          // 0x0028 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0030 (size: 0x1)
    TArray<class UObject*> Objects;                                                   // 0x0038 (size: 0x10)
    TArray<TWeakObjectPtr<UObject>> WeakObjects;                                      // 0x0048 (size: 0x10)
    bool bUseWeakReferences;                                                          // 0x0058 (size: 0x1)
    bool bIsFullyLoaded;                                                              // 0x0059 (size: 0x1)

}; // Size: 0xA8

class UObjectReferencer : public UObject
{
    TArray<class UObject*> ReferencedObjects;                                         // 0x0028 (size: 0x10)

}; // Size: 0x38

class UObjectTraceWorldSubsystem : public UWorldSubsystem
{
}; // Size: 0x38

class UPackageMapClient : public UPackageMap
{
}; // Size: 0x408

class APainCausingVolume : public APhysicsVolume
{
    uint8 bPainCausing;                                                               // 0x0270 (size: 0x1)
    float DamagePerSec;                                                               // 0x0274 (size: 0x4)
    TSubclassOf<class UDamageType> DamageType;                                        // 0x0278 (size: 0x8)
    float PainInterval;                                                               // 0x0280 (size: 0x4)
    uint8 bEntryPain;                                                                 // 0x0284 (size: 0x1)
    uint8 BACKUP_bPainCausing;                                                        // 0x0284 (size: 0x1)
    class AController* DamageInstigator;                                              // 0x0288 (size: 0x8)

}; // Size: 0x298

class UParticleEmitter : public UObject
{
    FName EmitterName;                                                                // 0x0028 (size: 0x8)
    int32 SubUVDataOffset;                                                            // 0x0030 (size: 0x4)
    TEnumAsByte<EEmitterRenderMode> EmitterRenderMode;                                // 0x0034 (size: 0x1)
    EParticleSignificanceLevel SignificanceLevel;                                     // 0x0035 (size: 0x1)
    uint8 bUseLegacySpawningBehavior;                                                 // 0x0037 (size: 0x1)
    uint8 ConvertedModules;                                                           // 0x0037 (size: 0x1)
    uint8 bIsSoloing;                                                                 // 0x0037 (size: 0x1)
    uint8 bCookedOut;                                                                 // 0x0037 (size: 0x1)
    uint8 bDisabledLODsKeepEmitterAlive;                                              // 0x0037 (size: 0x1)
    uint8 bDisableWhenInsignficant;                                                   // 0x0038 (size: 0x1)
    TArray<class UParticleLODLevel*> LODLevels;                                       // 0x0040 (size: 0x10)
    int32 PeakActiveParticles;                                                        // 0x0050 (size: 0x4)
    int32 InitialAllocationCount;                                                     // 0x0054 (size: 0x4)
    float QualityLevelSpawnRateScale;                                                 // 0x0058 (size: 0x4)
    uint32 DetailModeBitmask;                                                         // 0x005C (size: 0x4)

}; // Size: 0x1B8

class AParticleEventManager : public AActor
{
}; // Size: 0x228

class UParticleLODLevel : public UObject
{
    int32 Level;                                                                      // 0x0028 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x002C (size: 0x1)
    class UParticleModuleRequired* RequiredModule;                                    // 0x0030 (size: 0x8)
    TArray<class UParticleModule*> Modules;                                           // 0x0038 (size: 0x10)
    class UParticleModuleTypeDataBase* TypeDataModule;                                // 0x0048 (size: 0x8)
    class UParticleModuleSpawn* SpawnModule;                                          // 0x0050 (size: 0x8)
    class UParticleModuleEventGenerator* EventGenerator;                              // 0x0058 (size: 0x8)
    TArray<class UParticleModuleSpawnBase*> SpawningModules;                          // 0x0060 (size: 0x10)
    TArray<class UParticleModule*> SpawnModules;                                      // 0x0070 (size: 0x10)
    TArray<class UParticleModule*> UpdateModules;                                     // 0x0080 (size: 0x10)
    TArray<class UParticleModuleOrbit*> OrbitModules;                                 // 0x0090 (size: 0x10)
    TArray<class UParticleModuleEventReceiverBase*> EventReceiverModules;             // 0x00A0 (size: 0x10)
    uint8 ConvertedModules;                                                           // 0x00B0 (size: 0x1)
    int32 PeakActiveParticles;                                                        // 0x00B4 (size: 0x4)

}; // Size: 0xB8

struct FParticleSystemLOD
{
}; // Size: 0x1

struct FLODSoloTrack
{
    TArray<uint8> SoloEnableSetting;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FNamedEmitterMaterial
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

class UParticleSystem : public UFXSystemAsset
{
    float UpdateTime_FPS;                                                             // 0x0030 (size: 0x4)
    float UpdateTime_Delta;                                                           // 0x0034 (size: 0x4)
    float WarmupTime;                                                                 // 0x0038 (size: 0x4)
    float WarmupTickRate;                                                             // 0x003C (size: 0x4)
    TArray<class UParticleEmitter*> Emitters;                                         // 0x0040 (size: 0x10)
    class UParticleSystemComponent* PreviewComponent;                                 // 0x0050 (size: 0x8)
    class UInterpCurveEdSetup* CurveEdSetup;                                          // 0x0058 (size: 0x8)
    float LODDistanceCheckTime;                                                       // 0x0060 (size: 0x4)
    float MacroUVRadius;                                                              // 0x0064 (size: 0x4)
    TArray<float> LODDistances;                                                       // 0x0068 (size: 0x10)
    TArray<FParticleSystemLOD> LODSettings;                                           // 0x0078 (size: 0x10)
    FBox FixedRelativeBoundingBox;                                                    // 0x0088 (size: 0x1C)
    float SecondsBeforeInactive;                                                      // 0x00A4 (size: 0x4)
    float Delay;                                                                      // 0x00A8 (size: 0x4)
    float DelayLow;                                                                   // 0x00AC (size: 0x4)
    uint8 bOrientZAxisTowardCamera;                                                   // 0x00B0 (size: 0x1)
    uint8 bUseFixedRelativeBoundingBox;                                               // 0x00B0 (size: 0x1)
    uint8 bShouldResetPeakCounts;                                                     // 0x00B0 (size: 0x1)
    uint8 bHasPhysics;                                                                // 0x00B0 (size: 0x1)
    uint8 bUseRealtimeThumbnail;                                                      // 0x00B0 (size: 0x1)
    uint8 ThumbnailImageOutOfDate;                                                    // 0x00B0 (size: 0x1)
    uint8 bUseDelayRange;                                                             // 0x00B1 (size: 0x1)
    uint8 bAllowManagedTicking;                                                       // 0x00B1 (size: 0x1)
    uint8 bAutoDeactivate;                                                            // 0x00B1 (size: 0x1)
    uint8 bRegenerateLODDuplicate;                                                    // 0x00B1 (size: 0x1)
    TEnumAsByte<EParticleSystemUpdateMode> SystemUpdateMode;                          // 0x00B2 (size: 0x1)
    TEnumAsByte<ParticleSystemLODMethod> LODMethod;                                   // 0x00B3 (size: 0x1)
    EParticleSystemInsignificanceReaction InsignificantReaction;                      // 0x00B4 (size: 0x1)
    TEnumAsByte<EParticleSystemOcclusionBoundsMethod> OcclusionBoundsMethod;          // 0x00B5 (size: 0x1)
    EParticleSignificanceLevel MaxSignificanceLevel;                                  // 0x00B7 (size: 0x1)
    uint32 MinTimeBetweenTicks;                                                       // 0x00B8 (size: 0x4)
    float InsignificanceDelay;                                                        // 0x00BC (size: 0x4)
    FVector MacroUVPosition;                                                          // 0x00C0 (size: 0xC)
    FBox CustomOcclusionBounds;                                                       // 0x00CC (size: 0x1C)
    TArray<FLODSoloTrack> SoloTracking;                                               // 0x00E8 (size: 0x10)
    TArray<FNamedEmitterMaterial> NamedMaterialSlots;                                 // 0x00F8 (size: 0x10)

    bool ContainsEmitterType(UClass* TypeData);
}; // Size: 0x110

class UParticleModule : public UObject
{
    uint8 bSpawnModule;                                                               // 0x0028 (size: 0x1)
    uint8 bUpdateModule;                                                              // 0x0028 (size: 0x1)
    uint8 bFinalUpdateModule;                                                         // 0x0028 (size: 0x1)
    uint8 bUpdateForGPUEmitter;                                                       // 0x0028 (size: 0x1)
    uint8 bCurvesAsColor;                                                             // 0x0028 (size: 0x1)
    uint8 b3DDrawMode;                                                                // 0x0028 (size: 0x1)
    uint8 bSupported3DDrawMode;                                                       // 0x0028 (size: 0x1)
    uint8 bEnabled;                                                                   // 0x0028 (size: 0x1)
    uint8 bEditable;                                                                  // 0x0029 (size: 0x1)
    uint8 LODDuplicate;                                                               // 0x0029 (size: 0x1)
    uint8 bSupportsRandomSeed;                                                        // 0x0029 (size: 0x1)
    uint8 bRequiresLoopingNotification;                                               // 0x0029 (size: 0x1)
    uint8 LODValidity;                                                                // 0x002A (size: 0x1)

}; // Size: 0x30

class UParticleModuleAccelerationBase : public UParticleModule
{
    uint8 bAlwaysInWorldSpace;                                                        // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FDistributionLookupTable
{
    float TimeScale;                                                                  // 0x0000 (size: 0x4)
    float TimeBias;                                                                   // 0x0004 (size: 0x4)
    TArray<float> Values;                                                             // 0x0008 (size: 0x10)
    uint8 Op;                                                                         // 0x0018 (size: 0x1)
    uint8 EntryCount;                                                                 // 0x0019 (size: 0x1)
    uint8 EntryStride;                                                                // 0x001A (size: 0x1)
    uint8 SubEntryStride;                                                             // 0x001B (size: 0x1)
    uint8 LockFlag;                                                                   // 0x001C (size: 0x1)

}; // Size: 0x20

struct FRawDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FRawDistributionVector : public FRawDistribution
{
    float MinValue;                                                                   // 0x0020 (size: 0x4)
    float MaxValue;                                                                   // 0x0024 (size: 0x4)
    FVector MinValueVec;                                                              // 0x0028 (size: 0xC)
    FVector MaxValueVec;                                                              // 0x0034 (size: 0xC)
    class UDistributionVector* Distribution;                                          // 0x0040 (size: 0x8)

}; // Size: 0x48

class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
    FRawDistributionVector Acceleration;                                              // 0x0038 (size: 0x48)
    uint8 bApplyOwnerScale;                                                           // 0x0080 (size: 0x1)

}; // Size: 0x88

class UParticleModuleAccelerationConstant : public UParticleModuleAccelerationBase
{
    FVector Acceleration;                                                             // 0x0038 (size: 0xC)

}; // Size: 0x48

struct FRawDistributionFloat : public FRawDistribution
{
    float MinValue;                                                                   // 0x0020 (size: 0x4)
    float MaxValue;                                                                   // 0x0024 (size: 0x4)
    class UDistributionFloat* Distribution;                                           // 0x0028 (size: 0x8)

}; // Size: 0x30

class UParticleModuleAccelerationDrag : public UParticleModuleAccelerationBase
{
    class UDistributionFloat* DragCoefficient;                                        // 0x0038 (size: 0x8)
    FRawDistributionFloat DragCoefficientRaw;                                         // 0x0040 (size: 0x30)

}; // Size: 0x70

class UParticleModuleAccelerationDragScaleOverLife : public UParticleModuleAccelerationBase
{
    class UDistributionFloat* DragScale;                                              // 0x0038 (size: 0x8)
    FRawDistributionFloat DragScaleRaw;                                               // 0x0040 (size: 0x30)

}; // Size: 0x70

class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
    FRawDistributionVector AccelOverLife;                                             // 0x0038 (size: 0x48)

}; // Size: 0x80

class UParticleModuleAttractorBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
    FVector EndPoint0;                                                                // 0x0030 (size: 0xC)
    FVector EndPoint1;                                                                // 0x003C (size: 0xC)
    FRawDistributionFloat Range;                                                      // 0x0048 (size: 0x30)
    FRawDistributionFloat Strength;                                                   // 0x0078 (size: 0x30)

}; // Size: 0xA8

class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)
    FRawDistributionFloat Range;                                                      // 0x0038 (size: 0x30)
    uint8 bStrengthByDistance;                                                        // 0x0068 (size: 0x1)
    FRawDistributionFloat Strength;                                                   // 0x0070 (size: 0x30)
    uint8 bAffectBaseVelocity;                                                        // 0x00A0 (size: 0x1)
    TEnumAsByte<EAttractorParticleSelectionMethod> SelectionMethod;                   // 0x00A4 (size: 0x1)
    uint8 bRenewSource;                                                               // 0x00A8 (size: 0x1)
    uint8 bInheritSourceVel;                                                          // 0x00A8 (size: 0x1)
    int32 LastSelIndex;                                                               // 0x00AC (size: 0x4)

}; // Size: 0xB0

class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
    FRawDistributionVector Position;                                                  // 0x0030 (size: 0x48)
    FRawDistributionFloat Range;                                                      // 0x0078 (size: 0x30)
    FRawDistributionFloat Strength;                                                   // 0x00A8 (size: 0x30)
    uint8 StrengthByDistance;                                                         // 0x00D8 (size: 0x1)
    uint8 bAffectBaseVelocity;                                                        // 0x00D8 (size: 0x1)
    uint8 bOverrideVelocity;                                                          // 0x00D8 (size: 0x1)
    uint8 bUseWorldSpacePosition;                                                     // 0x00D8 (size: 0x1)
    uint8 Positive_X;                                                                 // 0x00D8 (size: 0x1)
    uint8 Positive_Y;                                                                 // 0x00D8 (size: 0x1)
    uint8 Positive_Z;                                                                 // 0x00D8 (size: 0x1)
    uint8 Negative_X;                                                                 // 0x00D8 (size: 0x1)
    uint8 Negative_Y;                                                                 // 0x00D9 (size: 0x1)
    uint8 Negative_Z;                                                                 // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UParticleModuleAttractorPointGravity : public UParticleModuleAttractorBase
{
    FVector Position;                                                                 // 0x0030 (size: 0xC)
    float Radius;                                                                     // 0x003C (size: 0x4)
    class UDistributionFloat* Strength;                                               // 0x0040 (size: 0x8)
    FRawDistributionFloat StrengthRaw;                                                // 0x0048 (size: 0x30)

}; // Size: 0x78

class UParticleModuleBeamBase : public UParticleModule
{
}; // Size: 0x30

struct FBeamModifierOptions
{
    uint8 bModify;                                                                    // 0x0000 (size: 0x1)
    uint8 bScale;                                                                     // 0x0000 (size: 0x1)
    uint8 bLock;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x4

class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
    TEnumAsByte<BeamModifierType> ModifierType;                                       // 0x0030 (size: 0x1)
    FBeamModifierOptions PositionOptions;                                             // 0x0034 (size: 0x4)
    FRawDistributionVector Position;                                                  // 0x0038 (size: 0x48)
    FBeamModifierOptions TangentOptions;                                              // 0x0080 (size: 0x4)
    FRawDistributionVector Tangent;                                                   // 0x0088 (size: 0x48)
    uint8 bAbsoluteTangent;                                                           // 0x00D0 (size: 0x1)
    FBeamModifierOptions StrengthOptions;                                             // 0x00D4 (size: 0x4)
    FRawDistributionFloat Strength;                                                   // 0x00D8 (size: 0x30)

}; // Size: 0x108

class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
    uint8 bLowFreq_Enabled;                                                           // 0x0030 (size: 0x1)
    int32 Frequency;                                                                  // 0x0034 (size: 0x4)
    int32 Frequency_LowRange;                                                         // 0x0038 (size: 0x4)
    FRawDistributionVector NoiseRange;                                                // 0x0040 (size: 0x48)
    FRawDistributionFloat NoiseRangeScale;                                            // 0x0088 (size: 0x30)
    uint8 bNRScaleEmitterTime;                                                        // 0x00B8 (size: 0x1)
    FRawDistributionVector NoiseSpeed;                                                // 0x00C0 (size: 0x48)
    uint8 bSmooth;                                                                    // 0x0108 (size: 0x1)
    float NoiseLockRadius;                                                            // 0x010C (size: 0x4)
    uint8 bNoiseLock;                                                                 // 0x0110 (size: 0x1)
    uint8 bOscillate;                                                                 // 0x0110 (size: 0x1)
    float NoiseLockTime;                                                              // 0x0114 (size: 0x4)
    float NoiseTension;                                                               // 0x0118 (size: 0x4)
    uint8 bUseNoiseTangents;                                                          // 0x011C (size: 0x1)
    FRawDistributionFloat NoiseTangentStrength;                                       // 0x0120 (size: 0x30)
    int32 NoiseTessellation;                                                          // 0x0150 (size: 0x4)
    uint8 bTargetNoise;                                                               // 0x0154 (size: 0x1)
    float FrequencyDistance;                                                          // 0x0158 (size: 0x4)
    uint8 bApplyNoiseScale;                                                           // 0x015C (size: 0x1)
    FRawDistributionFloat NoiseScale;                                                 // 0x0160 (size: 0x30)

}; // Size: 0x190

class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
    TEnumAsByte<Beam2SourceTargetMethod> SourceMethod;                                // 0x0030 (size: 0x1)
    FName SourceName;                                                                 // 0x0034 (size: 0x8)
    uint8 bSourceAbsolute;                                                            // 0x003C (size: 0x1)
    FRawDistributionVector Source;                                                    // 0x0040 (size: 0x48)
    uint8 bLockSource;                                                                // 0x0088 (size: 0x1)
    TEnumAsByte<Beam2SourceTargetTangentMethod> SourceTangentMethod;                  // 0x008C (size: 0x1)
    FRawDistributionVector SourceTangent;                                             // 0x0090 (size: 0x48)
    uint8 bLockSourceTangent;                                                         // 0x00D8 (size: 0x1)
    FRawDistributionFloat SourceStrength;                                             // 0x00E0 (size: 0x30)
    uint8 bLockSourceStength;                                                         // 0x0110 (size: 0x1)

}; // Size: 0x118

class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
    TEnumAsByte<Beam2SourceTargetMethod> TargetMethod;                                // 0x0030 (size: 0x1)
    FName TargetName;                                                                 // 0x0034 (size: 0x8)
    FRawDistributionVector Target;                                                    // 0x0040 (size: 0x48)
    uint8 bTargetAbsolute;                                                            // 0x0088 (size: 0x1)
    uint8 bLockTarget;                                                                // 0x0088 (size: 0x1)
    TEnumAsByte<Beam2SourceTargetTangentMethod> TargetTangentMethod;                  // 0x008C (size: 0x1)
    FRawDistributionVector TargetTangent;                                             // 0x0090 (size: 0x48)
    uint8 bLockTargetTangent;                                                         // 0x00D8 (size: 0x1)
    FRawDistributionFloat TargetStrength;                                             // 0x00E0 (size: 0x30)
    uint8 bLockTargetStength;                                                         // 0x0110 (size: 0x1)
    float LockRadius;                                                                 // 0x0114 (size: 0x4)

}; // Size: 0x120

class UParticleModuleCameraBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleCameraOffset : public UParticleModuleCameraBase
{
    FRawDistributionFloat CameraOffset;                                               // 0x0030 (size: 0x30)
    uint8 bSpawnTimeOnly;                                                             // 0x0060 (size: 0x1)
    TEnumAsByte<EParticleCameraOffsetUpdateMethod> UpdateMethod;                      // 0x0064 (size: 0x1)

}; // Size: 0x68

class UParticleModuleCollisionBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleCollision : public UParticleModuleCollisionBase
{
    FRawDistributionVector DampingFactor;                                             // 0x0030 (size: 0x48)
    FRawDistributionVector DampingFactorRotation;                                     // 0x0078 (size: 0x48)
    FRawDistributionFloat MaxCollisions;                                              // 0x00C0 (size: 0x30)
    TEnumAsByte<EParticleCollisionComplete> CollisionCompletionOption;                // 0x00F0 (size: 0x1)
    TArray<TEnumAsByte<EObjectTypeQuery>> CollisionTypes;                             // 0x00F8 (size: 0x10)
    uint8 bApplyPhysics;                                                              // 0x0110 (size: 0x1)
    uint8 bIgnoreTriggerVolumes;                                                      // 0x0110 (size: 0x1)
    FRawDistributionFloat ParticleMass;                                               // 0x0118 (size: 0x30)
    float DirScalar;                                                                  // 0x0148 (size: 0x4)
    uint8 bPawnsDoNotDecrementCount;                                                  // 0x014C (size: 0x1)
    uint8 bOnlyVerticalNormalsDecrementCount;                                         // 0x014C (size: 0x1)
    float VerticalFudgeFactor;                                                        // 0x0150 (size: 0x4)
    FRawDistributionFloat DelayAmount;                                                // 0x0158 (size: 0x30)
    uint8 bDropDetail;                                                                // 0x0188 (size: 0x1)
    uint8 bCollideOnlyIfVisible;                                                      // 0x0188 (size: 0x1)
    uint8 bIgnoreSourceActor;                                                         // 0x0188 (size: 0x1)
    float MaxCollisionDistance;                                                       // 0x018C (size: 0x4)

}; // Size: 0x190

class UParticleModuleCollisionGPU : public UParticleModuleCollisionBase
{
    FRawDistributionFloat Resilience;                                                 // 0x0030 (size: 0x30)
    FRawDistributionFloat ResilienceScaleOverLife;                                    // 0x0060 (size: 0x30)
    float Friction;                                                                   // 0x0090 (size: 0x4)
    float RandomSpread;                                                               // 0x0094 (size: 0x4)
    float RandomDistribution;                                                         // 0x0098 (size: 0x4)
    float RadiusScale;                                                                // 0x009C (size: 0x4)
    float RadiusBias;                                                                 // 0x00A0 (size: 0x4)
    TEnumAsByte<EParticleCollisionResponse::Type> Response;                           // 0x00A4 (size: 0x1)
    TEnumAsByte<EParticleCollisionMode::Type> CollisionMode;                          // 0x00A5 (size: 0x1)

}; // Size: 0xA8

class UParticleModuleColorBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleColor : public UParticleModuleColorBase
{
    FRawDistributionVector StartColor;                                                // 0x0030 (size: 0x48)
    FRawDistributionFloat StartAlpha;                                                 // 0x0078 (size: 0x30)
    uint8 bClampAlpha;                                                                // 0x00A8 (size: 0x1)

}; // Size: 0xB0

struct FParticleRandomSeedInfo
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    uint8 bGetSeedFromInstance;                                                       // 0x0008 (size: 0x1)
    uint8 bInstanceSeedIsIndex;                                                       // 0x0008 (size: 0x1)
    uint8 bResetSeedOnEmitterLooping;                                                 // 0x0008 (size: 0x1)
    uint8 bRandomlySelectSeedArray;                                                   // 0x0008 (size: 0x1)
    TArray<int32> RandomSeeds;                                                        // 0x0010 (size: 0x10)

}; // Size: 0x20

class UParticleModuleColor_Seeded : public UParticleModuleColor
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00B0 (size: 0x20)

}; // Size: 0xD0

class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
    FRawDistributionVector ColorOverLife;                                             // 0x0030 (size: 0x48)
    FRawDistributionFloat AlphaOverLife;                                              // 0x0078 (size: 0x30)
    uint8 bClampAlpha;                                                                // 0x00A8 (size: 0x1)

}; // Size: 0xB0

class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
    FRawDistributionVector ColorScaleOverLife;                                        // 0x0030 (size: 0x48)
    FRawDistributionFloat AlphaScaleOverLife;                                         // 0x0078 (size: 0x30)
    uint8 bEmitterTime;                                                               // 0x00A8 (size: 0x1)

}; // Size: 0xB0

class UParticleModuleEventBase : public UParticleModule
{
}; // Size: 0x30

struct FParticleEvent_GenerateInfo
{
    TEnumAsByte<EParticleEventType> Type;                                             // 0x0000 (size: 0x1)
    int32 Frequency;                                                                  // 0x0004 (size: 0x4)
    int32 ParticleFrequency;                                                          // 0x0008 (size: 0x4)
    uint8 FirstTimeOnly;                                                              // 0x000C (size: 0x1)
    uint8 LastTimeOnly;                                                               // 0x000C (size: 0x1)
    uint8 UseReflectedImpactVector;                                                   // 0x000C (size: 0x1)
    uint8 bUseOrbitOffset;                                                            // 0x000C (size: 0x1)
    FName CustomName;                                                                 // 0x0010 (size: 0x8)
    TArray<class UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;   // 0x0018 (size: 0x10)

}; // Size: 0x28

class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
    TArray<FParticleEvent_GenerateInfo> Events;                                       // 0x0030 (size: 0x10)

}; // Size: 0x40

class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
    TEnumAsByte<EParticleEventType> EventGeneratorType;                               // 0x0030 (size: 0x1)
    FName EventName;                                                                  // 0x0034 (size: 0x8)

}; // Size: 0x40

class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase
{
    uint8 bStopSpawning;                                                              // 0x0040 (size: 0x1)

}; // Size: 0x48

class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
    FRawDistributionFloat SpawnCount;                                                 // 0x0040 (size: 0x30)
    uint8 bUseParticleTime;                                                           // 0x0070 (size: 0x1)
    uint8 bUsePSysLocation;                                                           // 0x0070 (size: 0x1)
    uint8 bInheritVelocity;                                                           // 0x0070 (size: 0x1)
    FRawDistributionVector InheritVelocityScale;                                      // 0x0078 (size: 0x48)
    TArray<class UPhysicalMaterial*> PhysicalMaterials;                               // 0x00C0 (size: 0x10)
    uint8 bBanPhysicalMaterials;                                                      // 0x00D0 (size: 0x1)

}; // Size: 0xD8

class UParticleModuleEventSendToGame : public UObject
{
}; // Size: 0x28

class UParticleModuleKillBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleKillBox : public UParticleModuleKillBase
{
    FRawDistributionVector LowerLeftCorner;                                           // 0x0030 (size: 0x48)
    FRawDistributionVector UpperRightCorner;                                          // 0x0078 (size: 0x48)
    uint8 bAbsolute;                                                                  // 0x00C0 (size: 0x1)
    uint8 bKillInside;                                                                // 0x00C0 (size: 0x1)
    uint8 bAxisAlignedAndFixedSize;                                                   // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class UParticleModuleKillHeight : public UParticleModuleKillBase
{
    FRawDistributionFloat Height;                                                     // 0x0030 (size: 0x30)
    uint8 bAbsolute;                                                                  // 0x0060 (size: 0x1)
    uint8 bFloor;                                                                     // 0x0060 (size: 0x1)
    uint8 bApplyPSysScale;                                                            // 0x0060 (size: 0x1)

}; // Size: 0x68

class UParticleModuleLifetimeBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
    FRawDistributionFloat LifeTime;                                                   // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleLightBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLight : public UParticleModuleLightBase
{
    bool bUseInverseSquaredFalloff;                                                   // 0x0030 (size: 0x1)
    bool bAffectsTranslucency;                                                        // 0x0031 (size: 0x1)
    bool bPreviewLightRadius;                                                         // 0x0032 (size: 0x1)
    float SpawnFraction;                                                              // 0x0034 (size: 0x4)
    FRawDistributionVector ColorScaleOverLife;                                        // 0x0038 (size: 0x48)
    FRawDistributionFloat BrightnessOverLife;                                         // 0x0080 (size: 0x30)
    FRawDistributionFloat RadiusScale;                                                // 0x00B0 (size: 0x30)
    FRawDistributionFloat LightExponent;                                              // 0x00E0 (size: 0x30)
    FLightingChannels LightingChannels;                                               // 0x0110 (size: 0x1)
    float VolumetricScatteringIntensity;                                              // 0x0114 (size: 0x4)
    bool bHighQualityLights;                                                          // 0x0118 (size: 0x1)
    bool bShadowCastingLights;                                                        // 0x0119 (size: 0x1)

}; // Size: 0x120

class UParticleModuleLight_Seeded : public UParticleModuleLight
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0120 (size: 0x20)

}; // Size: 0x140

class UParticleModuleLocationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLocation : public UParticleModuleLocationBase
{
    FRawDistributionVector StartLocation;                                             // 0x0030 (size: 0x48)
    float DistributeOverNPoints;                                                      // 0x0078 (size: 0x4)
    float DistributeThreshold;                                                        // 0x007C (size: 0x4)

}; // Size: 0x80

class UParticleModuleLocation_Seeded : public UParticleModuleLocation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0080 (size: 0x20)

}; // Size: 0xA0

struct FLocationBoneSocketInfo
{
    FName BoneSocketName;                                                             // 0x0000 (size: 0x8)
    FVector Offset;                                                                   // 0x0008 (size: 0xC)

}; // Size: 0x14

class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase
{
    TEnumAsByte<ELocationBoneSocketSource> SourceType;                                // 0x0030 (size: 0x1)
    FVector UniversalOffset;                                                          // 0x0034 (size: 0xC)
    TArray<FLocationBoneSocketInfo> SourceLocations;                                  // 0x0040 (size: 0x10)
    TEnumAsByte<ELocationBoneSocketSelectionMethod> SelectionMethod;                  // 0x0050 (size: 0x1)
    uint8 bUpdatePositionEachFrame;                                                   // 0x0054 (size: 0x1)
    uint8 bOrientMeshEmitters;                                                        // 0x0054 (size: 0x1)
    uint8 bInheritBoneVelocity;                                                       // 0x0054 (size: 0x1)
    float InheritVelocityScale;                                                       // 0x0058 (size: 0x4)
    FName SkelMeshActorParamName;                                                     // 0x005C (size: 0x8)
    int32 NumPreSelectedIndices;                                                      // 0x0064 (size: 0x4)

}; // Size: 0x70

class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
    FRawDistributionVector Location;                                                  // 0x0030 (size: 0x48)
    FRawDistributionVector LocationOffset;                                            // 0x0078 (size: 0x48)
    FRawDistributionVector ScaleFactor;                                               // 0x00C0 (size: 0x48)
    FRawDistributionVector Direction;                                                 // 0x0108 (size: 0x48)

}; // Size: 0x150

class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)
    TEnumAsByte<ELocationEmitterSelectionMethod> SelectionMethod;                     // 0x0038 (size: 0x1)
    uint8 InheritSourceVelocity;                                                      // 0x003C (size: 0x1)
    float InheritSourceVelocityScale;                                                 // 0x0040 (size: 0x4)
    uint8 bInheritSourceRotation;                                                     // 0x0044 (size: 0x1)
    float InheritSourceRotationScale;                                                 // 0x0048 (size: 0x4)

}; // Size: 0x50

class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)

}; // Size: 0x38

class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
    uint8 Positive_X;                                                                 // 0x0030 (size: 0x1)
    uint8 Positive_Y;                                                                 // 0x0030 (size: 0x1)
    uint8 Positive_Z;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_X;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_Y;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_Z;                                                                 // 0x0030 (size: 0x1)
    uint8 SurfaceOnly;                                                                // 0x0030 (size: 0x1)
    uint8 Velocity;                                                                   // 0x0030 (size: 0x1)
    FRawDistributionFloat VelocityScale;                                              // 0x0038 (size: 0x30)
    FRawDistributionVector StartLocation;                                             // 0x0068 (size: 0x48)

}; // Size: 0xB0

class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
    uint8 RadialVelocity;                                                             // 0x00B0 (size: 0x1)
    FRawDistributionFloat StartRadius;                                                // 0x00B8 (size: 0x30)
    FRawDistributionFloat StartHeight;                                                // 0x00E8 (size: 0x30)
    TEnumAsByte<CylinderHeightAxis> HeightAxis;                                       // 0x0118 (size: 0x1)

}; // Size: 0x120

class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0120 (size: 0x20)

}; // Size: 0x140

class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
    FRawDistributionFloat StartRadius;                                                // 0x00B0 (size: 0x30)

}; // Size: 0xE0

class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00E0 (size: 0x20)

}; // Size: 0x100

class UParticleModuleLocationPrimitiveTriangle : public UParticleModuleLocationBase
{
    FRawDistributionVector StartOffset;                                               // 0x0030 (size: 0x48)
    FRawDistributionFloat Height;                                                     // 0x0078 (size: 0x30)
    FRawDistributionFloat Angle;                                                      // 0x00A8 (size: 0x30)
    FRawDistributionFloat Thickness;                                                  // 0x00D8 (size: 0x30)

}; // Size: 0x108

class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase
{
    TEnumAsByte<ELocationSkelVertSurfaceSource> SourceType;                           // 0x0030 (size: 0x1)
    FVector UniversalOffset;                                                          // 0x0034 (size: 0xC)
    uint8 bUpdatePositionEachFrame;                                                   // 0x0040 (size: 0x1)
    uint8 bOrientMeshEmitters;                                                        // 0x0040 (size: 0x1)
    uint8 bInheritBoneVelocity;                                                       // 0x0040 (size: 0x1)
    float InheritVelocityScale;                                                       // 0x0044 (size: 0x4)
    FName SkelMeshActorParamName;                                                     // 0x0048 (size: 0x8)
    TArray<FName> ValidAssociatedBones;                                               // 0x0050 (size: 0x10)
    uint8 bEnforceNormalCheck;                                                        // 0x0060 (size: 0x1)
    FVector NormalToCompare;                                                          // 0x0064 (size: 0xC)
    float NormalCheckToleranceDegrees;                                                // 0x0070 (size: 0x4)
    float NormalCheckTolerance;                                                       // 0x0074 (size: 0x4)
    TArray<int32> ValidMaterialIndices;                                               // 0x0078 (size: 0x10)
    uint8 bInheritVertexColor;                                                        // 0x0088 (size: 0x1)
    uint8 bInheritUV;                                                                 // 0x0088 (size: 0x1)
    uint32 InheritUVChannel;                                                          // 0x008C (size: 0x4)

}; // Size: 0x90

class UParticleModuleLocationWorldOffset : public UParticleModuleLocation
{
}; // Size: 0x80

class UParticleModuleLocationWorldOffset_Seeded : public UParticleModuleLocationWorldOffset
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0080 (size: 0x20)

}; // Size: 0xA0

class UParticleModuleMaterialBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
    TArray<class UMaterialInterface*> MeshMaterials;                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

class UParticleModuleRotationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
    FRawDistributionVector StartRotation;                                             // 0x0030 (size: 0x48)
    uint8 bInheritParent;                                                             // 0x0078 (size: 0x1)

}; // Size: 0x80

class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0080 (size: 0x20)

}; // Size: 0xA0

class UParticleModuleRotationRateBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
    FRawDistributionVector StartRotationRate;                                         // 0x0030 (size: 0x48)

}; // Size: 0x78

class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0078 (size: 0x20)

}; // Size: 0x98

class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
    FRawDistributionVector LifeMultiplier;                                            // 0x0030 (size: 0x48)

}; // Size: 0x78

class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase
{
    FRawDistributionVector RotRate;                                                   // 0x0030 (size: 0x48)
    uint8 bScaleRotRate;                                                              // 0x0078 (size: 0x1)

}; // Size: 0x80

class UParticleModuleOrbitBase : public UParticleModule
{
    uint8 bUseEmitterTime;                                                            // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FOrbitOptions
{
    uint8 bProcessDuringSpawn;                                                        // 0x0000 (size: 0x1)
    uint8 bProcessDuringUpdate;                                                       // 0x0000 (size: 0x1)
    uint8 bUseEmitterTime;                                                            // 0x0000 (size: 0x1)

}; // Size: 0x4

class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
    TEnumAsByte<EOrbitChainMode> ChainMode;                                           // 0x0038 (size: 0x1)
    FRawDistributionVector OffsetAmount;                                              // 0x0040 (size: 0x48)
    FOrbitOptions OffsetOptions;                                                      // 0x0088 (size: 0x4)
    FRawDistributionVector RotationAmount;                                            // 0x0090 (size: 0x48)
    FOrbitOptions RotationOptions;                                                    // 0x00D8 (size: 0x4)
    FRawDistributionVector RotationRateAmount;                                        // 0x00E0 (size: 0x48)
    FOrbitOptions RotationRateOptions;                                                // 0x0128 (size: 0x4)

}; // Size: 0x130

class UParticleModuleOrientationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
    TEnumAsByte<EParticleAxisLock> LockAxisFlags;                                     // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleParameterBase : public UParticleModule
{
}; // Size: 0x30

struct FEmitterDynamicParameter
{
    FName ParamName;                                                                  // 0x0000 (size: 0x8)
    uint8 bUseEmitterTime;                                                            // 0x0008 (size: 0x1)
    uint8 bSpawnTimeOnly;                                                             // 0x0008 (size: 0x1)
    TEnumAsByte<EEmitterDynamicParameterValue> ValueMethod;                           // 0x000C (size: 0x1)
    uint8 bScaleVelocityByParamValue;                                                 // 0x0010 (size: 0x1)
    FRawDistributionFloat ParamValue;                                                 // 0x0018 (size: 0x30)

}; // Size: 0x48

class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
    TArray<FEmitterDynamicParameter> DynamicParams;                                   // 0x0030 (size: 0x10)
    int32 UpdateFlags;                                                                // 0x0040 (size: 0x4)
    uint8 bUsesVelocity;                                                              // 0x0044 (size: 0x1)

}; // Size: 0x48

class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0048 (size: 0x20)

}; // Size: 0x68

class UParticleModulePivotOffset : public UParticleModuleLocationBase
{
    FVector2D PivotOffset;                                                            // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FParticleBurst
{
    int32 Count;                                                                      // 0x0000 (size: 0x4)
    int32 CountLow;                                                                   // 0x0004 (size: 0x4)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

class UParticleModuleRequired : public UParticleModule
{
    class UMaterialInterface* Material;                                               // 0x0030 (size: 0x8)
    float MinFacingCameraBlendDistance;                                               // 0x0038 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x003C (size: 0x4)
    FVector EmitterOrigin;                                                            // 0x0040 (size: 0xC)
    FRotator EmitterRotation;                                                         // 0x004C (size: 0xC)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0058 (size: 0x1)
    uint8 bUseLocalSpace;                                                             // 0x0059 (size: 0x1)
    uint8 bKillOnDeactivate;                                                          // 0x0059 (size: 0x1)
    uint8 bKillOnCompleted;                                                           // 0x0059 (size: 0x1)
    TEnumAsByte<EParticleSortMode> SortMode;                                          // 0x005A (size: 0x1)
    uint8 bUseLegacyEmitterTime;                                                      // 0x005B (size: 0x1)
    uint8 bRemoveHMDRoll;                                                             // 0x005B (size: 0x1)
    uint8 bEmitterDurationUseRange;                                                   // 0x005B (size: 0x1)
    float EmitterDuration;                                                            // 0x005C (size: 0x4)
    FRawDistributionFloat SpawnRate;                                                  // 0x0060 (size: 0x30)
    TArray<FParticleBurst> BurstList;                                                 // 0x0090 (size: 0x10)
    float EmitterDelay;                                                               // 0x00A0 (size: 0x4)
    float EmitterDelayLow;                                                            // 0x00A4 (size: 0x4)
    uint8 bDelayFirstLoopOnly;                                                        // 0x00A8 (size: 0x1)
    TEnumAsByte<EParticleSubUVInterpMethod> InterpolationMethod;                      // 0x00A9 (size: 0x1)
    uint8 bScaleUV;                                                                   // 0x00AA (size: 0x1)
    uint8 bEmitterDelayUseRange;                                                      // 0x00AA (size: 0x1)
    TEnumAsByte<EParticleBurstMethod> ParticleBurstMethod;                            // 0x00AB (size: 0x1)
    uint8 bOverrideSystemMacroUV;                                                     // 0x00AC (size: 0x1)
    uint8 bUseMaxDrawCount;                                                           // 0x00AC (size: 0x1)
    TEnumAsByte<EOpacitySourceMode> OpacitySourceMode;                                // 0x00AD (size: 0x1)
    TEnumAsByte<EEmitterNormalsMode> EmitterNormalsMode;                              // 0x00AE (size: 0x1)
    uint8 bOrbitModuleAffectsVelocityAlignment;                                       // 0x00AF (size: 0x1)
    int32 SubImages_Horizontal;                                                       // 0x00B0 (size: 0x4)
    int32 SubImages_Vertical;                                                         // 0x00B4 (size: 0x4)
    float RandomImageTime;                                                            // 0x00B8 (size: 0x4)
    int32 RandomImageChanges;                                                         // 0x00BC (size: 0x4)
    FVector MacroUVPosition;                                                          // 0x00C0 (size: 0xC)
    float MacroUVRadius;                                                              // 0x00CC (size: 0x4)
    EParticleUVFlipMode UVFlippingMode;                                               // 0x00D0 (size: 0x1)
    TEnumAsByte<ESubUVBoundingVertexCount> BoundingMode;                              // 0x00D1 (size: 0x1)
    uint8 bDurationRecalcEachLoop;                                                    // 0x00D2 (size: 0x1)
    FVector NormalsSphereCenter;                                                      // 0x00D4 (size: 0xC)
    float AlphaThreshold;                                                             // 0x00E0 (size: 0x4)
    int32 EmitterLoops;                                                               // 0x00E4 (size: 0x4)
    class UTexture2D* CutoutTexture;                                                  // 0x00E8 (size: 0x8)
    int32 MaxDrawCount;                                                               // 0x00F0 (size: 0x4)
    float EmitterDurationLow;                                                         // 0x00F4 (size: 0x4)
    FVector NormalsCylinderDirection;                                                 // 0x00F8 (size: 0xC)
    TArray<FName> NamedMaterialOverrides;                                             // 0x0108 (size: 0x10)

}; // Size: 0x140

class UParticleModuleRotation : public UParticleModuleRotationBase
{
    FRawDistributionFloat StartRotation;                                              // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleRotation_Seeded : public UParticleModuleRotation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
    FRawDistributionFloat RotationOverLife;                                           // 0x0030 (size: 0x30)
    uint8 Scale;                                                                      // 0x0060 (size: 0x1)

}; // Size: 0x68

class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
    FRawDistributionFloat StartRotationRate;                                          // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
    FRawDistributionFloat LifeMultiplier;                                             // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleSizeBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleSize : public UParticleModuleSizeBase
{
    FRawDistributionVector StartSize;                                                 // 0x0030 (size: 0x48)

}; // Size: 0x78

class UParticleModuleSize_Seeded : public UParticleModuleSize
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0078 (size: 0x20)

}; // Size: 0x98

class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
    FRawDistributionVector LifeMultiplier;                                            // 0x0030 (size: 0x48)
    uint8 MultiplyX;                                                                  // 0x0078 (size: 0x1)
    uint8 MultiplyY;                                                                  // 0x0078 (size: 0x1)
    uint8 MultiplyZ;                                                                  // 0x0078 (size: 0x1)

}; // Size: 0x80

class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
    FRawDistributionVector SizeScale;                                                 // 0x0030 (size: 0x48)
    uint8 EnableX;                                                                    // 0x0078 (size: 0x1)
    uint8 EnableY;                                                                    // 0x0078 (size: 0x1)
    uint8 EnableZ;                                                                    // 0x0078 (size: 0x1)

}; // Size: 0x80

class UParticleModuleSizeScaleBySpeed : public UParticleModuleSizeBase
{
    FVector2D SpeedScale;                                                             // 0x0030 (size: 0x8)
    FVector2D MaxScale;                                                               // 0x0038 (size: 0x8)

}; // Size: 0x40

class UParticleModuleSourceMovement : public UParticleModuleLocationBase
{
    FRawDistributionVector SourceMovementScale;                                       // 0x0030 (size: 0x48)

}; // Size: 0x78

class UParticleModuleSpawnBase : public UParticleModule
{
    uint8 bProcessSpawnRate;                                                          // 0x0030 (size: 0x1)
    uint8 bProcessBurstList;                                                          // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
    FRawDistributionFloat Rate;                                                       // 0x0038 (size: 0x30)
    FRawDistributionFloat RateScale;                                                  // 0x0068 (size: 0x30)
    TEnumAsByte<EParticleBurstMethod> ParticleBurstMethod;                            // 0x0098 (size: 0x1)
    TArray<FParticleBurst> BurstList;                                                 // 0x00A0 (size: 0x10)
    FRawDistributionFloat BurstScale;                                                 // 0x00B0 (size: 0x30)
    uint8 bApplyGlobalSpawnRateScale;                                                 // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
    float UnitScalar;                                                                 // 0x0038 (size: 0x4)
    float MovementTolerance;                                                          // 0x003C (size: 0x4)
    FRawDistributionFloat SpawnPerUnit;                                               // 0x0040 (size: 0x30)
    float MaxFrameDistance;                                                           // 0x0070 (size: 0x4)
    uint8 bIgnoreSpawnRateWhenMoving;                                                 // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongX;                                                      // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongY;                                                      // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongZ;                                                      // 0x0074 (size: 0x1)

}; // Size: 0x78

class UParticleModuleSubUVBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
    class USubUVAnimation* Animation;                                                 // 0x0030 (size: 0x8)
    FRawDistributionFloat SubImageIndex;                                              // 0x0038 (size: 0x30)
    uint8 bUseRealTime;                                                               // 0x0068 (size: 0x1)

}; // Size: 0x70

class UParticleModuleSubUVMovie : public UParticleModuleSubUV
{
    uint8 bUseEmitterTime;                                                            // 0x0070 (size: 0x1)
    FRawDistributionFloat FrameRate;                                                  // 0x0078 (size: 0x30)
    int32 StartingFrame;                                                              // 0x00A8 (size: 0x4)

}; // Size: 0xB0

class UParticleModuleTrailBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
    TEnumAsByte<ETrail2SourceMethod> SourceMethod;                                    // 0x0030 (size: 0x1)
    FName SourceName;                                                                 // 0x0034 (size: 0x8)
    FRawDistributionFloat SourceStrength;                                             // 0x0040 (size: 0x30)
    uint8 bLockSourceStength;                                                         // 0x0070 (size: 0x1)
    int32 SourceOffsetCount;                                                          // 0x0074 (size: 0x4)
    TArray<FVector> SourceOffsetDefaults;                                             // 0x0078 (size: 0x10)
    TEnumAsByte<EParticleSourceSelectionMethod> SelectionMethod;                      // 0x0088 (size: 0x1)
    uint8 bInheritRotation;                                                           // 0x008C (size: 0x1)

}; // Size: 0x90

class UParticleModuleTypeDataBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase
{
    uint8 bDeadTrailsOnDeactivate;                                                    // 0x0030 (size: 0x1)
    uint8 bEnablePreviousTangentRecalculation;                                        // 0x0030 (size: 0x1)
    uint8 bTangentRecalculationEveryFrame;                                            // 0x0030 (size: 0x1)
    float TilingDistance;                                                             // 0x0034 (size: 0x4)
    float DistanceTessellationStepSize;                                               // 0x0038 (size: 0x4)
    float TangentTessellationStepSize;                                                // 0x003C (size: 0x4)
    float WidthTessellationStepSize;                                                  // 0x0040 (size: 0x4)

}; // Size: 0x48

class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
    TEnumAsByte<EBeam2Method> BeamMethod;                                             // 0x0030 (size: 0x1)
    int32 TextureTile;                                                                // 0x0034 (size: 0x4)
    float TextureTileDistance;                                                        // 0x0038 (size: 0x4)
    int32 Sheets;                                                                     // 0x003C (size: 0x4)
    int32 MaxBeamCount;                                                               // 0x0040 (size: 0x4)
    float Speed;                                                                      // 0x0044 (size: 0x4)
    int32 InterpolationPoints;                                                        // 0x0048 (size: 0x4)
    uint8 bAlwaysOn;                                                                  // 0x004C (size: 0x1)
    int32 UpVectorStepSize;                                                           // 0x0050 (size: 0x4)
    FName BranchParentName;                                                           // 0x0054 (size: 0x8)
    FRawDistributionFloat Distance;                                                   // 0x0060 (size: 0x30)
    TEnumAsByte<EBeamTaperMethod> TaperMethod;                                        // 0x0090 (size: 0x1)
    FRawDistributionFloat TaperFactor;                                                // 0x0098 (size: 0x30)
    FRawDistributionFloat TaperScale;                                                 // 0x00C8 (size: 0x30)
    uint8 RenderGeometry;                                                             // 0x00F8 (size: 0x1)
    uint8 RenderDirectLine;                                                           // 0x00F8 (size: 0x1)
    uint8 RenderLines;                                                                // 0x00F8 (size: 0x1)
    uint8 RenderTessellation;                                                         // 0x00F8 (size: 0x1)

}; // Size: 0x150

struct FGPUSpriteLocalVectorFieldInfo
{
    class UVectorField* Field;                                                        // 0x0000 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)
    FRotator MinInitialRotation;                                                      // 0x0040 (size: 0xC)
    FRotator MaxInitialRotation;                                                      // 0x004C (size: 0xC)
    FRotator RotationRate;                                                            // 0x0058 (size: 0xC)
    float Intensity;                                                                  // 0x0064 (size: 0x4)
    float Tightness;                                                                  // 0x0068 (size: 0x4)
    uint8 bIgnoreComponentTransform;                                                  // 0x006C (size: 0x1)
    uint8 bTileX;                                                                     // 0x006C (size: 0x1)
    uint8 bTileY;                                                                     // 0x006C (size: 0x1)
    uint8 bTileZ;                                                                     // 0x006C (size: 0x1)
    uint8 bUseFixDT;                                                                  // 0x006C (size: 0x1)

}; // Size: 0x70

struct FFloatDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FGPUSpriteEmitterInfo
{
    class UParticleModuleRequired* RequiredModule;                                    // 0x0000 (size: 0x8)
    class UParticleModuleSpawn* SpawnModule;                                          // 0x0008 (size: 0x8)
    class UParticleModuleSpawnPerUnit* SpawnPerUnitModule;                            // 0x0010 (size: 0x8)
    TArray<class UParticleModule*> SpawnModules;                                      // 0x0018 (size: 0x10)
    FGPUSpriteLocalVectorFieldInfo LocalVectorField;                                  // 0x0030 (size: 0x70)
    FFloatDistribution VectorFieldScale;                                              // 0x00A0 (size: 0x20)
    FFloatDistribution DragCoefficient;                                               // 0x00C0 (size: 0x20)
    FFloatDistribution PointAttractorStrength;                                        // 0x00E0 (size: 0x20)
    FFloatDistribution Resilience;                                                    // 0x0100 (size: 0x20)
    FVector ConstantAcceleration;                                                     // 0x0120 (size: 0xC)
    FVector PointAttractorPosition;                                                   // 0x012C (size: 0xC)
    float PointAttractorRadiusSq;                                                     // 0x0138 (size: 0x4)
    FVector OrbitOffsetBase;                                                          // 0x013C (size: 0xC)
    FVector OrbitOffsetRange;                                                         // 0x0148 (size: 0xC)
    FVector2D InvMaxSize;                                                             // 0x0154 (size: 0x8)
    float InvRotationRateScale;                                                       // 0x015C (size: 0x4)
    float MaxLifetime;                                                                // 0x0160 (size: 0x4)
    int32 MaxParticleCount;                                                           // 0x0164 (size: 0x4)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0168 (size: 0x1)
    TEnumAsByte<EParticleAxisLock> LockAxisFlag;                                      // 0x0169 (size: 0x1)
    uint8 bEnableCollision;                                                           // 0x016C (size: 0x1)
    TEnumAsByte<EParticleCollisionMode::Type> CollisionMode;                          // 0x0170 (size: 0x1)
    uint8 bRemoveHMDRoll;                                                             // 0x0174 (size: 0x1)
    float MinFacingCameraBlendDistance;                                               // 0x0178 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x017C (size: 0x4)
    FRawDistributionVector DynamicColor;                                              // 0x0180 (size: 0x48)
    FRawDistributionFloat DynamicAlpha;                                               // 0x01C8 (size: 0x30)
    FRawDistributionVector DynamicColorScale;                                         // 0x01F8 (size: 0x48)
    FRawDistributionFloat DynamicAlphaScale;                                          // 0x0240 (size: 0x30)

}; // Size: 0x280

struct FGPUSpriteResourceData
{
    TArray<FColor> QuantizedColorSamples;                                             // 0x0000 (size: 0x10)
    TArray<FColor> QuantizedMiscSamples;                                              // 0x0010 (size: 0x10)
    TArray<FColor> QuantizedSimulationAttrSamples;                                    // 0x0020 (size: 0x10)
    FVector4 ColorScale;                                                              // 0x0030 (size: 0x10)
    FVector4 ColorBias;                                                               // 0x0040 (size: 0x10)
    FVector4 MiscScale;                                                               // 0x0050 (size: 0x10)
    FVector4 MiscBias;                                                                // 0x0060 (size: 0x10)
    FVector4 SimulationAttrCurveScale;                                                // 0x0070 (size: 0x10)
    FVector4 SimulationAttrCurveBias;                                                 // 0x0080 (size: 0x10)
    FVector4 SubImageSize;                                                            // 0x0090 (size: 0x10)
    FVector4 SizeBySpeed;                                                             // 0x00A0 (size: 0x10)
    FVector ConstantAcceleration;                                                     // 0x00B0 (size: 0xC)
    FVector OrbitOffsetBase;                                                          // 0x00BC (size: 0xC)
    FVector OrbitOffsetRange;                                                         // 0x00C8 (size: 0xC)
    FVector OrbitFrequencyBase;                                                       // 0x00D4 (size: 0xC)
    FVector OrbitFrequencyRange;                                                      // 0x00E0 (size: 0xC)
    FVector OrbitPhaseBase;                                                           // 0x00EC (size: 0xC)
    FVector OrbitPhaseRange;                                                          // 0x00F8 (size: 0xC)
    float GlobalVectorFieldScale;                                                     // 0x0104 (size: 0x4)
    float GlobalVectorFieldTightness;                                                 // 0x0108 (size: 0x4)
    float PerParticleVectorFieldScale;                                                // 0x010C (size: 0x4)
    float PerParticleVectorFieldBias;                                                 // 0x0110 (size: 0x4)
    float DragCoefficientScale;                                                       // 0x0114 (size: 0x4)
    float DragCoefficientBias;                                                        // 0x0118 (size: 0x4)
    float ResilienceScale;                                                            // 0x011C (size: 0x4)
    float ResilienceBias;                                                             // 0x0120 (size: 0x4)
    float CollisionRadiusScale;                                                       // 0x0124 (size: 0x4)
    float CollisionRadiusBias;                                                        // 0x0128 (size: 0x4)
    float CollisionTimeBias;                                                          // 0x012C (size: 0x4)
    float CollisionRandomSpread;                                                      // 0x0130 (size: 0x4)
    float CollisionRandomDistribution;                                                // 0x0134 (size: 0x4)
    float OneMinusFriction;                                                           // 0x0138 (size: 0x4)
    float RotationRateScale;                                                          // 0x013C (size: 0x4)
    float CameraMotionBlurAmount;                                                     // 0x0140 (size: 0x4)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0144 (size: 0x1)
    TEnumAsByte<EParticleAxisLock> LockAxisFlag;                                      // 0x0145 (size: 0x1)
    FVector2D PivotOffset;                                                            // 0x0148 (size: 0x8)
    uint8 bRemoveHMDRoll;                                                             // 0x0150 (size: 0x1)
    float MinFacingCameraBlendDistance;                                               // 0x0154 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x0158 (size: 0x4)

}; // Size: 0x160

class UParticleModuleTypeDataGpu : public UParticleModuleTypeDataBase
{
    FGPUSpriteEmitterInfo EmitterInfo;                                                // 0x0030 (size: 0x280)
    FGPUSpriteResourceData ResourceData;                                              // 0x02B0 (size: 0x160)
    float CameraMotionBlurAmount;                                                     // 0x0410 (size: 0x4)
    uint8 bClearExistingParticlesOnInit;                                              // 0x0414 (size: 0x1)

}; // Size: 0x420

class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
    class UStaticMesh* Mesh;                                                          // 0x0030 (size: 0x8)
    float LODSizeScale;                                                               // 0x0040 (size: 0x4)
    uint8 bUseStaticMeshLODs;                                                         // 0x0044 (size: 0x1)
    uint8 CastShadows;                                                                // 0x0044 (size: 0x1)
    uint8 DoCollisions;                                                               // 0x0044 (size: 0x1)
    TEnumAsByte<EMeshScreenAlignment> MeshAlignment;                                  // 0x0045 (size: 0x1)
    uint8 bOverrideMaterial;                                                          // 0x0046 (size: 0x1)
    uint8 bOverrideDefaultMotionBlurSettings;                                         // 0x0046 (size: 0x1)
    uint8 bEnableMotionBlur;                                                          // 0x0046 (size: 0x1)
    FRawDistributionVector RollPitchYawRange;                                         // 0x0048 (size: 0x48)
    TEnumAsByte<EParticleAxisLock> AxisLockOption;                                    // 0x0090 (size: 0x1)
    uint8 bCameraFacing;                                                              // 0x0091 (size: 0x1)
    TEnumAsByte<EMeshCameraFacingUpAxis> CameraFacingUpAxisOption;                    // 0x0092 (size: 0x1)
    TEnumAsByte<EMeshCameraFacingOptions> CameraFacingOption;                         // 0x0093 (size: 0x1)
    uint8 bApplyParticleRotationAsSpin;                                               // 0x0094 (size: 0x1)
    uint8 bFaceCameraDirectionRatherThanPosition;                                     // 0x0094 (size: 0x1)
    uint8 bCollisionsConsiderPartilceSize;                                            // 0x0094 (size: 0x1)

}; // Size: 0x98

class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
    int32 MaxTessellationBetweenParticles;                                            // 0x0030 (size: 0x4)
    int32 SheetsPerTrail;                                                             // 0x0034 (size: 0x4)
    int32 MaxTrailCount;                                                              // 0x0038 (size: 0x4)
    int32 MaxParticleInTrailCount;                                                    // 0x003C (size: 0x4)
    uint8 bDeadTrailsOnDeactivate;                                                    // 0x0040 (size: 0x1)
    uint8 bDeadTrailsOnSourceLoss;                                                    // 0x0040 (size: 0x1)
    uint8 bClipSourceSegement;                                                        // 0x0040 (size: 0x1)
    uint8 bEnablePreviousTangentRecalculation;                                        // 0x0040 (size: 0x1)
    uint8 bTangentRecalculationEveryFrame;                                            // 0x0040 (size: 0x1)
    uint8 bSpawnInitialParticle;                                                      // 0x0040 (size: 0x1)
    TEnumAsByte<ETrailsRenderAxisOption> RenderAxis;                                  // 0x0044 (size: 0x1)
    float TangentSpawningScalar;                                                      // 0x0048 (size: 0x4)
    uint8 bRenderGeometry;                                                            // 0x004C (size: 0x1)
    uint8 bRenderSpawnPoints;                                                         // 0x004C (size: 0x1)
    uint8 bRenderTangents;                                                            // 0x004C (size: 0x1)
    uint8 bRenderTessellation;                                                        // 0x004C (size: 0x1)
    float TilingDistance;                                                             // 0x0050 (size: 0x4)
    float DistanceTessellationStepSize;                                               // 0x0054 (size: 0x4)
    uint8 bEnableTangentDiffInterpScale;                                              // 0x0058 (size: 0x1)
    float TangentTessellationScalar;                                                  // 0x005C (size: 0x4)

}; // Size: 0x60

class UParticleModuleVectorFieldBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleVectorFieldGlobal : public UParticleModuleVectorFieldBase
{
    uint8 bOverrideGlobalVectorFieldTightness;                                        // 0x0030 (size: 0x1)
    float GlobalVectorFieldScale;                                                     // 0x0034 (size: 0x4)
    float GlobalVectorFieldTightness;                                                 // 0x0038 (size: 0x4)

}; // Size: 0x40

class UParticleModuleVectorFieldLocal : public UParticleModuleVectorFieldBase
{
    class UVectorField* VectorField;                                                  // 0x0030 (size: 0x8)
    FVector RelativeTranslation;                                                      // 0x0038 (size: 0xC)
    FRotator RelativeRotation;                                                        // 0x0044 (size: 0xC)
    FVector RelativeScale3D;                                                          // 0x0050 (size: 0xC)
    float Intensity;                                                                  // 0x005C (size: 0x4)
    float Tightness;                                                                  // 0x0060 (size: 0x4)
    uint8 bIgnoreComponentTransform;                                                  // 0x0064 (size: 0x1)
    uint8 bTileX;                                                                     // 0x0064 (size: 0x1)
    uint8 bTileY;                                                                     // 0x0064 (size: 0x1)
    uint8 bTileZ;                                                                     // 0x0064 (size: 0x1)
    uint8 bUseFixDT;                                                                  // 0x0064 (size: 0x1)

}; // Size: 0x68

class UParticleModuleVectorFieldRotation : public UParticleModuleVectorFieldBase
{
    FVector MinInitialRotation;                                                       // 0x0030 (size: 0xC)
    FVector MaxInitialRotation;                                                       // 0x003C (size: 0xC)

}; // Size: 0x48

class UParticleModuleVectorFieldRotationRate : public UParticleModuleVectorFieldBase
{
    FVector RotationRate;                                                             // 0x0030 (size: 0xC)

}; // Size: 0x40

class UParticleModuleVectorFieldScale : public UParticleModuleVectorFieldBase
{
    class UDistributionFloat* VectorFieldScale;                                       // 0x0030 (size: 0x8)
    FRawDistributionFloat VectorFieldScaleRaw;                                        // 0x0038 (size: 0x30)

}; // Size: 0x68

class UParticleModuleVectorFieldScaleOverLife : public UParticleModuleVectorFieldBase
{
    class UDistributionFloat* VectorFieldScaleOverLife;                               // 0x0030 (size: 0x8)
    FRawDistributionFloat VectorFieldScaleOverLifeRaw;                                // 0x0038 (size: 0x30)

}; // Size: 0x68

class UParticleModuleVelocityBase : public UParticleModule
{
    uint8 bInWorldSpace;                                                              // 0x0030 (size: 0x1)
    uint8 bApplyOwnerScale;                                                           // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
    FRawDistributionVector startVelocity;                                             // 0x0038 (size: 0x48)
    FRawDistributionFloat StartVelocityRadial;                                        // 0x0080 (size: 0x30)

}; // Size: 0xB0

class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00B0 (size: 0x20)

}; // Size: 0xD0

class UParticleModuleVelocityCone : public UParticleModuleVelocityBase
{
    FRawDistributionFloat Angle;                                                      // 0x0038 (size: 0x30)
    FRawDistributionFloat Velocity;                                                   // 0x0068 (size: 0x30)
    FVector Direction;                                                                // 0x0098 (size: 0xC)

}; // Size: 0xA8

class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
    FRawDistributionVector Scale;                                                     // 0x0038 (size: 0x48)

}; // Size: 0x80

class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
    FRawDistributionVector VelOverLife;                                               // 0x0038 (size: 0x48)
    uint8 Absolute;                                                                   // 0x0080 (size: 0x1)

}; // Size: 0x88

class UParticleSpriteEmitter : public UParticleEmitter
{
}; // Size: 0x1B8

struct FParticleSysParam
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<EParticleSysParamType> ParamType;                                     // 0x0008 (size: 0x1)
    float Scalar;                                                                     // 0x000C (size: 0x4)
    float Scalar_Low;                                                                 // 0x0010 (size: 0x4)
    FVector Vector;                                                                   // 0x0014 (size: 0xC)
    FVector Vector_Low;                                                               // 0x0020 (size: 0xC)
    FColor Color;                                                                     // 0x002C (size: 0x4)
    class AActor* Actor;                                                              // 0x0030 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0038 (size: 0x8)

}; // Size: 0x80

class UParticleSystemComponent : public UFXSystemComponent
{
    class UParticleSystem* Template;                                                  // 0x0450 (size: 0x8)
    TArray<class UMaterialInterface*> EmitterMaterials;                               // 0x0458 (size: 0x10)
    TArray<class USkeletalMeshComponent*> SkelMeshComponents;                         // 0x0468 (size: 0x10)
    uint8 bResetOnDetach;                                                             // 0x0479 (size: 0x1)
    uint8 bUpdateOnDedicatedServer;                                                   // 0x0479 (size: 0x1)
    uint8 bAllowRecycling;                                                            // 0x0479 (size: 0x1)
    uint8 bAutoManageAttachment;                                                      // 0x0479 (size: 0x1)
    uint8 bAutoAttachWeldSimulatedBodies;                                             // 0x0479 (size: 0x1)
    uint8 bWarmingUp;                                                                 // 0x047A (size: 0x1)
    uint8 bOverrideLODMethod;                                                         // 0x047A (size: 0x1)
    uint8 bSkipUpdateDynamicDataDuringTick;                                           // 0x047A (size: 0x1)
    TEnumAsByte<ParticleSystemLODMethod> LODMethod;                                   // 0x0485 (size: 0x1)
    EParticleSignificanceLevel RequiredSignificance;                                  // 0x0486 (size: 0x1)
    TArray<FParticleSysParam> InstanceParameters;                                     // 0x0488 (size: 0x10)
    FParticleSystemComponentOnParticleSpawn OnParticleSpawn;                          // 0x0498 (size: 0x10)
    void ParticleSpawnSignature(FName EventName, float EmitterTime, FVector Location, FVector Velocity);
    FParticleSystemComponentOnParticleBurst OnParticleBurst;                          // 0x04A8 (size: 0x10)
    void ParticleBurstSignature(FName EventName, float EmitterTime, int32 ParticleCount);
    FParticleSystemComponentOnParticleDeath OnParticleDeath;                          // 0x04B8 (size: 0x10)
    void ParticleDeathSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction);
    FParticleSystemComponentOnParticleCollide OnParticleCollide;                      // 0x04C8 (size: 0x10)
    void ParticleCollisionSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction, FVector Normal, FName BoneName, class UPhysicalMaterial* PhysMat);
    bool bOldPositionValid;                                                           // 0x04D8 (size: 0x1)
    FVector OldPosition;                                                              // 0x04DC (size: 0xC)
    FVector PartSysVelocity;                                                          // 0x04E8 (size: 0xC)
    float WarmupTime;                                                                 // 0x04F4 (size: 0x4)
    float WarmupTickRate;                                                             // 0x04F8 (size: 0x4)
    float SecondsBeforeInactive;                                                      // 0x0500 (size: 0x4)
    float MaxTimeBeforeForceUpdateTransform;                                          // 0x0508 (size: 0x4)
    TArray<class UParticleSystemReplay*> ReplayClips;                                 // 0x0528 (size: 0x10)
    float CustomTimeDilation;                                                         // 0x0540 (size: 0x4)
    TWeakObjectPtr<class USceneComponent> AutoAttachParent;                           // 0x0598 (size: 0x8)
    FName AutoAttachSocketName;                                                       // 0x05A0 (size: 0x8)
    EAttachmentRule AutoAttachLocationRule;                                           // 0x05A8 (size: 0x1)
    EAttachmentRule AutoAttachRotationRule;                                           // 0x05A9 (size: 0x1)
    EAttachmentRule AutoAttachScaleRule;                                              // 0x05AA (size: 0x1)
    FParticleSystemComponentOnSystemFinished OnSystemFinished;                        // 0x05D8 (size: 0x10)
    void OnSystemFinished(class UParticleSystemComponent* PSystem);

    void SetTrailSourceData(FName InFirstSocketName, FName InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth);
    void SetTemplate(class UParticleSystem* NewTemplate);
    void SetMaterialParameter(FName ParameterName, class UMaterialInterface* Param);
    void SetBeamTargetTangent(int32 EmitterIndex, FVector NewTangentPoint, int32 TargetIndex);
    void SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex);
    void SetBeamTargetPoint(int32 EmitterIndex, FVector NewTargetPoint, int32 TargetIndex);
    void SetBeamSourceTangent(int32 EmitterIndex, FVector NewTangentPoint, int32 SourceIndex);
    void SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex);
    void SetBeamSourcePoint(int32 EmitterIndex, FVector NewSourcePoint, int32 SourceIndex);
    void SetBeamEndPoint(int32 EmitterIndex, FVector NewEndPoint);
    void SetAutoAttachParams(class USceneComponent* Parent, FName SocketName, TEnumAsByte<EAttachLocation::Type> LocationType);
    int32 GetNumActiveParticles();
    class UMaterialInterface* GetNamedMaterial(FName InName);
    bool GetBeamTargetTangent(int32 EmitterIndex, int32 TargetIndex, FVector& OutTangentPoint);
    bool GetBeamTargetStrength(int32 EmitterIndex, int32 TargetIndex, float& OutTargetStrength);
    bool GetBeamTargetPoint(int32 EmitterIndex, int32 TargetIndex, FVector& OutTargetPoint);
    bool GetBeamSourceTangent(int32 EmitterIndex, int32 SourceIndex, FVector& OutTangentPoint);
    bool GetBeamSourceStrength(int32 EmitterIndex, int32 SourceIndex, float& OutSourceStrength);
    bool GetBeamSourcePoint(int32 EmitterIndex, int32 SourceIndex, FVector& OutSourcePoint);
    bool GetBeamEndPoint(int32 EmitterIndex, FVector& OutEndPoint);
    void GenerateParticleEvent(const FName InEventName, const float InEmitterTime, const FVector InLocation, const FVector InDirection, const FVector InVelocity);
    void EndTrails();
    class UMaterialInstanceDynamic* CreateNamedDynamicMaterialInstance(FName InName, class UMaterialInterface* SourceMaterial);
    void BeginTrails(FName InFirstSocketName, FName InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth);
}; // Size: 0x6B0

class UParticleSystemReplay : public UObject
{
    int32 ClipIDNumber;                                                               // 0x0028 (size: 0x4)

}; // Size: 0x40

class IPathFollowingAgentInterface : public IInterface
{
}; // Size: 0x28

class UPawnNoiseEmitterComponent : public UActorComponent
{
    uint8 bAIPerceptionSystemCompatibilityMode;                                       // 0x00B0 (size: 0x1)
    FVector LastRemoteNoisePosition;                                                  // 0x00B4 (size: 0xC)
    float NoiseLifetime;                                                              // 0x00C0 (size: 0x4)
    float LastRemoteNoiseVolume;                                                      // 0x00C4 (size: 0x4)
    float LastRemoteNoiseTime;                                                        // 0x00C8 (size: 0x4)
    float LastLocalNoiseVolume;                                                       // 0x00CC (size: 0x4)
    float LastLocalNoiseTime;                                                         // 0x00D0 (size: 0x4)

    void MakeNoise(class AActor* NoiseMaker, float Loudness, const FVector& NoiseLocation);
}; // Size: 0xD8

struct FPhysicalAnimationData
{
    FName BodyName;                                                                   // 0x0000 (size: 0x8)
    uint8 bIsLocalSimulation;                                                         // 0x0008 (size: 0x1)
    float OrientationStrength;                                                        // 0x000C (size: 0x4)
    float AngularVelocityStrength;                                                    // 0x0010 (size: 0x4)
    float PositionStrength;                                                           // 0x0014 (size: 0x4)
    float VelocityStrength;                                                           // 0x0018 (size: 0x4)
    float MaxLinearForce;                                                             // 0x001C (size: 0x4)
    float MaxAngularForce;                                                            // 0x0020 (size: 0x4)

}; // Size: 0x24

class UPhysicalAnimationComponent : public UActorComponent
{
    float StrengthMultiplyer;                                                         // 0x00B0 (size: 0x4)
    class USkeletalMeshComponent* SkeletalMeshComponent;                              // 0x00B8 (size: 0x8)

    void SetStrengthMultiplyer(float InStrengthMultiplyer);
    void SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
    FTransform GetBodyTargetTransform(FName BodyName);
    void ApplyPhysicalAnimationSettingsBelow(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf);
    void ApplyPhysicalAnimationSettings(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData);
    void ApplyPhysicalAnimationProfileBelow(FName BodyName, FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
}; // Size: 0xF0

class UPhysicalMaterialMask : public UObject
{
    int32 UVChannelIndex;                                                             // 0x0028 (size: 0x4)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x002C (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x002D (size: 0x1)

}; // Size: 0x30

struct FSolverIterations
{
    float FixedTimeStep;                                                              // 0x0000 (size: 0x4)
    int32 SolverIterations;                                                           // 0x0004 (size: 0x4)
    int32 JointIterations;                                                            // 0x0008 (size: 0x4)
    int32 CollisionIterations;                                                        // 0x000C (size: 0x4)
    int32 SolverPushOutIterations;                                                    // 0x0010 (size: 0x4)
    int32 JointPushOutIterations;                                                     // 0x0014 (size: 0x4)
    int32 CollisionPushOutIterations;                                                 // 0x0018 (size: 0x4)

}; // Size: 0x1C

class UPhysicsAsset : public UObject
{
    TArray<int32> BoundsBodies;                                                       // 0x0030 (size: 0x10)
    TArray<class USkeletalBodySetup*> SkeletalBodySetups;                             // 0x0040 (size: 0x10)
    TArray<class UPhysicsConstraintTemplate*> ConstraintSetup;                        // 0x0050 (size: 0x10)
    FSolverIterations SolverIterations;                                               // 0x0060 (size: 0x1C)
    EPhysicsAssetSolverType SolverType;                                               // 0x007C (size: 0x1)
    uint8 bNotForDedicatedServer;                                                     // 0x007D (size: 0x1)
    class UThumbnailInfo* ThumbnailInfo;                                              // 0x0120 (size: 0x8)
    TArray<class UBodySetup*> BodySetup;                                              // 0x0128 (size: 0x10)

}; // Size: 0x138

struct FPhysicalAnimationProfile
{
    FName ProfileName;                                                                // 0x0000 (size: 0x8)
    FPhysicalAnimationData PhysicalAnimationData;                                     // 0x0008 (size: 0x24)

}; // Size: 0x2C

class USkeletalBodySetup : public UBodySetup
{
    bool bSkipScaleFromAnimation;                                                     // 0x02A0 (size: 0x1)
    TArray<FPhysicalAnimationProfile> PhysicalAnimationData;                          // 0x02A8 (size: 0x10)

}; // Size: 0x2B8

class UPhysicsCollisionHandler : public UObject
{
    float ImpactThreshold;                                                            // 0x0028 (size: 0x4)
    float ImpactReFireDelay;                                                          // 0x002C (size: 0x4)
    class USoundBase* DefaultImpactSound;                                             // 0x0030 (size: 0x8)
    float LastImpactSoundTime;                                                        // 0x0038 (size: 0x4)

}; // Size: 0x40

class ARigidBodyBase : public AActor
{
}; // Size: 0x228

class APhysicsConstraintActor : public ARigidBodyBase
{
    class UPhysicsConstraintComponent* ConstraintComp;                                // 0x0228 (size: 0x8)
    class AActor* ConstraintActor1;                                                   // 0x0230 (size: 0x8)
    class AActor* ConstraintActor2;                                                   // 0x0238 (size: 0x8)
    uint8 bDisableCollision;                                                          // 0x0240 (size: 0x1)

}; // Size: 0x248

struct FConstrainComponentPropName
{
    FName ComponentName;                                                              // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FConstraintInstanceBase
{
}; // Size: 0x18

struct FConstraintBaseParams
{
    float Stiffness;                                                                  // 0x0000 (size: 0x4)
    float Damping;                                                                    // 0x0004 (size: 0x4)
    float Restitution;                                                                // 0x0008 (size: 0x4)
    float ContactDistance;                                                            // 0x000C (size: 0x4)
    uint8 bSoftConstraint;                                                            // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FLinearConstraint : public FConstraintBaseParams
{
    float Limit;                                                                      // 0x0014 (size: 0x4)
    TEnumAsByte<ELinearConstraintMotion> XMotion;                                     // 0x0018 (size: 0x1)
    TEnumAsByte<ELinearConstraintMotion> YMotion;                                     // 0x0019 (size: 0x1)
    TEnumAsByte<ELinearConstraintMotion> ZMotion;                                     // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FConeConstraint : public FConstraintBaseParams
{
    float Swing1LimitDegrees;                                                         // 0x0014 (size: 0x4)
    float Swing2LimitDegrees;                                                         // 0x0018 (size: 0x4)
    TEnumAsByte<EAngularConstraintMotion> Swing1Motion;                               // 0x001C (size: 0x1)
    TEnumAsByte<EAngularConstraintMotion> Swing2Motion;                               // 0x001D (size: 0x1)

}; // Size: 0x20

struct FTwistConstraint : public FConstraintBaseParams
{
    float TwistLimitDegrees;                                                          // 0x0014 (size: 0x4)
    TEnumAsByte<EAngularConstraintMotion> TwistMotion;                                // 0x0018 (size: 0x1)

}; // Size: 0x1C

struct FConstraintDrive
{
    float Stiffness;                                                                  // 0x0000 (size: 0x4)
    float Damping;                                                                    // 0x0004 (size: 0x4)
    float MaxForce;                                                                   // 0x0008 (size: 0x4)
    uint8 bEnablePositionDrive;                                                       // 0x000C (size: 0x1)
    uint8 bEnableVelocityDrive;                                                       // 0x000C (size: 0x1)

}; // Size: 0x10

struct FLinearDriveConstraint
{
    FVector PositionTarget;                                                           // 0x0000 (size: 0xC)
    FVector VelocityTarget;                                                           // 0x000C (size: 0xC)
    FConstraintDrive XDrive;                                                          // 0x0018 (size: 0x10)
    FConstraintDrive YDrive;                                                          // 0x0028 (size: 0x10)
    FConstraintDrive ZDrive;                                                          // 0x0038 (size: 0x10)
    uint8 bEnablePositionDrive;                                                       // 0x0048 (size: 0x1)

}; // Size: 0x4C

struct FAngularDriveConstraint
{
    FConstraintDrive TwistDrive;                                                      // 0x0000 (size: 0x10)
    FConstraintDrive SwingDrive;                                                      // 0x0010 (size: 0x10)
    FConstraintDrive SlerpDrive;                                                      // 0x0020 (size: 0x10)
    FRotator OrientationTarget;                                                       // 0x0030 (size: 0xC)
    FVector AngularVelocityTarget;                                                    // 0x003C (size: 0xC)
    TEnumAsByte<EAngularDriveMode::Type> AngularDriveMode;                            // 0x0048 (size: 0x1)

}; // Size: 0x4C

struct FConstraintProfileProperties
{
    float ProjectionLinearTolerance;                                                  // 0x0000 (size: 0x4)
    float ProjectionAngularTolerance;                                                 // 0x0004 (size: 0x4)
    float ProjectionLinearAlpha;                                                      // 0x0008 (size: 0x4)
    float ProjectionAngularAlpha;                                                     // 0x000C (size: 0x4)
    float LinearBreakThreshold;                                                       // 0x0010 (size: 0x4)
    float LinearPlasticityThreshold;                                                  // 0x0014 (size: 0x4)
    float AngularBreakThreshold;                                                      // 0x0018 (size: 0x4)
    float AngularPlasticityThreshold;                                                 // 0x001C (size: 0x4)
    FLinearConstraint LinearLimit;                                                    // 0x0020 (size: 0x1C)
    FConeConstraint ConeLimit;                                                        // 0x003C (size: 0x20)
    FTwistConstraint TwistLimit;                                                      // 0x005C (size: 0x1C)
    FLinearDriveConstraint LinearDrive;                                               // 0x0078 (size: 0x4C)
    FAngularDriveConstraint AngularDrive;                                             // 0x00C4 (size: 0x4C)
    uint8 bDisableCollision;                                                          // 0x0110 (size: 0x1)
    uint8 bParentDominates;                                                           // 0x0110 (size: 0x1)
    uint8 bEnableProjection;                                                          // 0x0110 (size: 0x1)
    uint8 bEnableSoftProjection;                                                      // 0x0110 (size: 0x1)
    uint8 bAngularBreakable;                                                          // 0x0110 (size: 0x1)
    uint8 bAngularPlasticity;                                                         // 0x0110 (size: 0x1)
    uint8 bLinearBreakable;                                                           // 0x0110 (size: 0x1)
    uint8 bLinearPlasticity;                                                          // 0x0110 (size: 0x1)

}; // Size: 0x114

struct FConstraintInstance : public FConstraintInstanceBase
{
    FName JointName;                                                                  // 0x0018 (size: 0x8)
    FName ConstraintBone1;                                                            // 0x0020 (size: 0x8)
    FName ConstraintBone2;                                                            // 0x0028 (size: 0x8)
    FVector Pos1;                                                                     // 0x0030 (size: 0xC)
    FVector PriAxis1;                                                                 // 0x003C (size: 0xC)
    FVector SecAxis1;                                                                 // 0x0048 (size: 0xC)
    FVector Pos2;                                                                     // 0x0054 (size: 0xC)
    FVector PriAxis2;                                                                 // 0x0060 (size: 0xC)
    FVector SecAxis2;                                                                 // 0x006C (size: 0xC)
    FRotator AngularRotationOffset;                                                   // 0x0078 (size: 0xC)
    uint8 bScaleLinearLimits;                                                         // 0x0084 (size: 0x1)
    FConstraintProfileProperties ProfileInstance;                                     // 0x008C (size: 0x114)

}; // Size: 0x1C8

class UPhysicsConstraintComponent : public USceneComponent
{
    class AActor* ConstraintActor1;                                                   // 0x01F8 (size: 0x8)
    FConstrainComponentPropName ComponentName1;                                       // 0x0200 (size: 0x8)
    class AActor* ConstraintActor2;                                                   // 0x0208 (size: 0x8)
    FConstrainComponentPropName ComponentName2;                                       // 0x0210 (size: 0x8)
    class UPhysicsConstraintTemplate* ConstraintSetup;                                // 0x0228 (size: 0x8)
    FPhysicsConstraintComponentOnConstraintBroken OnConstraintBroken;                 // 0x0230 (size: 0x10)
    void ConstraintBrokenSignature(int32 ConstraintIndex);
    FConstraintInstance ConstraintInstance;                                           // 0x0240 (size: 0x1C8)

    void SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetOrientationDriveSLERP(bool bEnableSLERP);
    void SetLinearZLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearYLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearXLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearVelocityTarget(const FVector& InVelTarget);
    void SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPositionTarget(const FVector& InPosTarget);
    void SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPlasticity(bool bLinearPlasticity, float LinearPlasticityThreshold);
    void SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold);
    void SetDisableCollision(bool bDisableCollision);
    void SetConstraintReferencePosition(TEnumAsByte<EConstraintFrame::Type> Frame, const FVector& RefPosition);
    void SetConstraintReferenceOrientation(TEnumAsByte<EConstraintFrame::Type> Frame, const FVector& PriAxis, const FVector& SecAxis);
    void SetConstraintReferenceFrame(TEnumAsByte<EConstraintFrame::Type> Frame, const FTransform& RefFrame);
    void SetConstrainedComponents(class UPrimitiveComponent* Component1, FName BoneName1, class UPrimitiveComponent* Component2, FName BoneName2);
    void SetAngularVelocityTarget(const FVector& InVelTarget);
    void SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetAngularVelocityDriveSLERP(bool bEnableSLERP);
    void SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularTwistLimit(TEnumAsByte<EAngularConstraintMotion> ConstraintType, float TwistLimitAngle);
    void SetAngularSwing2Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing2LimitAngle);
    void SetAngularSwing1Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing1LimitAngle);
    void SetAngularPlasticity(bool bAngularPlasticity, float AngularPlasticityThreshold);
    void SetAngularOrientationTarget(const FRotator& InPosTarget);
    void SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetAngularDriveMode(TEnumAsByte<EAngularDriveMode::Type> DriveMode);
    void SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold);
    bool IsBroken();
    float GetCurrentTwist();
    float GetCurrentSwing2();
    float GetCurrentSwing1();
    void GetConstraintForce(FVector& OutLinearForce, FVector& OutAngularForce);
    void BreakConstraint();
}; // Size: 0x410

struct FPhysicsConstraintProfileHandle
{
    FConstraintProfileProperties ProfileProperties;                                   // 0x0000 (size: 0x114)
    FName ProfileName;                                                                // 0x0114 (size: 0x8)

}; // Size: 0x11C

class UPhysicsConstraintTemplate : public UObject
{
    FConstraintInstance DefaultInstance;                                              // 0x0028 (size: 0x1C8)
    TArray<FPhysicsConstraintProfileHandle> ProfileHandles;                           // 0x01F0 (size: 0x10)
    FConstraintProfileProperties DefaultProfile;                                      // 0x0200 (size: 0x114)

}; // Size: 0x318

class UPhysicsFieldComponent : public USceneComponent
{
}; // Size: 0x270

class UPhysicsHandleComponent : public UActorComponent
{
    class UPrimitiveComponent* GrabbedComponent;                                      // 0x00B0 (size: 0x8)
    uint8 bSoftAngularConstraint;                                                     // 0x00C0 (size: 0x1)
    uint8 bSoftLinearConstraint;                                                      // 0x00C0 (size: 0x1)
    uint8 bInterpolateTarget;                                                         // 0x00C0 (size: 0x1)
    float LinearDamping;                                                              // 0x00C4 (size: 0x4)
    float LinearStiffness;                                                            // 0x00C8 (size: 0x4)
    float AngularDamping;                                                             // 0x00CC (size: 0x4)
    float AngularStiffness;                                                           // 0x00D0 (size: 0x4)
    float InterpolationSpeed;                                                         // 0x0140 (size: 0x4)

    void SetTargetRotation(FRotator NewRotation);
    void SetTargetLocationAndRotation(FVector NewLocation, FRotator NewRotation);
    void SetTargetLocation(FVector NewLocation);
    void SetLinearStiffness(float NewLinearStiffness);
    void SetLinearDamping(float NewLinearDamping);
    void SetInterpolationSpeed(float NewInterpolationSpeed);
    void SetAngularStiffness(float NewAngularStiffness);
    void SetAngularDamping(float NewAngularDamping);
    void ReleaseComponent();
    void GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, FName InBoneName, FVector Location, FRotator Rotation);
    void GrabComponentAtLocation(class UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation);
    void GrabComponent(class UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation, bool bConstrainRotation);
    void GetTargetLocationAndRotation(FVector& TargetLocation, FRotator& TargetRotation);
    class UPrimitiveComponent* GetGrabbedComponent();
}; // Size: 0x160

struct FRigidBodyErrorCorrection
{
    float PingExtrapolation;                                                          // 0x0000 (size: 0x4)
    float PingLimit;                                                                  // 0x0004 (size: 0x4)
    float ErrorPerLinearDifference;                                                   // 0x0008 (size: 0x4)
    float ErrorPerAngularDifference;                                                  // 0x000C (size: 0x4)
    float MaxRestoredStateError;                                                      // 0x0010 (size: 0x4)
    float MaxLinearHardSnapDistance;                                                  // 0x0014 (size: 0x4)
    float PositionLerp;                                                               // 0x0018 (size: 0x4)
    float AngleLerp;                                                                  // 0x001C (size: 0x4)
    float LinearVelocityCoefficient;                                                  // 0x0020 (size: 0x4)
    float AngularVelocityCoefficient;                                                 // 0x0024 (size: 0x4)
    float ErrorAccumulationSeconds;                                                   // 0x0028 (size: 0x4)
    float ErrorAccumulationDistanceSq;                                                // 0x002C (size: 0x4)
    float ErrorAccumulationSimilarity;                                                // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FPhysicalSurfaceName
{
    TEnumAsByte<EPhysicalSurface> Type;                                               // 0x0000 (size: 0x1)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FChaosPhysicsSettings
{
    EChaosThreadingMode DefaultThreadingModel;                                        // 0x0000 (size: 0x1)
    EChaosSolverTickMode DedicatedThreadTickMode;                                     // 0x0001 (size: 0x1)
    EChaosBufferMode DedicatedThreadBufferMode;                                       // 0x0002 (size: 0x1)

}; // Size: 0x3

class UPhysicsSettings : public UPhysicsSettingsCore
{
    FRigidBodyErrorCorrection PhysicErrorCorrection;                                  // 0x00E0 (size: 0x34)
    TEnumAsByte<ESettingsLockedAxis::Type> LockedAxis;                                // 0x0114 (size: 0x1)
    TEnumAsByte<ESettingsDOF::Type> DefaultDegreesOfFreedom;                          // 0x0115 (size: 0x1)
    bool bSuppressFaceRemapTable;                                                     // 0x0116 (size: 0x1)
    bool bSupportUVFromHitResults;                                                    // 0x0117 (size: 0x1)
    bool bDisableActiveActors;                                                        // 0x0118 (size: 0x1)
    bool bDisableKinematicStaticPairs;                                                // 0x0119 (size: 0x1)
    bool bDisableKinematicKinematicPairs;                                             // 0x011A (size: 0x1)
    bool bDisableCCD;                                                                 // 0x011B (size: 0x1)
    bool bEnableEnhancedDeterminism;                                                  // 0x011C (size: 0x1)
    float AnimPhysicsMinDeltaTime;                                                    // 0x0120 (size: 0x4)
    bool bSimulateAnimPhysicsAfterReset;                                              // 0x0124 (size: 0x1)
    float MaxPhysicsDeltaTime;                                                        // 0x0128 (size: 0x4)
    bool bSubstepping;                                                                // 0x012C (size: 0x1)
    bool bSubsteppingAsync;                                                           // 0x012D (size: 0x1)
    float MaxSubstepDeltaTime;                                                        // 0x0130 (size: 0x4)
    int32 MaxSubsteps;                                                                // 0x0134 (size: 0x4)
    float SyncSceneSmoothingFactor;                                                   // 0x0138 (size: 0x4)
    float InitialAverageFrameRate;                                                    // 0x013C (size: 0x4)
    int32 PhysXTreeRebuildRate;                                                       // 0x0140 (size: 0x4)
    TArray<FPhysicalSurfaceName> PhysicalSurfaces;                                    // 0x0148 (size: 0x10)
    FBroadphaseSettings DefaultBroadphaseSettings;                                    // 0x0158 (size: 0x40)
    float MinDeltaVelocityForHitEvents;                                               // 0x0198 (size: 0x4)
    FChaosPhysicsSettings ChaosSettings;                                              // 0x019C (size: 0x3)

}; // Size: 0x1A0

class UPhysicsSpringComponent : public USceneComponent
{
    float SpringStiffness;                                                            // 0x01F8 (size: 0x4)
    float SpringDamping;                                                              // 0x01FC (size: 0x4)
    float SpringLengthAtRest;                                                         // 0x0200 (size: 0x4)
    float SpringRadius;                                                               // 0x0204 (size: 0x4)
    TEnumAsByte<ECollisionChannel> SpringChannel;                                     // 0x0208 (size: 0x1)
    bool bIgnoreSelf;                                                                 // 0x0209 (size: 0x1)
    float SpringCompression;                                                          // 0x020C (size: 0x4)

    FVector GetSpringRestingPoint();
    FVector GetSpringDirection();
    FVector GetSpringCurrentEndPoint();
    float GetNormalizedCompressionScalar();
}; // Size: 0x220

class APhysicsThruster : public ARigidBodyBase
{
    class UPhysicsThrusterComponent* ThrusterComponent;                               // 0x0228 (size: 0x8)

}; // Size: 0x230

class UPhysicsThrusterComponent : public USceneComponent
{
    float ThrustStrength;                                                             // 0x01F8 (size: 0x4)

}; // Size: 0x200

class ASceneCapture : public AActor
{
    class UStaticMeshComponent* MeshComp;                                             // 0x0228 (size: 0x8)
    class USceneComponent* SceneComponent;                                            // 0x0230 (size: 0x8)

}; // Size: 0x238

class APlanarReflection : public ASceneCapture
{
    class UPlanarReflectionComponent* PlanarReflectionComponent;                      // 0x0238 (size: 0x8)
    bool bShowPreviewPlane;                                                           // 0x0240 (size: 0x1)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x248

struct FEngineShowFlagsSetting
{
    FString ShowFlagName;                                                             // 0x0000 (size: 0x10)
    bool Enabled;                                                                     // 0x0010 (size: 0x1)

}; // Size: 0x18

class USceneCaptureComponent : public USceneComponent
{
    ESceneCapturePrimitiveRenderMode PrimitiveRenderMode;                             // 0x01F8 (size: 0x1)
    TEnumAsByte<ESceneCaptureSource> CaptureSource;                                   // 0x01F9 (size: 0x1)
    uint8 bCaptureEveryFrame;                                                         // 0x01FA (size: 0x1)
    uint8 bCaptureOnMovement;                                                         // 0x01FA (size: 0x1)
    bool bAlwaysPersistRenderingState;                                                // 0x01FB (size: 0x1)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenComponents;                     // 0x0200 (size: 0x10)
    TArray<class AActor*> HiddenActors;                                               // 0x0210 (size: 0x10)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> ShowOnlyComponents;                   // 0x0220 (size: 0x10)
    TArray<class AActor*> ShowOnlyActors;                                             // 0x0230 (size: 0x10)
    float LODDistanceFactor;                                                          // 0x0240 (size: 0x4)
    float MaxViewDistanceOverride;                                                    // 0x0244 (size: 0x4)
    int32 CaptureSortPriority;                                                        // 0x0248 (size: 0x4)
    bool bUseRayTracingIfEnabled;                                                     // 0x024C (size: 0x1)
    TArray<FEngineShowFlagsSetting> ShowFlagSettings;                                 // 0x0250 (size: 0x10)
    FString ProfilingEventName;                                                       // 0x0290 (size: 0x10)

    void ShowOnlyComponent(class UPrimitiveComponent* InComponent);
    void ShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void SetCaptureSortPriority(int32 NewCaptureSortPriority);
    void RemoveShowOnlyComponent(class UPrimitiveComponent* InComponent);
    void RemoveShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void HideComponent(class UPrimitiveComponent* InComponent);
    void HideActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void ClearShowOnlyComponents();
    void ClearHiddenComponents();
}; // Size: 0x2B0

class UPlanarReflectionComponent : public USceneCaptureComponent
{
    class UBoxComponent* PreviewBox;                                                  // 0x02B0 (size: 0x8)
    float NormalDistortionStrength;                                                   // 0x02B8 (size: 0x4)
    float PrefilterRoughness;                                                         // 0x02BC (size: 0x4)
    float PrefilterRoughnessDistance;                                                 // 0x02C0 (size: 0x4)
    int32 ScreenPercentage;                                                           // 0x02C4 (size: 0x4)
    float ExtraFOV;                                                                   // 0x02C8 (size: 0x4)
    float DistanceFromPlaneFadeStart;                                                 // 0x02CC (size: 0x4)
    float DistanceFromPlaneFadeEnd;                                                   // 0x02D0 (size: 0x4)
    float DistanceFromPlaneFadeoutStart;                                              // 0x02D4 (size: 0x4)
    float DistanceFromPlaneFadeoutEnd;                                                // 0x02D8 (size: 0x4)
    float AngleFromPlaneFadeStart;                                                    // 0x02DC (size: 0x4)
    float AngleFromPlaneFadeEnd;                                                      // 0x02E0 (size: 0x4)
    bool bShowPreviewPlane;                                                           // 0x02E4 (size: 0x1)
    bool bRenderSceneTwoSided;                                                        // 0x02E5 (size: 0x1)

}; // Size: 0x3A0

class APlaneReflectionCapture : public AReflectionCapture
{
}; // Size: 0x230

class UPlaneReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float InfluenceRadiusScale;                                                       // 0x0270 (size: 0x4)
    class UDrawSphereComponent* PreviewInfluenceRadius;                               // 0x0278 (size: 0x8)
    class UBoxComponent* PreviewCaptureBox;                                           // 0x0280 (size: 0x8)

}; // Size: 0x290

class UPlatformEventsComponent : public UActorComponent
{
    FPlatformEventsComponentPlatformChangedToLaptopModeDelegate PlatformChangedToLaptopModeDelegate; // 0x00B0 (size: 0x10)
    void PlatformEventDelegate();
    FPlatformEventsComponentPlatformChangedToTabletModeDelegate PlatformChangedToTabletModeDelegate; // 0x00C0 (size: 0x10)
    void PlatformEventDelegate();

    bool SupportsConvertibleLaptops();
    void PlatformEventDelegate__DelegateSignature();
    bool IsInTabletMode();
    bool IsInLaptopMode();
}; // Size: 0xD0

class UPlatformInterfaceWebResponse : public UObject
{
    FString OriginalURL;                                                              // 0x0028 (size: 0x10)
    int32 ResponseCode;                                                               // 0x0038 (size: 0x4)
    int32 Tag;                                                                        // 0x003C (size: 0x4)
    FString StringResponse;                                                           // 0x0040 (size: 0x10)
    TArray<uint8> BinaryResponse;                                                     // 0x0050 (size: 0x10)

    int32 GetNumHeaders();
    FString GetHeaderValue(FString HeaderName);
    void GetHeader(int32 HeaderIndex, FString& Header, FString& Value);
}; // Size: 0xB0

class APlayerStartPIE : public APlayerStart
{
}; // Size: 0x258

class APlayerState : public AInfo
{
    float Score;                                                                      // 0x0228 (size: 0x4)
    int32 PlayerId;                                                                   // 0x022C (size: 0x4)
    uint8 Ping;                                                                       // 0x0230 (size: 0x1)
    uint8 bShouldUpdateReplicatedPing;                                                // 0x0232 (size: 0x1)
    uint8 bIsSpectator;                                                               // 0x0232 (size: 0x1)
    uint8 bOnlySpectator;                                                             // 0x0232 (size: 0x1)
    uint8 bIsABot;                                                                    // 0x0232 (size: 0x1)
    uint8 bIsInactive;                                                                // 0x0232 (size: 0x1)
    uint8 bFromPreviousLevel;                                                         // 0x0232 (size: 0x1)
    int32 StartTime;                                                                  // 0x0234 (size: 0x4)
    TSubclassOf<class ULocalMessage> EngineMessageClass;                              // 0x0238 (size: 0x8)
    FString SavedNetworkAddress;                                                      // 0x0248 (size: 0x10)
    FUniqueNetIdRepl UniqueId;                                                        // 0x0258 (size: 0x28)
    class APawn* PawnPrivate;                                                         // 0x0288 (size: 0x8)
    FString PlayerNamePrivate;                                                        // 0x0308 (size: 0x10)

    void ReceiveOverrideWith(class APlayerState* OldPlayerState);
    void ReceiveCopyProperties(class APlayerState* NewPlayerState);
    void OnRep_UniqueId();
    void OnRep_Score();
    void OnRep_PlayerName();
    void OnRep_PlayerId();
    void OnRep_bIsInactive();
    bool IsOnlyASpectator();
    FString GetPlayerName();
}; // Size: 0x328

class UPluginCommandlet : public UCommandlet
{
}; // Size: 0xA0

class APointLight : public ALight
{
    class UPointLightComponent* PointLightComponent;                                  // 0x0238 (size: 0x8)

    void SetRadius(float NewRadius);
    void SetLightFalloffExponent(float NewLightFalloffExponent);
}; // Size: 0x240

class UPolys : public UObject
{
}; // Size: 0x38

class UPoseableMeshComponent : public USkinnedMeshComponent
{

    void SetBoneTransformByName(FName BoneName, const FTransform& InTransform, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneScaleByName(FName BoneName, FVector InScale3D, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneRotationByName(FName BoneName, FRotator InRotation, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneLocationByName(FName BoneName, FVector InLocation, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void ResetBoneTransformByName(FName BoneName);
    FTransform GetBoneTransformByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FVector GetBoneScaleByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FRotator GetBoneRotationByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FVector GetBoneLocationByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy);
}; // Size: 0x800

struct FPoseData
{
    TArray<FTransform> LocalSpacePose;                                                // 0x0000 (size: 0x10)
    TMap<int32, int32> TrackToBufferIndex;                                            // 0x0010 (size: 0x50)
    TArray<float> CurveData;                                                          // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FPoseDataContainer
{
    TArray<FSmartName> PoseNames;                                                     // 0x0000 (size: 0x10)
    TArray<FName> Tracks;                                                             // 0x0010 (size: 0x10)
    TMap<FName, int32> TrackMap;                                                      // 0x0020 (size: 0x50)
    TArray<FPoseData> Poses;                                                          // 0x0070 (size: 0x10)
    TArray<FAnimCurveBase> Curves;                                                    // 0x0080 (size: 0x10)

}; // Size: 0x90

class UPoseAsset : public UAnimationAsset
{
    FPoseDataContainer PoseContainer;                                                 // 0x0080 (size: 0x90)
    bool bAdditivePose;                                                               // 0x0110 (size: 0x1)
    int32 BasePoseIndex;                                                              // 0x0114 (size: 0x4)
    FName RetargetSource;                                                             // 0x0118 (size: 0x8)
    TArray<FTransform> RetargetSourceAssetReferencePose;                              // 0x0120 (size: 0x10)

}; // Size: 0x130

class UPoseWatch : public UObject
{
    class UEdGraphNode* Node;                                                         // 0x0028 (size: 0x8)
    FColor PoseWatchColour;                                                           // 0x0030 (size: 0x4)

}; // Size: 0x38

class UPostProcessComponent : public USceneComponent
{
    FPostProcessSettings Settings;                                                    // 0x0200 (size: 0x560)
    float Priority;                                                                   // 0x0760 (size: 0x4)
    float BlendRadius;                                                                // 0x0764 (size: 0x4)
    float BlendWeight;                                                                // 0x0768 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x076C (size: 0x1)
    uint8 bUnbound;                                                                   // 0x076C (size: 0x1)

    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x770

class APostProcessVolume : public AVolume
{
    FPostProcessSettings Settings;                                                    // 0x0270 (size: 0x560)
    float Priority;                                                                   // 0x07D0 (size: 0x4)
    float BlendRadius;                                                                // 0x07D4 (size: 0x4)
    float BlendWeight;                                                                // 0x07D8 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x07DC (size: 0x1)
    uint8 bUnbound;                                                                   // 0x07DC (size: 0x1)

    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x7E0

class APrecomputedVisibilityOverrideVolume : public AVolume
{
    TArray<class AActor*> OverrideVisibleActors;                                      // 0x0260 (size: 0x10)
    TArray<class AActor*> OverrideInvisibleActors;                                    // 0x0270 (size: 0x10)
    TArray<FName> OverrideInvisibleLevels;                                            // 0x0280 (size: 0x10)

}; // Size: 0x290

class APrecomputedVisibilityVolume : public AVolume
{
}; // Size: 0x260

class IPreviewCollectionInterface : public IInterface
{
}; // Size: 0x28

struct FPreviewMeshCollectionEntry
{
    TSoftObjectPtr<USkeletalMesh> SkeletalMesh;                                       // 0x0000 (size: 0x28)

}; // Size: 0x28

class UPreviewMeshCollection : public UDataAsset
{
    class USkeleton* Skeleton;                                                        // 0x0038 (size: 0x8)
    TArray<FPreviewMeshCollectionEntry> SkeletalMeshes;                               // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FCollectionReference
{
    FName CollectionName;                                                             // 0x0000 (size: 0x8)

}; // Size: 0x8

class UPrimaryAssetLabel : public UPrimaryDataAsset
{
    FPrimaryAssetRules Rules;                                                         // 0x0030 (size: 0xC)
    uint8 bLabelAssetsInMyDirectory;                                                  // 0x003C (size: 0x1)
    uint8 bIsRuntimeLabel;                                                            // 0x003C (size: 0x1)
    TArray<TSoftObjectPtr<UObject>> ExplicitAssets;                                   // 0x0040 (size: 0x10)
    TArray<TSoftClassPtr<UObject>> ExplicitBlueprints;                                // 0x0050 (size: 0x10)
    FCollectionReference AssetCollection;                                             // 0x0060 (size: 0x8)

}; // Size: 0x68

class UProjectileMovementComponent : public UMovementComponent
{
    float InitialSpeed;                                                               // 0x00F0 (size: 0x4)
    float MaxSpeed;                                                                   // 0x00F4 (size: 0x4)
    uint8 bRotationFollowsVelocity;                                                   // 0x00F8 (size: 0x1)
    uint8 bRotationRemainsVertical;                                                   // 0x00F8 (size: 0x1)
    uint8 bShouldBounce;                                                              // 0x00F8 (size: 0x1)
    uint8 bInitialVelocityInLocalSpace;                                               // 0x00F8 (size: 0x1)
    uint8 bForceSubStepping;                                                          // 0x00F8 (size: 0x1)
    uint8 bSimulationEnabled;                                                         // 0x00F8 (size: 0x1)
    uint8 bSweepCollision;                                                            // 0x00F8 (size: 0x1)
    uint8 bIsHomingProjectile;                                                        // 0x00F8 (size: 0x1)
    uint8 bBounceAngleAffectsFriction;                                                // 0x00F9 (size: 0x1)
    uint8 bIsSliding;                                                                 // 0x00F9 (size: 0x1)
    uint8 bInterpMovement;                                                            // 0x00F9 (size: 0x1)
    uint8 bInterpRotation;                                                            // 0x00F9 (size: 0x1)
    float PreviousHitTime;                                                            // 0x00FC (size: 0x4)
    FVector PreviousHitNormal;                                                        // 0x0100 (size: 0xC)
    float ProjectileGravityScale;                                                     // 0x010C (size: 0x4)
    float Buoyancy;                                                                   // 0x0110 (size: 0x4)
    float Bounciness;                                                                 // 0x0114 (size: 0x4)
    float Friction;                                                                   // 0x0118 (size: 0x4)
    float BounceVelocityStopSimulatingThreshold;                                      // 0x011C (size: 0x4)
    float MinFrictionFraction;                                                        // 0x0120 (size: 0x4)
    FProjectileMovementComponentOnProjectileBounce OnProjectileBounce;                // 0x0128 (size: 0x10)
    void OnProjectileBounceDelegate(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    FProjectileMovementComponentOnProjectileStop OnProjectileStop;                    // 0x0138 (size: 0x10)
    void OnProjectileStopDelegate(const FHitResult& ImpactResult);
    float HomingAccelerationMagnitude;                                                // 0x0148 (size: 0x4)
    TWeakObjectPtr<class USceneComponent> HomingTargetComponent;                      // 0x014C (size: 0x8)
    float MaxSimulationTimeStep;                                                      // 0x0154 (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x0158 (size: 0x4)
    int32 BounceAdditionalIterations;                                                 // 0x015C (size: 0x4)
    float InterpLocationTime;                                                         // 0x0160 (size: 0x4)
    float InterpRotationTime;                                                         // 0x0164 (size: 0x4)
    float InterpLocationMaxLagDistance;                                               // 0x0168 (size: 0x4)
    float InterpLocationSnapToTargetDistance;                                         // 0x016C (size: 0x4)

    void StopSimulating(const FHitResult& HitResult);
    void SetVelocityInLocalSpace(FVector NewVelocity);
    void SetInterpolatedComponent(class USceneComponent* Component);
    void ResetInterpolation();
    void OnProjectileStopDelegate__DelegateSignature(const FHitResult& ImpactResult);
    void OnProjectileBounceDelegate__DelegateSignature(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    void MoveInterpolationTarget(const FVector& NewLocation, const FRotator& NewRotation);
    FVector LimitVelocity(FVector NewVelocity);
    bool IsVelocityUnderSimulationThreshold();
    bool IsInterpolationComplete();
}; // Size: 0x1D0

class UProxyLODMeshSimplificationSettings : public UDeveloperSettings
{
    FName ProxyLODMeshReductionModuleName;                                            // 0x0038 (size: 0x8)

}; // Size: 0x40

class ARadialForceActor : public ARigidBodyBase
{
    class URadialForceComponent* ForceComponent;                                      // 0x0228 (size: 0x8)

    void ToggleForce();
    void FireImpulse();
    void EnableForce();
    void DisableForce();
}; // Size: 0x230

class URadialForceComponent : public USceneComponent
{
    float Radius;                                                                     // 0x01F8 (size: 0x4)
    TEnumAsByte<ERadialImpulseFalloff> Falloff;                                       // 0x01FC (size: 0x1)
    float ImpulseStrength;                                                            // 0x0200 (size: 0x4)
    uint8 bImpulseVelChange;                                                          // 0x0204 (size: 0x1)
    uint8 bIgnoreOwningActor;                                                         // 0x0204 (size: 0x1)
    float ForceStrength;                                                              // 0x0208 (size: 0x4)
    float DestructibleDamage;                                                         // 0x020C (size: 0x4)
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypesToAffect;                        // 0x0210 (size: 0x10)

    void RemoveObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType);
    void FireImpulse();
    void AddObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType);
}; // Size: 0x230

class ARectLight : public ALight
{
    class URectLightComponent* RectLightComponent;                                    // 0x0238 (size: 0x8)

}; // Size: 0x240

class URectLightComponent : public ULocalLightComponent
{
    float SourceWidth;                                                                // 0x0340 (size: 0x4)
    float SourceHeight;                                                               // 0x0344 (size: 0x4)
    float BarnDoorAngle;                                                              // 0x0348 (size: 0x4)
    float BarnDoorLength;                                                             // 0x034C (size: 0x4)
    class UTexture* SourceTexture;                                                    // 0x0350 (size: 0x8)

    void SetSourceWidth(float bNewValue);
    void SetSourceTexture(class UTexture* bNewValue);
    void SetSourceHeight(float newValue);
    void SetBarnDoorLength(float newValue);
    void SetBarnDoorAngle(float newValue);
}; // Size: 0x360

class URendererSettings : public UDeveloperSettings
{
    uint8 bMobileDisableVertexFog;                                                    // 0x0038 (size: 0x1)
    int32 MaxMobileCascades;                                                          // 0x003C (size: 0x4)
    TEnumAsByte<EMobileMSAASampleCount::Type> MobileMSAASampleCount;                  // 0x0040 (size: 0x1)
    uint8 bMobileAllowDitheredLODTransition;                                          // 0x0044 (size: 0x1)
    uint8 bMobileAllowSoftwareOcclusionCulling;                                       // 0x0044 (size: 0x1)
    uint8 bMobileVirtualTextures;                                                     // 0x0044 (size: 0x1)
    uint8 bDiscardUnusedQualityLevels;                                                // 0x0044 (size: 0x1)
    uint8 bOcclusionCulling;                                                          // 0x0044 (size: 0x1)
    float MinScreenRadiusForLights;                                                   // 0x0048 (size: 0x4)
    float MinScreenRadiusForEarlyZPass;                                               // 0x004C (size: 0x4)
    float MinScreenRadiusForCSMdepth;                                                 // 0x0050 (size: 0x4)
    uint8 bPrecomputedVisibilityWarning;                                              // 0x0054 (size: 0x1)
    uint8 bTextureStreaming;                                                          // 0x0054 (size: 0x1)
    uint8 bUseDXT5NormalMaps;                                                         // 0x0054 (size: 0x1)
    uint8 bVirtualTextures;                                                           // 0x0054 (size: 0x1)
    uint8 bVirtualTextureEnableAutoImport;                                            // 0x0054 (size: 0x1)
    uint8 bVirtualTexturedLightmaps;                                                  // 0x0054 (size: 0x1)
    uint32 VirtualTextureTileSize;                                                    // 0x0058 (size: 0x4)
    uint32 VirtualTextureTileBorderSize;                                              // 0x005C (size: 0x4)
    uint32 VirtualTextureFeedbackFactor;                                              // 0x0060 (size: 0x4)
    uint8 bVirtualTextureEnableCompressZlib;                                          // 0x0064 (size: 0x1)
    uint8 bVirtualTextureEnableCompressCrunch;                                        // 0x0064 (size: 0x1)
    uint8 bClearCoatEnableSecondNormal;                                               // 0x0064 (size: 0x1)
    int32 ReflectionCaptureResolution;                                                // 0x0068 (size: 0x4)
    uint8 bReflectionCaptureCompression;                                              // 0x006C (size: 0x1)
    uint8 ReflectionEnvironmentLightmapMixBasedOnRoughness;                           // 0x006C (size: 0x1)
    uint8 bForwardShading;                                                            // 0x006C (size: 0x1)
    uint8 bVertexFoggingForOpaque;                                                    // 0x006C (size: 0x1)
    uint8 bAllowStaticLighting;                                                       // 0x006C (size: 0x1)
    uint8 bUseNormalMapsForStaticLighting;                                            // 0x006C (size: 0x1)
    uint8 bGenerateMeshDistanceFields;                                                // 0x006C (size: 0x1)
    uint8 bEightBitMeshDistanceFields;                                                // 0x006C (size: 0x1)
    uint8 bGenerateLandscapeGIData;                                                   // 0x006D (size: 0x1)
    uint8 bCompressMeshDistanceFields;                                                // 0x006D (size: 0x1)
    float TessellationAdaptivePixelsPerTriangle;                                      // 0x0070 (size: 0x4)
    uint8 bSeparateTranslucency;                                                      // 0x0074 (size: 0x1)
    TEnumAsByte<ETranslucentSortPolicy::Type> TranslucentSortPolicy;                  // 0x0078 (size: 0x1)
    FVector TranslucentSortAxis;                                                      // 0x007C (size: 0xC)
    TEnumAsByte<EFixedFoveationLevels::Type> HMDFixedFoveationLevel;                  // 0x0088 (size: 0x1)
    TEnumAsByte<ECustomDepthStencil::Type> CustomDepthStencil;                        // 0x0089 (size: 0x1)
    uint8 bCustomDepthTaaJitter;                                                      // 0x008C (size: 0x1)
    TEnumAsByte<EAlphaChannelMode::Type> bEnableAlphaChannelInPostProcessing;         // 0x0090 (size: 0x1)
    uint8 bDefaultFeatureBloom;                                                       // 0x0094 (size: 0x1)
    uint8 bDefaultFeatureAmbientOcclusion;                                            // 0x0094 (size: 0x1)
    uint8 bDefaultFeatureAmbientOcclusionStaticFraction;                              // 0x0094 (size: 0x1)
    uint8 bDefaultFeatureAutoExposure;                                                // 0x0094 (size: 0x1)
    TEnumAsByte<EAutoExposureMethodUI::Type> DefaultFeatureAutoExposure;              // 0x0098 (size: 0x1)
    float DefaultFeatureAutoExposureBias;                                             // 0x009C (size: 0x4)
    uint8 bExtendDefaultLuminanceRangeInAutoExposureSettings;                         // 0x00A0 (size: 0x1)
    uint8 bUsePreExposure;                                                            // 0x00A0 (size: 0x1)
    uint8 bEnablePreExposureOnlyInTheEditor;                                          // 0x00A0 (size: 0x1)
    uint8 bDefaultFeatureMotionBlur;                                                  // 0x00A0 (size: 0x1)
    uint8 bDefaultFeatureLensFlare;                                                   // 0x00A0 (size: 0x1)
    uint8 bTemporalUpsampling;                                                        // 0x00A0 (size: 0x1)
    uint8 bSSGI;                                                                      // 0x00A0 (size: 0x1)
    TEnumAsByte<EAntiAliasingMethod> DefaultFeatureAntiAliasing;                      // 0x00A4 (size: 0x1)
    ELightUnits DefaultLightUnits;                                                    // 0x00A5 (size: 0x1)
    TEnumAsByte<EDefaultBackBufferPixelFormat::Type> DefaultBackBufferPixelFormat;    // 0x00A6 (size: 0x1)
    uint8 bRenderUnbuiltPreviewShadowsInGame;                                         // 0x00A8 (size: 0x1)
    uint8 bStencilForLODDither;                                                       // 0x00A8 (size: 0x1)
    TEnumAsByte<EEarlyZPass::Type> EarlyZPass;                                        // 0x00AC (size: 0x1)
    uint8 bEarlyZPassOnlyMaterialMasking;                                             // 0x00B0 (size: 0x1)
    uint8 bDBuffer;                                                                   // 0x00B0 (size: 0x1)
    TEnumAsByte<EClearSceneOptions::Type> ClearSceneMethod;                           // 0x00B4 (size: 0x1)
    uint8 bBasePassOutputsVelocity;                                                   // 0x00B8 (size: 0x1)
    uint8 bVertexDeformationOutputsVelocity;                                          // 0x00B8 (size: 0x1)
    uint8 bSelectiveBasePassOutputs;                                                  // 0x00B8 (size: 0x1)
    uint8 bDefaultParticleCutouts;                                                    // 0x00B8 (size: 0x1)
    int32 GPUSimulationTextureSizeX;                                                  // 0x00BC (size: 0x4)
    int32 GPUSimulationTextureSizeY;                                                  // 0x00C0 (size: 0x4)
    uint8 bGlobalClipPlane;                                                           // 0x00C4 (size: 0x1)
    TEnumAsByte<EGBufferFormat::Type> GBufferFormat;                                  // 0x00C8 (size: 0x1)
    uint8 bUseGPUMorphTargets;                                                        // 0x00CC (size: 0x1)
    uint8 bNvidiaAftermathEnabled;                                                    // 0x00CC (size: 0x1)
    uint8 bMultiView;                                                                 // 0x00CC (size: 0x1)
    uint8 bMobilePostProcessing;                                                      // 0x00CC (size: 0x1)
    uint8 bMobileMultiView;                                                           // 0x00CC (size: 0x1)
    uint8 bMobileUseHWsRGBEncoding;                                                   // 0x00CC (size: 0x1)
    uint8 bRoundRobinOcclusion;                                                       // 0x00CC (size: 0x1)
    uint8 bODSCapture;                                                                // 0x00CC (size: 0x1)
    uint8 bMeshStreaming;                                                             // 0x00CD (size: 0x1)
    float WireframeCullThreshold;                                                     // 0x00D0 (size: 0x4)
    uint8 bEnableRayTracing;                                                          // 0x00D4 (size: 0x1)
    uint8 bEnableRayTracingTextureLOD;                                                // 0x00D4 (size: 0x1)
    uint8 bSupportStationarySkylight;                                                 // 0x00D4 (size: 0x1)
    uint8 bSupportLowQualityLightmaps;                                                // 0x00D4 (size: 0x1)
    uint8 bSupportPointLightWholeSceneShadows;                                        // 0x00D4 (size: 0x1)
    uint8 bSupportAtmosphericFog;                                                     // 0x00D4 (size: 0x1)
    uint8 bSupportSkyAtmosphere;                                                      // 0x00D4 (size: 0x1)
    uint8 bSupportSkyAtmosphereAffectsHeightFog;                                      // 0x00D4 (size: 0x1)
    uint8 bSupportSkinCacheShaders;                                                   // 0x00D5 (size: 0x1)
    ESkinCacheDefaultBehavior DefaultSkinCacheBehavior;                               // 0x00D8 (size: 0x1)
    float SkinCacheSceneMemoryLimitInMB;                                              // 0x00DC (size: 0x4)
    uint8 bMobileEnableStaticAndCSMShadowReceivers;                                   // 0x00E0 (size: 0x1)
    uint8 bMobileEnableMovableLightCSMShaderCulling;                                  // 0x00E0 (size: 0x1)
    uint8 bMobileAllowDistanceFieldShadows;                                           // 0x00E0 (size: 0x1)
    uint8 bMobileAllowMovableDirectionalLights;                                       // 0x00E0 (size: 0x1)
    uint32 MobileNumDynamicPointLights;                                               // 0x00E4 (size: 0x4)
    uint8 bMobileDynamicPointLightsUseStaticBranch;                                   // 0x00E8 (size: 0x1)
    uint8 bMobileAllowMovableSpotlights;                                              // 0x00E8 (size: 0x1)
    uint8 bMobileAllowMovableSpotlightShadows;                                        // 0x00E8 (size: 0x1)
    uint8 bSupport16BitBoneIndex;                                                     // 0x00E8 (size: 0x1)
    uint8 bGPUSkinLimit2BoneInfluences;                                               // 0x00E8 (size: 0x1)
    uint8 bSupportDepthOnlyIndexBuffers;                                              // 0x00E8 (size: 0x1)
    uint8 bSupportReversedIndexBuffers;                                               // 0x00E8 (size: 0x1)
    uint8 bLPV;                                                                       // 0x00E8 (size: 0x1)
    uint8 bMobileAmbientOcclusion;                                                    // 0x00E9 (size: 0x1)
    uint8 bUseUnlimitedBoneInfluences;                                                // 0x00E9 (size: 0x1)
    int32 UnlimitedBonInfluencesThreshold;                                            // 0x00EC (size: 0x4)
    FPerPlatformInt MaxSkinBones;                                                     // 0x00F0 (size: 0x4)
    TEnumAsByte<EMobilePlanarReflectionMode::Type> MobilePlanarReflectionMode;        // 0x00F4 (size: 0x1)
    uint8 bMobileSupportsGen4TAA;                                                     // 0x00F8 (size: 0x1)
    FPerPlatformBool bStreamSkeletalMeshLODs;                                         // 0x00FC (size: 0x1)
    FPerPlatformBool bDiscardSkeletalMeshOptionalLODs;                                // 0x00FD (size: 0x1)
    FSoftObjectPath VisualizeCalibrationColorMaterialPath;                            // 0x0100 (size: 0x18)
    FSoftObjectPath VisualizeCalibrationCustomMaterialPath;                           // 0x0118 (size: 0x18)
    FSoftObjectPath VisualizeCalibrationGrayscaleMaterialPath;                        // 0x0130 (size: 0x18)

}; // Size: 0x148

class URendererOverrideSettings : public UDeveloperSettings
{
    uint8 bSupportAllShaderPermutations;                                              // 0x0038 (size: 0x1)
    uint8 bForceRecomputeTangents;                                                    // 0x0038 (size: 0x1)

}; // Size: 0x40

class UReplayNetConnection : public UNetConnection
{
}; // Size: 0x23A8

class UReplaySubsystem : public UGameInstanceSubsystem
{
    bool bLoadDefaultMapOnStop;                                                       // 0x0030 (size: 0x1)

}; // Size: 0x40

class UReplicationDriver : public UObject
{
}; // Size: 0x28

class UReplicationConnectionDriver : public UObject
{
}; // Size: 0x28

class UReporterBase : public UObject
{
}; // Size: 0x30

class UReporterGraph : public UReporterBase
{
}; // Size: 0xA8

class UReverbEffect : public UObject
{
    bool bBypassEarlyReflections;                                                     // 0x0028 (size: 0x1)
    float ReflectionsDelay;                                                           // 0x002C (size: 0x4)
    float GainHF;                                                                     // 0x0030 (size: 0x4)
    float ReflectionsGain;                                                            // 0x0034 (size: 0x4)
    bool bBypassLateReflections;                                                      // 0x0038 (size: 0x1)
    float LateDelay;                                                                  // 0x003C (size: 0x4)
    float DecayTime;                                                                  // 0x0040 (size: 0x4)
    float Density;                                                                    // 0x0044 (size: 0x4)
    float Diffusion;                                                                  // 0x0048 (size: 0x4)
    float AirAbsorptionGainHF;                                                        // 0x004C (size: 0x4)
    float DecayHFRatio;                                                               // 0x0050 (size: 0x4)
    float LateGain;                                                                   // 0x0054 (size: 0x4)
    float Gain;                                                                       // 0x0058 (size: 0x4)
    float RoomRolloffFactor;                                                          // 0x005C (size: 0x4)

}; // Size: 0x60

struct FRigTransformConstraint
{
    TEnumAsByte<EConstraintTransform::Type> TranformType;                             // 0x0000 (size: 0x1)
    FName ParentSpace;                                                                // 0x0004 (size: 0x8)
    float Weight;                                                                     // 0x000C (size: 0x4)

}; // Size: 0x10

struct FTransformBaseConstraint
{
    TArray<FRigTransformConstraint> TransformConstraints;                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FTransformBase
{
    FName Node;                                                                       // 0x0000 (size: 0x8)
    FTransformBaseConstraint Constraints;                                             // 0x0008 (size: 0x20)

}; // Size: 0x28

struct FNode
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FName ParentName;                                                                 // 0x0008 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x30)
    FString DisplayName;                                                              // 0x0040 (size: 0x10)
    bool bAdvanced;                                                                   // 0x0050 (size: 0x1)

}; // Size: 0x60

class URig : public UObject
{
    TArray<FTransformBase> TransformBases;                                            // 0x0030 (size: 0x10)
    TArray<FNode> Nodes;                                                              // 0x0040 (size: 0x10)

}; // Size: 0x50

class URotatingMovementComponent : public UMovementComponent
{
    FRotator RotationRate;                                                            // 0x00F0 (size: 0xC)
    FVector PivotTranslation;                                                         // 0x00FC (size: 0xC)
    uint8 bRotationInLocalSpace;                                                      // 0x0108 (size: 0x1)

}; // Size: 0x110

class URuntimeOptionsBase : public UObject
{
}; // Size: 0x38

class URuntimeVirtualTexture : public UObject
{
    int32 TileCount;                                                                  // 0x0028 (size: 0x4)
    int32 TileSize;                                                                   // 0x002C (size: 0x4)
    int32 TileBorderSize;                                                             // 0x0030 (size: 0x4)
    ERuntimeVirtualTextureMaterialType MaterialType;                                  // 0x0034 (size: 0x1)
    bool bCompressTextures;                                                           // 0x0035 (size: 0x1)
    bool bClearTextures;                                                              // 0x0036 (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x0037 (size: 0x1)
    bool bPrivateSpace;                                                               // 0x0038 (size: 0x1)
    bool bAdaptive;                                                                   // 0x0039 (size: 0x1)
    bool bContinuousUpdate;                                                           // 0x003A (size: 0x1)
    int32 RemoveLowMips;                                                              // 0x003C (size: 0x4)
    TEnumAsByte<TextureGroup> LODGroup;                                               // 0x0040 (size: 0x1)
    int32 Size;                                                                       // 0x0044 (size: 0x4)
    class URuntimeVirtualTextureStreamingProxy* StreamingTexture;                     // 0x0048 (size: 0x8)

    int32 GetTileSize();
    int32 GetTileCount();
    int32 GetTileBorderSize();
    int32 GetSize();
    int32 GetPageTableSize();
}; // Size: 0xA0

class URuntimeVirtualTextureComponent : public USceneComponent
{
    TSoftObjectPtr<AActor> BoundsAlignActor;                                          // 0x01F8 (size: 0x28)
    bool bSetBoundsButton;                                                            // 0x0220 (size: 0x1)
    bool bSnapBoundsToLandscape;                                                      // 0x0221 (size: 0x1)
    class URuntimeVirtualTexture* VirtualTexture;                                     // 0x0228 (size: 0x8)
    bool bEnableScalability;                                                          // 0x0230 (size: 0x1)
    uint32 ScalabilityGroup;                                                          // 0x0234 (size: 0x4)
    bool bHidePrimitives;                                                             // 0x0238 (size: 0x1)
    class UVirtualTextureBuilder* StreamingTexture;                                   // 0x0240 (size: 0x8)
    int32 StreamLowMips;                                                              // 0x0248 (size: 0x4)
    bool bBuildStreamingMipsButton;                                                   // 0x024C (size: 0x1)
    bool bEnableCompressCrunch;                                                       // 0x024D (size: 0x1)
    bool bUseStreamingLowMipsInEditor;                                                // 0x024E (size: 0x1)
    bool bBuildDebugStreamingMips;                                                    // 0x024F (size: 0x1)

    void Invalidate(const FBoxSphereBounds& WorldBounds);
}; // Size: 0x270

class ARuntimeVirtualTextureVolume : public AActor
{
    class URuntimeVirtualTextureComponent* VirtualTextureComponent;                   // 0x0228 (size: 0x8)

}; // Size: 0x230

class IRVOAvoidanceInterface : public IInterface
{
}; // Size: 0x28

class UScene : public UObject
{
}; // Size: 0x28

class ASceneCapture2D : public ASceneCapture
{
    class USceneCaptureComponent2D* CaptureComponent2D;                               // 0x0238 (size: 0x8)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x240

class USceneCaptureComponent2D : public USceneCaptureComponent
{
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionType;                          // 0x02B0 (size: 0x1)
    float FOVAngle;                                                                   // 0x02B4 (size: 0x4)
    float OrthoWidth;                                                                 // 0x02B8 (size: 0x4)
    class UTextureRenderTarget2D* TextureTarget;                                      // 0x02C0 (size: 0x8)
    TEnumAsByte<ESceneCaptureCompositeMode> CompositeMode;                            // 0x02C8 (size: 0x1)
    FPostProcessSettings PostProcessSettings;                                         // 0x02D0 (size: 0x560)
    float PostProcessBlendWeight;                                                     // 0x0830 (size: 0x4)
    uint8 bOverride_CustomNearClippingPlane;                                          // 0x0834 (size: 0x1)
    float CustomNearClippingPlane;                                                    // 0x0838 (size: 0x4)
    bool bUseCustomProjectionMatrix;                                                  // 0x083C (size: 0x1)
    FMatrix CustomProjectionMatrix;                                                   // 0x0840 (size: 0x40)
    bool bEnableClipPlane;                                                            // 0x0880 (size: 0x1)
    FVector ClipPlaneBase;                                                            // 0x0884 (size: 0xC)
    FVector ClipPlaneNormal;                                                          // 0x0890 (size: 0xC)
    uint8 bCameraCutThisFrame;                                                        // 0x089C (size: 0x1)
    uint8 bConsiderUnrenderedOpaquePixelAsFullyTranslucent;                           // 0x089C (size: 0x1)
    bool bDisableFlipCopyGLES;                                                        // 0x08A0 (size: 0x1)

    void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
    void CaptureScene();
    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x8C0

class USceneCaptureComponentCube : public USceneCaptureComponent
{
    class UTextureRenderTargetCube* TextureTarget;                                    // 0x02B0 (size: 0x8)
    bool bCaptureRotation;                                                            // 0x02B8 (size: 0x1)
    class UTextureRenderTargetCube* TextureTargetLeft;                                // 0x02C0 (size: 0x8)
    class UTextureRenderTargetCube* TextureTargetRight;                               // 0x02C8 (size: 0x8)
    class UTextureRenderTarget2D* TextureTargetODS;                                   // 0x02D0 (size: 0x8)
    float IPD;                                                                        // 0x02D8 (size: 0x4)

    void CaptureScene();
}; // Size: 0x2E0

class ASceneCaptureCube : public ASceneCapture
{
    class USceneCaptureComponentCube* CaptureComponentCube;                           // 0x0238 (size: 0x8)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x240

struct FBPVariableMetaDataEntry
{
    FName DataKey;                                                                    // 0x0000 (size: 0x8)
    FString DataValue;                                                                // 0x0008 (size: 0x10)

}; // Size: 0x18

class USCS_Node : public UObject
{
    UClass* ComponentClass;                                                           // 0x0028 (size: 0x8)
    class UActorComponent* ComponentTemplate;                                         // 0x0030 (size: 0x8)
    FBlueprintCookedComponentInstancingData CookedComponentInstancingData;            // 0x0038 (size: 0x48)
    FName AttachToName;                                                               // 0x0080 (size: 0x8)
    FName ParentComponentOrVariableName;                                              // 0x0088 (size: 0x8)
    FName ParentComponentOwnerClassName;                                              // 0x0090 (size: 0x8)
    bool bIsParentComponentNative;                                                    // 0x0098 (size: 0x1)
    TArray<class USCS_Node*> ChildNodes;                                              // 0x00A0 (size: 0x10)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x00B0 (size: 0x10)
    FGuid VariableGuid;                                                               // 0x00C0 (size: 0x10)
    FName InternalVariableName;                                                       // 0x00D0 (size: 0x8)

}; // Size: 0xD8

class USelection : public UObject
{
}; // Size: 0xA0

class AServerStatReplicator : public AInfo
{
    bool bUpdateStatNet;                                                              // 0x0228 (size: 0x1)
    bool bOverwriteClientStats;                                                       // 0x0229 (size: 0x1)
    uint32 Channels;                                                                  // 0x022C (size: 0x4)
    uint32 InRate;                                                                    // 0x0230 (size: 0x4)
    uint32 OutRate;                                                                   // 0x0234 (size: 0x4)
    uint32 MaxPacketOverhead;                                                         // 0x023C (size: 0x4)
    uint32 InRateClientMax;                                                           // 0x0240 (size: 0x4)
    uint32 InRateClientMin;                                                           // 0x0244 (size: 0x4)
    uint32 InRateClientAvg;                                                           // 0x0248 (size: 0x4)
    uint32 InPacketsClientMax;                                                        // 0x024C (size: 0x4)
    uint32 InPacketsClientMin;                                                        // 0x0250 (size: 0x4)
    uint32 InPacketsClientAvg;                                                        // 0x0254 (size: 0x4)
    uint32 OutRateClientMax;                                                          // 0x0258 (size: 0x4)
    uint32 OutRateClientMin;                                                          // 0x025C (size: 0x4)
    uint32 OutRateClientAvg;                                                          // 0x0260 (size: 0x4)
    uint32 OutPacketsClientMax;                                                       // 0x0264 (size: 0x4)
    uint32 OutPacketsClientMin;                                                       // 0x0268 (size: 0x4)
    uint32 OutPacketsClientAvg;                                                       // 0x026C (size: 0x4)
    uint32 NetNumClients;                                                             // 0x0270 (size: 0x4)
    uint32 InPackets;                                                                 // 0x0274 (size: 0x4)
    uint32 OutPackets;                                                                // 0x0278 (size: 0x4)
    uint32 InBunches;                                                                 // 0x027C (size: 0x4)
    uint32 OutBunches;                                                                // 0x0280 (size: 0x4)
    uint32 OutLoss;                                                                   // 0x0284 (size: 0x4)
    uint32 InLoss;                                                                    // 0x0288 (size: 0x4)
    uint32 VoiceBytesSent;                                                            // 0x028C (size: 0x4)
    uint32 VoiceBytesRecv;                                                            // 0x0290 (size: 0x4)
    uint32 VoicePacketsSent;                                                          // 0x0294 (size: 0x4)
    uint32 VoicePacketsRecv;                                                          // 0x0298 (size: 0x4)
    uint32 PercentInVoice;                                                            // 0x029C (size: 0x4)
    uint32 PercentOutVoice;                                                           // 0x02A0 (size: 0x4)
    uint32 NumActorChannels;                                                          // 0x02A4 (size: 0x4)
    uint32 NumConsideredActors;                                                       // 0x02A8 (size: 0x4)
    uint32 PrioritizedActors;                                                         // 0x02AC (size: 0x4)
    uint32 NumRelevantActors;                                                         // 0x02B0 (size: 0x4)
    uint32 NumRelevantDeletedActors;                                                  // 0x02B4 (size: 0x4)
    uint32 NumReplicatedActorAttempts;                                                // 0x02B8 (size: 0x4)
    uint32 NumReplicatedActors;                                                       // 0x02BC (size: 0x4)
    uint32 NumActors;                                                                 // 0x02C0 (size: 0x4)
    uint32 NumNetActors;                                                              // 0x02C4 (size: 0x4)
    uint32 NumDormantActors;                                                          // 0x02C8 (size: 0x4)
    uint32 NumInitiallyDormantActors;                                                 // 0x02CC (size: 0x4)
    uint32 NumNetGUIDsAckd;                                                           // 0x02D0 (size: 0x4)
    uint32 NumNetGUIDsPending;                                                        // 0x02D4 (size: 0x4)
    uint32 NumNetGUIDsUnAckd;                                                         // 0x02D8 (size: 0x4)
    uint32 ObjPathBytes;                                                              // 0x02DC (size: 0x4)
    uint32 NetGUIDOutRate;                                                            // 0x02E0 (size: 0x4)
    uint32 NetGUIDInRate;                                                             // 0x02E4 (size: 0x4)
    uint32 NetSaturated;                                                              // 0x02E8 (size: 0x4)

}; // Size: 0x2F0

class UShadowMapTexture2D : public UTexture2D
{
    TEnumAsByte<EShadowMapFlags> ShadowmapFlags;                                      // 0x01A0 (size: 0x1)

}; // Size: 0x1B0

class USimpleConstructionScript : public UObject
{
    TArray<class USCS_Node*> RootNodes;                                               // 0x0028 (size: 0x10)
    TArray<class USCS_Node*> AllNodes;                                                // 0x0038 (size: 0x10)
    class USCS_Node* DefaultSceneRootNode;                                            // 0x0048 (size: 0x8)

}; // Size: 0xA0

class ASkeletalMeshActor : public AActor
{
    uint8 bShouldDoAnimNotifies;                                                      // 0x0230 (size: 0x1)
    uint8 bWakeOnLevelStart;                                                          // 0x0230 (size: 0x1)
    class USkeletalMeshComponent* SkeletalMeshComponent;                              // 0x0238 (size: 0x8)
    class USkeletalMesh* ReplicatedMesh;                                              // 0x0240 (size: 0x8)
    class UPhysicsAsset* ReplicatedPhysAsset;                                         // 0x0248 (size: 0x8)
    class UMaterialInterface* ReplicatedMaterial0;                                    // 0x0250 (size: 0x8)
    class UMaterialInterface* ReplicatedMaterial1;                                    // 0x0258 (size: 0x8)

    void OnRep_ReplicatedPhysAsset();
    void OnRep_ReplicatedMesh();
    void OnRep_ReplicatedMaterial1();
    void OnRep_ReplicatedMaterial0();
}; // Size: 0x2B0

class USkeletalMeshEditorData : public UObject
{
}; // Size: 0x28

struct FBoneFilter
{
    bool bExcludeSelf;                                                                // 0x0000 (size: 0x1)
    FName BoneName;                                                                   // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FSkeletalMeshLODGroupSettings
{
    FPerPlatformFloat ScreenSize;                                                     // 0x0000 (size: 0x4)
    float LODHysteresis;                                                              // 0x0004 (size: 0x4)
    EBoneFilterActionOption BoneFilterActionOption;                                   // 0x0008 (size: 0x1)
    TArray<FBoneFilter> BoneList;                                                     // 0x0010 (size: 0x10)
    TArray<FName> BonesToPrioritize;                                                  // 0x0020 (size: 0x10)
    float WeightOfPrioritization;                                                     // 0x0030 (size: 0x4)
    class UAnimSequence* BakePose;                                                    // 0x0038 (size: 0x8)
    FSkeletalMeshOptimizationSettings ReductionSettings;                              // 0x0040 (size: 0x3C)

}; // Size: 0x80

class USkeletalMeshLODSettings : public UDataAsset
{
    FPerPlatformInt MinLOD;                                                           // 0x0030 (size: 0x4)
    FPerPlatformBool DisableBelowMinLodStripping;                                     // 0x0034 (size: 0x1)
    bool bOverrideLODStreamingSettings;                                               // 0x0035 (size: 0x1)
    FPerPlatformBool bSupportLODStreaming;                                            // 0x0036 (size: 0x1)
    FPerPlatformInt MaxNumStreamedLODs;                                               // 0x0038 (size: 0x4)
    FPerPlatformInt MaxNumOptionalLODs;                                               // 0x003C (size: 0x4)
    TArray<FSkeletalMeshLODGroupSettings> LODGroups;                                  // 0x0040 (size: 0x10)

}; // Size: 0x50

class USkeletalMeshSimplificationSettings : public UDeveloperSettings
{
    FName SkeletalMeshReductionModuleName;                                            // 0x0038 (size: 0x8)

}; // Size: 0x40

class USkeletalMeshSocket : public UObject
{
    FName SocketName;                                                                 // 0x0028 (size: 0x8)
    FName BoneName;                                                                   // 0x0030 (size: 0x8)
    FVector RelativeLocation;                                                         // 0x0038 (size: 0xC)
    FRotator RelativeRotation;                                                        // 0x0044 (size: 0xC)
    FVector RelativeScale;                                                            // 0x0050 (size: 0xC)
    bool bForceAlwaysAnimated;                                                        // 0x005C (size: 0x1)

    void InitializeSocketFromLocation(const class USkeletalMeshComponent* SkelComp, FVector WorldLocation, FVector WorldNormal);
    FVector GetSocketLocation(const class USkeletalMeshComponent* SkelComp);
}; // Size: 0x60

struct FTentDistribution
{
    float TipAltitude;                                                                // 0x0000 (size: 0x4)
    float TipValue;                                                                   // 0x0004 (size: 0x4)
    float Width;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

class USkyAtmosphereComponent : public USceneComponent
{
    ESkyAtmosphereTransformMode TransformMode;                                        // 0x01F8 (size: 0x1)
    float BottomRadius;                                                               // 0x01FC (size: 0x4)
    FColor GroundAlbedo;                                                              // 0x0200 (size: 0x4)
    float AtmosphereHeight;                                                           // 0x0204 (size: 0x4)
    float MultiScatteringFactor;                                                      // 0x0208 (size: 0x4)
    float TraceSampleCountScale;                                                      // 0x020C (size: 0x4)
    float RayleighScatteringScale;                                                    // 0x0210 (size: 0x4)
    FLinearColor RayleighScattering;                                                  // 0x0214 (size: 0x10)
    float RayleighExponentialDistribution;                                            // 0x0224 (size: 0x4)
    float MieScatteringScale;                                                         // 0x0228 (size: 0x4)
    FLinearColor MieScattering;                                                       // 0x022C (size: 0x10)
    float MieAbsorptionScale;                                                         // 0x023C (size: 0x4)
    FLinearColor MieAbsorption;                                                       // 0x0240 (size: 0x10)
    float MieAnisotropy;                                                              // 0x0250 (size: 0x4)
    float MieExponentialDistribution;                                                 // 0x0254 (size: 0x4)
    float OtherAbsorptionScale;                                                       // 0x0258 (size: 0x4)
    FLinearColor OtherAbsorption;                                                     // 0x025C (size: 0x10)
    FTentDistribution OtherTentDistribution;                                          // 0x026C (size: 0xC)
    FLinearColor SkyLuminanceFactor;                                                  // 0x0278 (size: 0x10)
    float AerialPespectiveViewDistanceScale;                                          // 0x0288 (size: 0x4)
    float HeightFogContribution;                                                      // 0x028C (size: 0x4)
    float TransmittanceMinLightElevationAngle;                                        // 0x0290 (size: 0x4)
    float AerialPerspectiveStartDepth;                                                // 0x0294 (size: 0x4)
    FGuid bStaticLightingBuiltGUID;                                                   // 0x02BC (size: 0x10)

    void SetSkyLuminanceFactor(FLinearColor newValue);
    void SetRayleighScatteringScale(float newValue);
    void SetRayleighScattering(FLinearColor newValue);
    void SetRayleighExponentialDistribution(float newValue);
    void SetOtherAbsorptionScale(float newValue);
    void SetOtherAbsorption(FLinearColor newValue);
    void SetMultiScatteringFactor(float newValue);
    void SetMieScatteringScale(float newValue);
    void SetMieScattering(FLinearColor newValue);
    void SetMieExponentialDistribution(float newValue);
    void SetMieAnisotropy(float newValue);
    void SetMieAbsorptionScale(float newValue);
    void SetMieAbsorption(FLinearColor newValue);
    void SetHeightFogContribution(float newValue);
    void SetAtmosphereHeight(float newValue);
    void SetAerialPespectiveViewDistanceScale(float newValue);
    void OverrideAtmosphereLightDirection(int32 AtmosphereLightIndex, const FVector& LightDirection);
    FLinearColor GetAtmosphereTransmitanceOnGroundAtPlanetTop(class UDirectionalLightComponent* DirectionalLight);
}; // Size: 0x2D0

class ASkyAtmosphere : public AInfo
{
    class USkyAtmosphereComponent* SkyAtmosphereComponent;                            // 0x0228 (size: 0x8)

}; // Size: 0x230

class USkyLightComponent : public ULightComponentBase
{
    bool bRealTimeCapture;                                                            // 0x0228 (size: 0x1)
    TEnumAsByte<ESkyLightSourceType> SourceType;                                      // 0x0229 (size: 0x1)
    class UTextureCube* Cubemap;                                                      // 0x0230 (size: 0x8)
    float SourceCubemapAngle;                                                         // 0x0238 (size: 0x4)
    int32 CubemapResolution;                                                          // 0x023C (size: 0x4)
    float SkyDistanceThreshold;                                                       // 0x0240 (size: 0x4)
    bool bCaptureEmissiveOnly;                                                        // 0x0244 (size: 0x1)
    bool bLowerHemisphereIsBlack;                                                     // 0x0245 (size: 0x1)
    FLinearColor LowerHemisphereColor;                                                // 0x0248 (size: 0x10)
    float OcclusionMaxDistance;                                                       // 0x0258 (size: 0x4)
    float Contrast;                                                                   // 0x025C (size: 0x4)
    float OcclusionExponent;                                                          // 0x0260 (size: 0x4)
    float MinOcclusion;                                                               // 0x0264 (size: 0x4)
    FColor OcclusionTint;                                                             // 0x0268 (size: 0x4)
    uint8 bCloudAmbientOcclusion;                                                     // 0x026C (size: 0x1)
    float CloudAmbientOcclusionStrength;                                              // 0x0270 (size: 0x4)
    float CloudAmbientOcclusionExtent;                                                // 0x0274 (size: 0x4)
    float CloudAmbientOcclusionMapResolutionScale;                                    // 0x0278 (size: 0x4)
    float CloudAmbientOcclusionApertureScale;                                         // 0x027C (size: 0x4)
    TEnumAsByte<EOcclusionCombineMode> OcclusionCombineMode;                          // 0x0280 (size: 0x1)
    class UTextureCube* BlendDestinationCubemap;                                      // 0x0328 (size: 0x8)

    void SetVolumetricScatteringIntensity(float NewIntensity);
    void SetOcclusionTint(const FColor& InTint);
    void SetOcclusionExponent(float InOcclusionExponent);
    void SetOcclusionContrast(float InOcclusionContrast);
    void SetMinOcclusion(float InMinOcclusion);
    void SetLowerHemisphereColor(const FLinearColor& InLowerHemisphereColor);
    void SetLightColor(FLinearColor NewLightColor);
    void SetIntensity(float NewIntensity);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction);
    void SetCubemap(class UTextureCube* NewCubemap);
    void RecaptureSky();
}; // Size: 0x400

class USlateBrushAsset : public UObject
{
    FSlateBrush Brush;                                                                // 0x0028 (size: 0x88)

}; // Size: 0xB0

class ISlateTextureAtlasInterface : public IInterface
{
}; // Size: 0x28

class USmokeTestCommandlet : public UCommandlet
{
}; // Size: 0x80

class USoundAttenuation : public UObject
{
    FSoundAttenuationSettings Attenuation;                                            // 0x0028 (size: 0x3A0)

}; // Size: 0x3C8

struct FSoundClassProperties
{
    float Volume;                                                                     // 0x0000 (size: 0x4)
    float Pitch;                                                                      // 0x0004 (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x0008 (size: 0x4)
    float AttenuationDistanceScale;                                                   // 0x000C (size: 0x4)
    float LFEBleed;                                                                   // 0x0010 (size: 0x4)
    float VoiceCenterChannelVolume;                                                   // 0x0014 (size: 0x4)
    float RadioFilterVolume;                                                          // 0x0018 (size: 0x4)
    float RadioFilterVolumeThreshold;                                                 // 0x001C (size: 0x4)
    uint8 bApplyEffects;                                                              // 0x0020 (size: 0x1)
    uint8 bAlwaysPlay;                                                                // 0x0020 (size: 0x1)
    uint8 bIsUISound;                                                                 // 0x0020 (size: 0x1)
    uint8 bIsMusic;                                                                   // 0x0020 (size: 0x1)
    uint8 bCenterChannelOnly;                                                         // 0x0020 (size: 0x1)
    uint8 bApplyAmbientVolumes;                                                       // 0x0020 (size: 0x1)
    uint8 bReverb;                                                                    // 0x0020 (size: 0x1)
    float Default2DReverbSendAmount;                                                  // 0x0024 (size: 0x4)
    FSoundModulationDefaultSettings ModulationSettings;                               // 0x0028 (size: 0x40)
    TEnumAsByte<EAudioOutputTarget::Type> OutputTarget;                               // 0x0068 (size: 0x1)
    ESoundWaveLoadingBehavior LoadingBehavior;                                        // 0x0069 (size: 0x1)
    class USoundSubmix* DefaultSubmix;                                                // 0x0070 (size: 0x8)

}; // Size: 0x78

struct FPassiveSoundMixModifier
{
    class USoundMix* SoundMix;                                                        // 0x0000 (size: 0x8)
    float MinVolumeThreshold;                                                         // 0x0008 (size: 0x4)
    float MaxVolumeThreshold;                                                         // 0x000C (size: 0x4)

}; // Size: 0x10

class USoundClass : public UObject
{
    FSoundClassProperties Properties;                                                 // 0x0028 (size: 0x78)
    TArray<class USoundClass*> ChildClasses;                                          // 0x00A0 (size: 0x10)
    TArray<FPassiveSoundMixModifier> PassiveSoundMixModifiers;                        // 0x00B0 (size: 0x10)
    class USoundClass* ParentClass;                                                   // 0x00C0 (size: 0x8)

}; // Size: 0xC8

class USoundConcurrency : public UObject
{
    FSoundConcurrencySettings Concurrency;                                            // 0x0028 (size: 0x28)

}; // Size: 0x50

class USoundCue : public USoundBase
{
    uint8 bPrimeOnLoad;                                                               // 0x0170 (size: 0x1)
    class USoundNode* FirstNode;                                                      // 0x0178 (size: 0x8)
    float VolumeMultiplier;                                                           // 0x0180 (size: 0x4)
    float PitchMultiplier;                                                            // 0x0184 (size: 0x4)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0188 (size: 0x3A0)
    float SubtitlePriority;                                                           // 0x0528 (size: 0x4)
    uint8 bOverrideAttenuation;                                                       // 0x0530 (size: 0x1)
    uint8 bExcludeFromRandomNodeBranchCulling;                                        // 0x0530 (size: 0x1)
    int32 CookedQualityIndex;                                                         // 0x0534 (size: 0x4)
    uint8 bHasPlayWhenSilent;                                                         // 0x0538 (size: 0x1)

}; // Size: 0x548

class USoundEffectSourcePresetChain : public UObject
{
    TArray<FSourceEffectChainEntry> Chain;                                            // 0x0028 (size: 0x10)
    uint8 bPlayEffectChainTails;                                                      // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FSoundGroup
{
    TEnumAsByte<ESoundGroup> SoundGroup;                                              // 0x0000 (size: 0x1)
    FString DisplayName;                                                              // 0x0008 (size: 0x10)
    uint8 bAlwaysDecompressOnLoad;                                                    // 0x0018 (size: 0x1)
    float DecompressedDuration;                                                       // 0x001C (size: 0x4)

}; // Size: 0x20

class USoundGroups : public UObject
{
    TArray<FSoundGroup> SoundGroupProfiles;                                           // 0x0028 (size: 0x10)

}; // Size: 0x88

struct FAudioEffectParameters
{
}; // Size: 0x8

struct FAudioEQEffect : public FAudioEffectParameters
{
    float FrequencyCenter0;                                                           // 0x0010 (size: 0x4)
    float Gain0;                                                                      // 0x0014 (size: 0x4)
    float Bandwidth0;                                                                 // 0x0018 (size: 0x4)
    float FrequencyCenter1;                                                           // 0x001C (size: 0x4)
    float Gain1;                                                                      // 0x0020 (size: 0x4)
    float Bandwidth1;                                                                 // 0x0024 (size: 0x4)
    float FrequencyCenter2;                                                           // 0x0028 (size: 0x4)
    float Gain2;                                                                      // 0x002C (size: 0x4)
    float Bandwidth2;                                                                 // 0x0030 (size: 0x4)
    float FrequencyCenter3;                                                           // 0x0034 (size: 0x4)
    float Gain3;                                                                      // 0x0038 (size: 0x4)
    float Bandwidth3;                                                                 // 0x003C (size: 0x4)

}; // Size: 0x40

struct FSoundClassAdjuster
{
    class USoundClass* SoundClassObject;                                              // 0x0000 (size: 0x8)
    float VolumeAdjuster;                                                             // 0x0008 (size: 0x4)
    float PitchAdjuster;                                                              // 0x000C (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x0010 (size: 0x4)
    uint8 bApplyToChildren;                                                           // 0x0014 (size: 0x1)
    float VoiceCenterChannelVolumeAdjuster;                                           // 0x0018 (size: 0x4)

}; // Size: 0x20

class USoundMix : public UObject
{
    uint8 bApplyEQ;                                                                   // 0x0028 (size: 0x1)
    float EQPriority;                                                                 // 0x002C (size: 0x4)
    FAudioEQEffect EQSettings;                                                        // 0x0030 (size: 0x40)
    TArray<FSoundClassAdjuster> SoundClassEffects;                                    // 0x0070 (size: 0x10)
    float InitialDelay;                                                               // 0x0080 (size: 0x4)
    float FadeInTime;                                                                 // 0x0084 (size: 0x4)
    float Duration;                                                                   // 0x0088 (size: 0x4)
    float FadeOutTime;                                                                // 0x008C (size: 0x4)

}; // Size: 0x90

class USoundNode : public UObject
{
    TArray<class USoundNode*> ChildNodes;                                             // 0x0028 (size: 0x10)

}; // Size: 0x48

class USoundNodeAssetReferencer : public USoundNode
{
}; // Size: 0x48

class USoundNodeAttenuation : public USoundNode
{
    class USoundAttenuation* AttenuationSettings;                                     // 0x0048 (size: 0x8)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0050 (size: 0x3A0)
    uint8 bOverrideAttenuation;                                                       // 0x03F0 (size: 0x1)

}; // Size: 0x3F8

class USoundNodeBranch : public USoundNode
{
    FName BoolParameterName;                                                          // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeConcatenator : public USoundNode
{
    TArray<float> InputVolume;                                                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeDelay : public USoundNode
{
    float DelayMin;                                                                   // 0x0048 (size: 0x4)
    float DelayMax;                                                                   // 0x004C (size: 0x4)

}; // Size: 0x50

struct FDialogueWaveParameter
{
    class UDialogueWave* DialogueWave;                                                // 0x0000 (size: 0x8)
    FDialogueContext Context;                                                         // 0x0008 (size: 0x18)

}; // Size: 0x20

class USoundNodeDialoguePlayer : public USoundNode
{
    FDialogueWaveParameter DialogueWaveParameter;                                     // 0x0048 (size: 0x20)
    uint8 bLooping;                                                                   // 0x0068 (size: 0x1)

}; // Size: 0x70

struct FDistanceDatum
{
    float FadeInDistanceStart;                                                        // 0x0000 (size: 0x4)
    float FadeInDistanceEnd;                                                          // 0x0004 (size: 0x4)
    float FadeOutDistanceStart;                                                       // 0x0008 (size: 0x4)
    float FadeOutDistanceEnd;                                                         // 0x000C (size: 0x4)
    float Volume;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

class USoundNodeDistanceCrossFade : public USoundNode
{
    TArray<FDistanceDatum> CrossFadeInput;                                            // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeDoppler : public USoundNode
{
    float DopplerIntensity;                                                           // 0x0048 (size: 0x4)
    bool bUseSmoothing;                                                               // 0x004C (size: 0x1)
    float SmoothingInterpSpeed;                                                       // 0x0050 (size: 0x4)

}; // Size: 0x58

class USoundNodeEnveloper : public USoundNode
{
    float LoopStart;                                                                  // 0x0048 (size: 0x4)
    float LoopEnd;                                                                    // 0x004C (size: 0x4)
    float DurationAfterLoop;                                                          // 0x0050 (size: 0x4)
    int32 LoopCount;                                                                  // 0x0054 (size: 0x4)
    uint8 bLoopIndefinitely;                                                          // 0x0058 (size: 0x1)
    uint8 bLoop;                                                                      // 0x0058 (size: 0x1)
    class UDistributionFloatConstantCurve* VolumeInterpCurve;                         // 0x0060 (size: 0x8)
    class UDistributionFloatConstantCurve* PitchInterpCurve;                          // 0x0068 (size: 0x8)
    FRuntimeFloatCurve VolumeCurve;                                                   // 0x0070 (size: 0x88)
    FRuntimeFloatCurve PitchCurve;                                                    // 0x00F8 (size: 0x88)
    float PitchMin;                                                                   // 0x0180 (size: 0x4)
    float PitchMax;                                                                   // 0x0184 (size: 0x4)
    float VolumeMin;                                                                  // 0x0188 (size: 0x4)
    float VolumeMax;                                                                  // 0x018C (size: 0x4)

}; // Size: 0x190

class USoundNodeGroupControl : public USoundNode
{
    TArray<int32> GroupSizes;                                                         // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeLooping : public USoundNode
{
    int32 LoopCount;                                                                  // 0x0048 (size: 0x4)
    uint8 bLoopIndefinitely;                                                          // 0x004C (size: 0x1)

}; // Size: 0x50

class USoundNodeMature : public USoundNode
{
}; // Size: 0x48

class USoundNodeMixer : public USoundNode
{
    TArray<float> InputVolume;                                                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeModulator : public USoundNode
{
    float PitchMin;                                                                   // 0x0048 (size: 0x4)
    float PitchMax;                                                                   // 0x004C (size: 0x4)
    float VolumeMin;                                                                  // 0x0050 (size: 0x4)
    float VolumeMax;                                                                  // 0x0054 (size: 0x4)

}; // Size: 0x58

struct FModulatorContinuousParams
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    float Default;                                                                    // 0x0008 (size: 0x4)
    float MinInput;                                                                   // 0x000C (size: 0x4)
    float MaxInput;                                                                   // 0x0010 (size: 0x4)
    float MinOutput;                                                                  // 0x0014 (size: 0x4)
    float MaxOutput;                                                                  // 0x0018 (size: 0x4)
    TEnumAsByte<ModulationParamMode> ParamMode;                                       // 0x001C (size: 0x1)

}; // Size: 0x20

class USoundNodeModulatorContinuous : public USoundNode
{
    FModulatorContinuousParams PitchModulationParams;                                 // 0x0048 (size: 0x20)
    FModulatorContinuousParams VolumeModulationParams;                                // 0x0068 (size: 0x20)

}; // Size: 0x88

class USoundNodeOscillator : public USoundNode
{
    uint8 bModulateVolume;                                                            // 0x0048 (size: 0x1)
    uint8 bModulatePitch;                                                             // 0x0048 (size: 0x1)
    float AmplitudeMin;                                                               // 0x004C (size: 0x4)
    float AmplitudeMax;                                                               // 0x0050 (size: 0x4)
    float FrequencyMin;                                                               // 0x0054 (size: 0x4)
    float FrequencyMax;                                                               // 0x0058 (size: 0x4)
    float OffsetMin;                                                                  // 0x005C (size: 0x4)
    float OffsetMax;                                                                  // 0x0060 (size: 0x4)
    float CenterMin;                                                                  // 0x0064 (size: 0x4)
    float CenterMax;                                                                  // 0x0068 (size: 0x4)

}; // Size: 0x70

class USoundNodeParamCrossFade : public USoundNodeDistanceCrossFade
{
    FName ParamName;                                                                  // 0x0058 (size: 0x8)

}; // Size: 0x60

class USoundNodeQualityLevel : public USoundNode
{
    int32 CookedQualityLevelIndex;                                                    // 0x0048 (size: 0x4)

}; // Size: 0x50

class USoundNodeRandom : public USoundNode
{
    TArray<float> Weights;                                                            // 0x0048 (size: 0x10)
    TArray<bool> HasBeenUsed;                                                         // 0x0058 (size: 0x10)
    int32 NumRandomUsed;                                                              // 0x0068 (size: 0x4)
    int32 PreselectAtLevelLoad;                                                       // 0x006C (size: 0x4)
    uint8 bShouldExcludeFromBranchCulling;                                            // 0x0070 (size: 0x1)
    uint8 bSoundCueExcludedFromBranchCulling;                                         // 0x0070 (size: 0x1)
    uint8 bRandomizeWithoutReplacement;                                               // 0x0070 (size: 0x1)

}; // Size: 0x78

class USoundNodeSoundClass : public USoundNode
{
    class USoundClass* SoundClassOverride;                                            // 0x0048 (size: 0x8)

}; // Size: 0x58

class USoundNodeSwitch : public USoundNode
{
    FName IntParameterName;                                                           // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeWaveParam : public USoundNode
{
    FName WaveParameterName;                                                          // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeWavePlayer : public USoundNodeAssetReferencer
{
    TSoftObjectPtr<USoundWave> SoundWaveAssetPtr;                                     // 0x0048 (size: 0x28)
    class USoundWave* SoundWave;                                                      // 0x0070 (size: 0x8)
    uint8 bLooping;                                                                   // 0x0080 (size: 0x1)

}; // Size: 0x88

class USoundSourceBus : public USoundWave
{
    ESourceBusChannels SourceBusChannels;                                             // 0x0370 (size: 0x1)
    float SourceBusDuration;                                                          // 0x0374 (size: 0x4)
    class UAudioBus* AudioBus;                                                        // 0x0378 (size: 0x8)
    uint8 bAutoDeactivateWhenSilent;                                                  // 0x0380 (size: 0x1)

}; // Size: 0x388

class USoundSubmixBase : public UObject
{
    TArray<class USoundSubmixBase*> ChildSubmixes;                                    // 0x0028 (size: 0x10)

}; // Size: 0x38

class USoundSubmixWithParentBase : public USoundSubmixBase
{
    class USoundSubmixBase* ParentSubmix;                                             // 0x0038 (size: 0x8)

}; // Size: 0x40

class USoundSubmix : public USoundSubmixWithParentBase
{
    uint8 bMuteWhenBackgrounded;                                                      // 0x0040 (size: 0x1)
    TArray<class USoundEffectSubmixPreset*> SubmixEffectChain;                        // 0x0048 (size: 0x10)
    class USoundfieldEncodingSettingsBase* AmbisonicsPluginSettings;                  // 0x0058 (size: 0x8)
    int32 EnvelopeFollowerAttackTime;                                                 // 0x0060 (size: 0x4)
    int32 EnvelopeFollowerReleaseTime;                                                // 0x0064 (size: 0x4)
    EGainParamMode GainMode;                                                          // 0x0068 (size: 0x1)
    float OutputVolume;                                                               // 0x006C (size: 0x4)
    float WetLevel;                                                                   // 0x0070 (size: 0x4)
    float DryLevel;                                                                   // 0x0074 (size: 0x4)
    FSoundModulationDestinationSettings OutputVolumeModulation;                       // 0x0078 (size: 0x10)
    FSoundModulationDestinationSettings WetLevelModulation;                           // 0x0088 (size: 0x10)
    FSoundModulationDestinationSettings DryLevelModulation;                           // 0x0098 (size: 0x10)
    FSoundSubmixOnSubmixRecordedFileDone OnSubmixRecordedFileDone;                    // 0x00A8 (size: 0x10)
    void OnSubmixRecordedFileDone(const class USoundWave* ResultingSoundWave);

    void StopSpectralAnalysis(const class UObject* WorldContextObject);
    void StopRecordingOutput(const class UObject* WorldContextObject, EAudioRecordingExportType ExportType, FString Name, FString Path, class USoundWave* ExistingSoundWaveToOverwrite);
    void StopEnvelopeFollowing(const class UObject* WorldContextObject);
    void StartSpectralAnalysis(const class UObject* WorldContextObject, EFFTSize FFTSize, EFFTPeakInterpolationMethod InterpolationMethod, EFFTWindowType WindowType, float HopSize, EAudioSpectrumType SpectrumType);
    void StartRecordingOutput(const class UObject* WorldContextObject, float ExpectedDuration);
    void StartEnvelopeFollowing(const class UObject* WorldContextObject);
    void SetSubmixOutputVolume(const class UObject* WorldContextObject, float InOutputVolume);
    void RemoveSpectralAnalysisDelegate(const class UObject* WorldContextObject, const FRemoveSpectralAnalysisDelegateOnSubmixSpectralAnalysisBP& OnSubmixSpectralAnalysisBP);
    void AddSpectralAnalysisDelegate(const class UObject* WorldContextObject, const TArray<FSoundSubmixSpectralAnalysisBandSettings>& InBandSettings, const FAddSpectralAnalysisDelegateOnSubmixSpectralAnalysisBP& OnSubmixSpectralAnalysisBP, float UpdateRate, float DecibelNoiseFloor, bool bDoNormalize, bool bDoAutoRange, float AutoRangeAttackTime, float AutoRangeReleaseTime);
    void AddEnvelopeFollowerDelegate(const class UObject* WorldContextObject, const FAddEnvelopeFollowerDelegateOnSubmixEnvelopeBP& OnSubmixEnvelopeBP);
}; // Size: 0xC0

class USoundfieldSubmix : public USoundSubmixWithParentBase
{
    FName SoundfieldEncodingFormat;                                                   // 0x0040 (size: 0x8)
    class USoundfieldEncodingSettingsBase* EncodingSettings;                          // 0x0048 (size: 0x8)
    TArray<class USoundfieldEffectBase*> SoundfieldEffectChain;                       // 0x0050 (size: 0x10)
    TSubclassOf<class USoundfieldEncodingSettingsBase> EncodingSettingsClass;         // 0x0060 (size: 0x8)

}; // Size: 0x68

class UEndpointSubmix : public USoundSubmixBase
{
    FName EndpointType;                                                               // 0x0038 (size: 0x8)
    TSubclassOf<class UAudioEndpointSettingsBase> EndpointSettingsClass;              // 0x0040 (size: 0x8)
    class UAudioEndpointSettingsBase* EndpointSettings;                               // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundfieldEndpointSubmix : public USoundSubmixBase
{
    FName SoundfieldEndpointType;                                                     // 0x0038 (size: 0x8)
    TSubclassOf<class UAudioEndpointSettingsBase> EndpointSettingsClass;              // 0x0040 (size: 0x8)
    class USoundfieldEndpointSettingsBase* EndpointSettings;                          // 0x0048 (size: 0x8)
    TSubclassOf<class USoundfieldEncodingSettingsBase> EncodingSettingsClass;         // 0x0050 (size: 0x8)
    class USoundfieldEncodingSettingsBase* EncodingSettings;                          // 0x0058 (size: 0x8)
    TArray<class USoundfieldEffectBase*> SoundfieldEffectChain;                       // 0x0060 (size: 0x10)

}; // Size: 0x70

class USpectatorPawnMovement : public UFloatingPawnMovement
{
    uint8 bIgnoreTimeDilation;                                                        // 0x0150 (size: 0x1)

}; // Size: 0x158

class ASphereReflectionCapture : public AReflectionCapture
{
    class UDrawSphereComponent* DrawCaptureRadius;                                    // 0x0230 (size: 0x8)

}; // Size: 0x238

class USphereReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float InfluenceRadius;                                                            // 0x0270 (size: 0x4)
    float CaptureDistanceScale;                                                       // 0x0274 (size: 0x4)
    class UDrawSphereComponent* PreviewInfluenceRadius;                               // 0x0278 (size: 0x8)

}; // Size: 0x280

class USplineMetadata : public UObject
{
}; // Size: 0x28

class ASplineMeshActor : public AActor
{
    class USplineMeshComponent* SplineMeshComponent;                                  // 0x0228 (size: 0x8)

}; // Size: 0x230

class USpringArmComponent : public USceneComponent
{
    float TargetArmLength;                                                            // 0x01F8 (size: 0x4)
    FVector SocketOffset;                                                             // 0x01FC (size: 0xC)
    FVector TargetOffset;                                                             // 0x0208 (size: 0xC)
    float ProbeSize;                                                                  // 0x0214 (size: 0x4)
    TEnumAsByte<ECollisionChannel> ProbeChannel;                                      // 0x0218 (size: 0x1)
    uint8 bDoCollisionTest;                                                           // 0x021C (size: 0x1)
    uint8 bUsePawnControlRotation;                                                    // 0x021C (size: 0x1)
    uint8 bInheritPitch;                                                              // 0x021C (size: 0x1)
    uint8 bInheritYaw;                                                                // 0x021C (size: 0x1)
    uint8 bInheritRoll;                                                               // 0x021C (size: 0x1)
    uint8 bEnableCameraLag;                                                           // 0x021C (size: 0x1)
    uint8 bEnableCameraRotationLag;                                                   // 0x021C (size: 0x1)
    uint8 bUseCameraLagSubstepping;                                                   // 0x021C (size: 0x1)
    uint8 bDrawDebugLagMarkers;                                                       // 0x021D (size: 0x1)
    float CameraLagSpeed;                                                             // 0x0220 (size: 0x4)
    float CameraRotationLagSpeed;                                                     // 0x0224 (size: 0x4)
    float CameraLagMaxTimeStep;                                                       // 0x0228 (size: 0x4)
    float CameraLagMaxDistance;                                                       // 0x022C (size: 0x4)

    bool IsCollisionFixApplied();
    FVector GetUnfixedCameraPosition();
    FRotator GetTargetRotation();
}; // Size: 0x280

class UStaticMesh : public UStreamableRenderAsset
{
    FPerPlatformInt MinLOD;                                                           // 0x0080 (size: 0x4)
    float LpvBiasMultiplier;                                                          // 0x0084 (size: 0x4)
    TArray<FStaticMaterial> StaticMaterials;                                          // 0x0088 (size: 0x10)
    float LightmapUVDensity;                                                          // 0x0098 (size: 0x4)
    int32 LightMapResolution;                                                         // 0x009C (size: 0x4)
    int32 LightMapCoordinateIndex;                                                    // 0x00A0 (size: 0x4)
    float DistanceFieldSelfShadowBias;                                                // 0x00A4 (size: 0x4)
    class UBodySetup* BodySetup;                                                      // 0x00A8 (size: 0x8)
    int32 LODForCollision;                                                            // 0x00B0 (size: 0x4)
    uint8 bGenerateMeshDistanceField;                                                 // 0x00B4 (size: 0x1)
    uint8 bStripComplexCollisionForConsole;                                           // 0x00B4 (size: 0x1)
    uint8 bHasNavigationData;                                                         // 0x00B4 (size: 0x1)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x00B4 (size: 0x1)
    uint8 bSupportPhysicalMaterialMasks;                                              // 0x00B4 (size: 0x1)
    uint8 bSupportRayTracing;                                                         // 0x00B4 (size: 0x1)
    uint8 bIsBuiltAtRuntime;                                                          // 0x00B4 (size: 0x1)
    uint8 bAllowCPUAccess;                                                            // 0x00B5 (size: 0x1)
    uint8 bSupportGpuUniformlyDistributedSampling;                                    // 0x00B5 (size: 0x1)
    TArray<class UStaticMeshSocket*> Sockets;                                         // 0x00D8 (size: 0x10)
    FVector PositiveBoundsExtension;                                                  // 0x00F8 (size: 0xC)
    FVector NegativeBoundsExtension;                                                  // 0x0104 (size: 0xC)
    FBoxSphereBounds ExtendedBounds;                                                  // 0x0110 (size: 0x1C)
    int32 ElementToIgnoreForTexFactor;                                                // 0x012C (size: 0x4)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0130 (size: 0x10)
    class UObject* EditableMesh;                                                      // 0x0140 (size: 0x8)
    class UNavCollisionBase* NavCollision;                                            // 0x0148 (size: 0x8)

    void SetStaticMaterials(const TArray<FStaticMaterial>& InStaticMaterials);
    void RemoveSocket(class UStaticMeshSocket* Socket);
    TArray<FStaticMaterial> GetStaticMaterials();
    int32 GetNumSections(int32 InLOD);
    int32 GetNumLODs();
    void GetMinimumLODForPlatforms(TMap<FName, int32>& PlatformMinimumLODs);
    int32 GetMinimumLODForPlatform(const FName& PlatformName);
    int32 GetMaterialIndex(FName MaterialSlotName);
    class UMaterialInterface* GetMaterial(int32 MaterialIndex);
    FBoxSphereBounds GetBounds();
    FBox GetBoundingBox();
    class UStaticMeshSocket* FindSocket(FName InSocketName);
    class UStaticMeshDescription* CreateStaticMeshDescription(class UObject* Outer);
    void BuildFromStaticMeshDescriptions(const TArray<class UStaticMeshDescription*>& StaticMeshDescriptions, bool bBuildSimpleCollision);
    void AddSocket(class UStaticMeshSocket* Socket);
    FName AddMaterial(class UMaterialInterface* Material);
}; // Size: 0x150

class UStaticMeshSocket : public UObject
{
    FName SocketName;                                                                 // 0x0028 (size: 0x8)
    FVector RelativeLocation;                                                         // 0x0030 (size: 0xC)
    FRotator RelativeRotation;                                                        // 0x003C (size: 0xC)
    FVector RelativeScale;                                                            // 0x0048 (size: 0xC)
    FString Tag;                                                                      // 0x0058 (size: 0x10)

}; // Size: 0x68

class UStereoLayerShape : public UObject
{
}; // Size: 0x28

class UStereoLayerShapeQuad : public UStereoLayerShape
{
}; // Size: 0x28

class UStereoLayerShapeCylinder : public UStereoLayerShape
{
    float Radius;                                                                     // 0x0028 (size: 0x4)
    float OverlayArc;                                                                 // 0x002C (size: 0x4)
    int32 Height;                                                                     // 0x0030 (size: 0x4)

    void SetRadius(float InRadius);
    void SetOverlayArc(float InOverlayArc);
    void SetHeight(int32 InHeight);
}; // Size: 0x38

class UStereoLayerShapeCubemap : public UStereoLayerShape
{
}; // Size: 0x28

struct FEquirectProps
{
    FBox2D LeftUVRect;                                                                // 0x0000 (size: 0x14)
    FBox2D RightUVRect;                                                               // 0x0014 (size: 0x14)
    FVector2D LeftScale;                                                              // 0x0028 (size: 0x8)
    FVector2D RightScale;                                                             // 0x0030 (size: 0x8)
    FVector2D LeftBias;                                                               // 0x0038 (size: 0x8)
    FVector2D RightBias;                                                              // 0x0040 (size: 0x8)

}; // Size: 0x48

class UStereoLayerShapeEquirect : public UStereoLayerShape
{
    FBox2D LeftUVRect;                                                                // 0x0028 (size: 0x14)
    FBox2D RightUVRect;                                                               // 0x003C (size: 0x14)
    FVector2D LeftScale;                                                              // 0x0050 (size: 0x8)
    FVector2D RightScale;                                                             // 0x0058 (size: 0x8)
    FVector2D LeftBias;                                                               // 0x0060 (size: 0x8)
    FVector2D RightBias;                                                              // 0x0068 (size: 0x8)

    void SetEquirectProps(FEquirectProps InScaleBiases);
}; // Size: 0x70

class UStereoLayerComponent : public USceneComponent
{
    uint8 bLiveTexture;                                                               // 0x01F8 (size: 0x1)
    uint8 bSupportsDepth;                                                             // 0x01F8 (size: 0x1)
    uint8 bNoAlphaChannel;                                                            // 0x01F8 (size: 0x1)
    class UTexture* Texture;                                                          // 0x0200 (size: 0x8)
    class UTexture* LeftTexture;                                                      // 0x0208 (size: 0x8)
    uint8 bQuadPreserveTextureRatio;                                                  // 0x0210 (size: 0x1)
    FVector2D QuadSize;                                                               // 0x0214 (size: 0x8)
    FBox2D UVRect;                                                                    // 0x021C (size: 0x14)
    float CylinderRadius;                                                             // 0x0230 (size: 0x4)
    float CylinderOverlayArc;                                                         // 0x0234 (size: 0x4)
    int32 CylinderHeight;                                                             // 0x0238 (size: 0x4)
    FEquirectProps EquirectProps;                                                     // 0x023C (size: 0x48)
    TEnumAsByte<EStereoLayerType> StereoLayerType;                                    // 0x0284 (size: 0x1)
    TEnumAsByte<EStereoLayerShape> StereoLayerShape;                                  // 0x0285 (size: 0x1)
    class UStereoLayerShape* Shape;                                                   // 0x0288 (size: 0x8)
    int32 Priority;                                                                   // 0x0290 (size: 0x4)

    void SetUVRect(FBox2D InUVRect);
    void SetTexture(class UTexture* InTexture);
    void SetQuadSize(FVector2D InQuadSize);
    void SetPriority(int32 InPriority);
    void SetLeftTexture(class UTexture* InTexture);
    void SetEquirectProps(FEquirectProps InScaleBiases);
    void MarkTextureForUpdate();
    FBox2D GetUVRect();
    class UTexture* GetTexture();
    FVector2D GetQuadSize();
    int32 GetPriority();
    class UTexture* GetLeftTexture();
}; // Size: 0x2E0

class UStereoLayerFunctionLibrary : public UBlueprintFunctionLibrary
{

    void ShowSplashScreen();
    void SetSplashScreen(class UTexture* Texture, FVector2D Scale, FVector Offset, bool bShowLoadingMovie, bool bShowOnSet);
    void HideSplashScreen();
    void EnableAutoLoadingSplashScreen(bool InAutoShowEnabled);
}; // Size: 0x28

class UStringTable : public UObject
{
}; // Size: 0x40

struct FSubsurfaceProfileStruct
{
    FLinearColor SurfaceAlbedo;                                                       // 0x0000 (size: 0x10)
    FLinearColor MeanFreePathColor;                                                   // 0x0010 (size: 0x10)
    float MeanFreePathDistance;                                                       // 0x0020 (size: 0x4)
    float WorldUnitScale;                                                             // 0x0024 (size: 0x4)
    bool bEnableBurley;                                                               // 0x0028 (size: 0x1)
    float ScatterRadius;                                                              // 0x002C (size: 0x4)
    FLinearColor SubsurfaceColor;                                                     // 0x0030 (size: 0x10)
    FLinearColor FalloffColor;                                                        // 0x0040 (size: 0x10)
    FLinearColor BoundaryColorBleed;                                                  // 0x0050 (size: 0x10)
    float ExtinctionScale;                                                            // 0x0060 (size: 0x4)
    float NormalScale;                                                                // 0x0064 (size: 0x4)
    float ScatteringDistribution;                                                     // 0x0068 (size: 0x4)
    float IOR;                                                                        // 0x006C (size: 0x4)
    float Roughness0;                                                                 // 0x0070 (size: 0x4)
    float Roughness1;                                                                 // 0x0074 (size: 0x4)
    float LobeMix;                                                                    // 0x0078 (size: 0x4)
    FLinearColor TransmissionTintColor;                                               // 0x007C (size: 0x10)

}; // Size: 0x8C

class USubsurfaceProfile : public UObject
{
    FSubsurfaceProfileStruct Settings;                                                // 0x0028 (size: 0x8C)

}; // Size: 0xB8

class USubsystemBlueprintLibrary : public UBlueprintFunctionLibrary
{

    class UWorldSubsystem* GetWorldSubsystem(class UObject* ContextObject, TSubclassOf<class UWorldSubsystem> Class);
    class ULocalPlayerSubsystem* GetLocalPlayerSubSystemFromPlayerController(class APlayerController* PlayerController, TSubclassOf<class ULocalPlayerSubsystem> Class);
    class ULocalPlayerSubsystem* GetLocalPlayerSubsystem(class UObject* ContextObject, TSubclassOf<class ULocalPlayerSubsystem> Class);
    class UGameInstanceSubsystem* GetGameInstanceSubsystem(class UObject* ContextObject, TSubclassOf<class UGameInstanceSubsystem> Class);
    class UEngineSubsystem* GetEngineSubsystem(TSubclassOf<class UEngineSubsystem> Class);
}; // Size: 0x28

class USubUVAnimation : public UObject
{
    class UTexture2D* SubUVTexture;                                                   // 0x0028 (size: 0x8)
    int32 SubImages_Horizontal;                                                       // 0x0030 (size: 0x4)
    int32 SubImages_Vertical;                                                         // 0x0034 (size: 0x4)
    TEnumAsByte<ESubUVBoundingVertexCount> BoundingMode;                              // 0x0038 (size: 0x1)
    TEnumAsByte<EOpacitySourceMode> OpacitySourceMode;                                // 0x0039 (size: 0x1)
    float AlphaThreshold;                                                             // 0x003C (size: 0x4)

}; // Size: 0x68

class USystemTimeTimecodeProvider : public UTimecodeProvider
{
    FFrameRate FrameRate;                                                             // 0x0030 (size: 0x8)
    bool bGenerateFullFrame;                                                          // 0x0038 (size: 0x1)
    bool bUseHighPerformanceClock;                                                    // 0x0039 (size: 0x1)

}; // Size: 0x40

class ATargetPoint : public AActor
{
}; // Size: 0x228

class UTextPropertyTestObject : public UObject
{
    FText DefaultedText;                                                              // 0x0028 (size: 0x18)
    FText UndefaultedText;                                                            // 0x0040 (size: 0x18)
    FText TransientText;                                                              // 0x0058 (size: 0x18)

}; // Size: 0x70

class ATextRenderActor : public AActor
{
    class UTextRenderComponent* TextRender;                                           // 0x0228 (size: 0x8)

}; // Size: 0x230

class UTextRenderComponent : public UPrimitiveComponent
{
    FText Text;                                                                       // 0x0450 (size: 0x18)
    class UMaterialInterface* TextMaterial;                                           // 0x0468 (size: 0x8)
    class UFont* Font;                                                                // 0x0470 (size: 0x8)
    TEnumAsByte<EHorizTextAligment> HorizontalAlignment;                              // 0x0478 (size: 0x1)
    TEnumAsByte<EVerticalTextAligment> VerticalAlignment;                             // 0x0479 (size: 0x1)
    FColor TextRenderColor;                                                           // 0x047C (size: 0x4)
    float XScale;                                                                     // 0x0480 (size: 0x4)
    float YScale;                                                                     // 0x0484 (size: 0x4)
    float WorldSize;                                                                  // 0x0488 (size: 0x4)
    float InvDefaultSize;                                                             // 0x048C (size: 0x4)
    float HorizSpacingAdjust;                                                         // 0x0490 (size: 0x4)
    float VertSpacingAdjust;                                                          // 0x0494 (size: 0x4)
    uint8 bAlwaysRenderAsText;                                                        // 0x0498 (size: 0x1)

    void SetYScale(float Value);
    void SetXScale(float Value);
    void SetWorldSize(float Value);
    void SetVertSpacingAdjust(float Value);
    void SetVerticalAlignment(TEnumAsByte<EVerticalTextAligment> Value);
    void SetTextRenderColor(FColor Value);
    void SetTextMaterial(class UMaterialInterface* Material);
    void SetText(FString Value);
    void SetHorizSpacingAdjust(float Value);
    void SetHorizontalAlignment(TEnumAsByte<EHorizTextAligment> Value);
    void SetFont(class UFont* Value);
    void K2_SetText(const FText& Value);
    FVector GetTextWorldSize();
    FVector GetTextLocalSize();
}; // Size: 0x4A0

class UTexture2DArray : public UTexture
{
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x01D0 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x01D1 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressZ;                                             // 0x01D2 (size: 0x1)

}; // Size: 0x1E0

class UTexture2DDynamic : public UTexture
{
    TEnumAsByte<EPixelFormat> Format;                                                 // 0x0180 (size: 0x1)

}; // Size: 0x190

class UTextureLightProfile : public UTexture2D
{
    float Brightness;                                                                 // 0x01A0 (size: 0x4)
    float TextureMultiplier;                                                          // 0x01A4 (size: 0x4)

}; // Size: 0x1B0

class UTextureMipDataProviderFactory : public UAssetUserData
{
}; // Size: 0x28

class UTextureRenderTarget2DArray : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0180 (size: 0x4)
    int32 SizeY;                                                                      // 0x0184 (size: 0x4)
    int32 Slices;                                                                     // 0x0188 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x018C (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x019C (size: 0x1)
    uint8 bHDR;                                                                       // 0x019D (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x019D (size: 0x1)

}; // Size: 0x1A0

class UTextureRenderTargetCube : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0180 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x0184 (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x0194 (size: 0x1)
    uint8 bHDR;                                                                       // 0x0195 (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x0195 (size: 0x1)

}; // Size: 0x1A0

class UTextureRenderTargetVolume : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0180 (size: 0x4)
    int32 SizeY;                                                                      // 0x0184 (size: 0x4)
    int32 SizeZ;                                                                      // 0x0188 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x018C (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x019C (size: 0x1)
    uint8 bHDR;                                                                       // 0x019D (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x019D (size: 0x1)

}; // Size: 0x1A0

class UThumbnailInfo : public UObject
{
}; // Size: 0x28

struct FTimelineEventEntry
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FTimelineEventEntryEventFunc EventFunc;                                           // 0x0004 (size: 0x10)
    void OnTimelineEvent();

}; // Size: 0x14

struct FTimelineVectorTrack
{
    class UCurveVector* VectorCurve;                                                  // 0x0000 (size: 0x8)
    FTimelineVectorTrackInterpFunc InterpFunc;                                        // 0x0008 (size: 0x10)
    void OnTimelineVector(FVector Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName VectorPropertyName;                                                         // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimelineFloatTrack
{
    class UCurveFloat* FloatCurve;                                                    // 0x0000 (size: 0x8)
    FTimelineFloatTrackInterpFunc InterpFunc;                                         // 0x0008 (size: 0x10)
    void OnTimelineFloat(float Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName FloatPropertyName;                                                          // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimelineLinearColorTrack
{
    class UCurveLinearColor* LinearColorCurve;                                        // 0x0000 (size: 0x8)
    FTimelineLinearColorTrackInterpFunc InterpFunc;                                   // 0x0008 (size: 0x10)
    void OnTimelineLinearColor(FLinearColor Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName LinearColorPropertyName;                                                    // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimeline
{
    TEnumAsByte<ETimelineLengthMode> LengthMode;                                      // 0x0000 (size: 0x1)
    uint8 bLooping;                                                                   // 0x0001 (size: 0x1)
    uint8 bReversePlayback;                                                           // 0x0001 (size: 0x1)
    uint8 bPlaying;                                                                   // 0x0001 (size: 0x1)
    float Length;                                                                     // 0x0004 (size: 0x4)
    float PlayRate;                                                                   // 0x0008 (size: 0x4)
    float Position;                                                                   // 0x000C (size: 0x4)
    TArray<FTimelineEventEntry> Events;                                               // 0x0010 (size: 0x10)
    TArray<FTimelineVectorTrack> InterpVectors;                                       // 0x0020 (size: 0x10)
    TArray<FTimelineFloatTrack> InterpFloats;                                         // 0x0030 (size: 0x10)
    TArray<FTimelineLinearColorTrack> InterpLinearColors;                             // 0x0040 (size: 0x10)
    FTimelineTimelinePostUpdateFunc TimelinePostUpdateFunc;                           // 0x0050 (size: 0x10)
    void OnTimelineEvent();
    FTimelineTimelineFinishedFunc TimelineFinishedFunc;                               // 0x0060 (size: 0x10)
    void OnTimelineEvent();
    TWeakObjectPtr<class UObject> PropertySetObject;                                  // 0x0070 (size: 0x8)
    FName DirectionPropertyName;                                                      // 0x0078 (size: 0x8)

}; // Size: 0x98

class UTimelineComponent : public UActorComponent
{
    FTimeline TheTimeline;                                                            // 0x00B0 (size: 0x98)
    uint8 bIgnoreTimeDilation;                                                        // 0x0148 (size: 0x1)

    void Stop();
    void SetVectorCurve(class UCurveVector* NewVectorCurve, FName VectorTrackName);
    void SetTimelineLengthMode(TEnumAsByte<ETimelineLengthMode> NewLengthMode);
    void SetTimelineLength(float NewLength);
    void SetPlayRate(float NewRate);
    void SetPlaybackPosition(float newPosition, bool bFireEvents, bool bFireUpdate);
    void SetNewTime(float NewTime);
    void SetLooping(bool bNewLooping);
    void SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, FName LinearColorTrackName);
    void SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation);
    void SetFloatCurve(class UCurveFloat* NewFloatCurve, FName FloatTrackName);
    void ReverseFromEnd();
    void Reverse();
    void PlayFromStart();
    void Play();
    void OnRep_Timeline();
    bool IsReversing();
    bool IsPlaying();
    bool IsLooping();
    float GetTimelineLength();
    float GetPlayRate();
    float GetPlaybackPosition();
    bool GetIgnoreTimeDilation();
}; // Size: 0x150

struct FTTTrackBase
{
    FName TrackName;                                                                  // 0x0008 (size: 0x8)
    bool bIsExternalCurve;                                                            // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FTTEventTrack : public FTTTrackBase
{
    FName FunctionName;                                                               // 0x0018 (size: 0x8)
    class UCurveFloat* CurveKeys;                                                     // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTPropertyTrack : public FTTTrackBase
{
    FName PropertyName;                                                               // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FTTFloatTrack : public FTTPropertyTrack
{
    class UCurveFloat* CurveFloat;                                                    // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTVectorTrack : public FTTPropertyTrack
{
    class UCurveVector* CurveVector;                                                  // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTLinearColorTrack : public FTTPropertyTrack
{
    class UCurveLinearColor* CurveLinearColor;                                        // 0x0020 (size: 0x8)

}; // Size: 0x28

class UTimelineTemplate : public UObject
{
    float TimelineLength;                                                             // 0x0028 (size: 0x4)
    TEnumAsByte<ETimelineLengthMode> LengthMode;                                      // 0x002C (size: 0x1)
    uint8 bAutoPlay;                                                                  // 0x002D (size: 0x1)
    uint8 bLoop;                                                                      // 0x002D (size: 0x1)
    uint8 bReplicated;                                                                // 0x002D (size: 0x1)
    uint8 bIgnoreTimeDilation;                                                        // 0x002D (size: 0x1)
    TArray<FTTEventTrack> EventTracks;                                                // 0x0030 (size: 0x10)
    TArray<FTTFloatTrack> FloatTracks;                                                // 0x0040 (size: 0x10)
    TArray<FTTVectorTrack> VectorTracks;                                              // 0x0050 (size: 0x10)
    TArray<FTTLinearColorTrack> LinearColorTracks;                                    // 0x0060 (size: 0x10)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x0070 (size: 0x10)
    FGuid TimelineGuid;                                                               // 0x0080 (size: 0x10)
    TEnumAsByte<ETickingGroup> TimelineTickGroup;                                     // 0x0090 (size: 0x1)
    FName VariableName;                                                               // 0x0094 (size: 0x8)
    FName DirectionPropertyName;                                                      // 0x009C (size: 0x8)
    FName UpdateFunctionName;                                                         // 0x00A4 (size: 0x8)
    FName FinishedFunctionName;                                                       // 0x00AC (size: 0x8)

}; // Size: 0xB8

class UTireType : public UDataAsset
{
    float FrictionScale;                                                              // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FTouchInputControl
{
    class UTexture2D* Image1;                                                         // 0x0000 (size: 0x8)
    class UTexture2D* Image2;                                                         // 0x0008 (size: 0x8)
    FVector2D Center;                                                                 // 0x0010 (size: 0x8)
    FVector2D VisualSize;                                                             // 0x0018 (size: 0x8)
    FVector2D ThumbSize;                                                              // 0x0020 (size: 0x8)
    FVector2D InteractionSize;                                                        // 0x0028 (size: 0x8)
    FVector2D InputScale;                                                             // 0x0030 (size: 0x8)
    FKey MainInputKey;                                                                // 0x0038 (size: 0x18)
    FKey AltInputKey;                                                                 // 0x0050 (size: 0x18)

}; // Size: 0x68

class UTouchInterface : public UObject
{
    TArray<FTouchInputControl> Controls;                                              // 0x0028 (size: 0x10)
    float ActiveOpacity;                                                              // 0x0038 (size: 0x4)
    float InactiveOpacity;                                                            // 0x003C (size: 0x4)
    float TimeUntilDeactive;                                                          // 0x0040 (size: 0x4)
    float TimeUntilReset;                                                             // 0x0044 (size: 0x4)
    float ActivationDelay;                                                            // 0x0048 (size: 0x4)
    bool bPreventRecenter;                                                            // 0x004C (size: 0x1)
    float StartupDelay;                                                               // 0x0050 (size: 0x4)

}; // Size: 0x58

class ATriggerBase : public AActor
{
    class UShapeComponent* CollisionComponent;                                        // 0x0228 (size: 0x8)

}; // Size: 0x230

class ATriggerBox : public ATriggerBase
{
}; // Size: 0x230

class ATriggerCapsule : public ATriggerBase
{
}; // Size: 0x230

class ATriggerSphere : public ATriggerBase
{
}; // Size: 0x230

class ATriggerVolume : public AVolume
{
}; // Size: 0x260

class UTwitterIntegrationBase : public UPlatformInterfaceBase
{

    bool TwitterRequest(FString URL, const TArray<FString>& ParamKeysAndValues, TEnumAsByte<ETwitterRequestMethod> RequestMethod, int32 AccountIndex);
    bool ShowTweetUI(FString InitialMessage, FString URL, FString Picture);
    void Init();
    int32 GetNumAccounts();
    FString GetAccountName(int32 AccountIndex);
    bool CanShowTweetUI();
    bool AuthorizeAccounts();
}; // Size: 0x38

class UUserDefinedEnum : public UEnum
{
    TMap<class FName, class FText> DisplayNameMap;                                    // 0x0060 (size: 0x50)

}; // Size: 0xB0

class UUserDefinedStruct : public UScriptStruct
{
    TEnumAsByte<EUserDefinedStructureStatus> status;                                  // 0x00C0 (size: 0x1)
    FGuid Guid;                                                                       // 0x00C4 (size: 0x10)

}; // Size: 0x108

struct FHardwareCursorReference
{
    FName CursorPath;                                                                 // 0x0000 (size: 0x8)
    FVector2D HotSpot;                                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

class UUserInterfaceSettings : public UDeveloperSettings
{
    ERenderFocusRule RenderFocusRule;                                                 // 0x0038 (size: 0x1)
    TMap<TEnumAsByte<EMouseCursor::Type>, FHardwareCursorReference> HardwareCursors;  // 0x0040 (size: 0x50)
    TMap<TEnumAsByte<EMouseCursor::Type>, FSoftClassPath> SoftwareCursors;            // 0x0090 (size: 0x50)
    FSoftClassPath DefaultCursor;                                                     // 0x00E0 (size: 0x18)
    FSoftClassPath TextEditBeamCursor;                                                // 0x00F8 (size: 0x18)
    FSoftClassPath CrosshairsCursor;                                                  // 0x0110 (size: 0x18)
    FSoftClassPath HandCursor;                                                        // 0x0128 (size: 0x18)
    FSoftClassPath GrabHandCursor;                                                    // 0x0140 (size: 0x18)
    FSoftClassPath GrabHandClosedCursor;                                              // 0x0158 (size: 0x18)
    FSoftClassPath SlashedCircleCursor;                                               // 0x0170 (size: 0x18)
    float ApplicationScale;                                                           // 0x0188 (size: 0x4)
    EUIScalingRule UIScaleRule;                                                       // 0x018C (size: 0x1)
    FSoftClassPath CustomScalingRuleClass;                                            // 0x0190 (size: 0x18)
    FRuntimeFloatCurve UIScaleCurve;                                                  // 0x01A8 (size: 0x88)
    bool bAllowHighDPIInGameMode;                                                     // 0x0230 (size: 0x1)
    FIntPoint DesignScreenSize;                                                       // 0x0234 (size: 0x8)
    bool bLoadWidgetsOnDedicatedServer;                                               // 0x023C (size: 0x1)
    TArray<class UObject*> CursorClasses;                                             // 0x0240 (size: 0x10)
    UClass* CustomScalingRuleClassInstance;                                           // 0x0250 (size: 0x8)
    class UDPICustomScalingRule* CustomScalingRule;                                   // 0x0258 (size: 0x8)

}; // Size: 0x270

class UVectorField : public UObject
{
    FBox Bounds;                                                                      // 0x0028 (size: 0x1C)
    float Intensity;                                                                  // 0x0044 (size: 0x4)

}; // Size: 0x48

class UVectorFieldAnimated : public UVectorField
{
    class UTexture2D* Texture;                                                        // 0x0048 (size: 0x8)
    TEnumAsByte<EVectorFieldConstructionOp> ConstructionOp;                           // 0x0050 (size: 0x1)
    int32 VolumeSizeX;                                                                // 0x0054 (size: 0x4)
    int32 VolumeSizeY;                                                                // 0x0058 (size: 0x4)
    int32 VolumeSizeZ;                                                                // 0x005C (size: 0x4)
    int32 SubImagesX;                                                                 // 0x0060 (size: 0x4)
    int32 SubImagesY;                                                                 // 0x0064 (size: 0x4)
    int32 FrameCount;                                                                 // 0x0068 (size: 0x4)
    float FramesPerSecond;                                                            // 0x006C (size: 0x4)
    uint8 bLoop;                                                                      // 0x0070 (size: 0x1)
    class UVectorFieldStatic* NoiseField;                                             // 0x0078 (size: 0x8)
    float NoiseScale;                                                                 // 0x0080 (size: 0x4)
    float NoiseMax;                                                                   // 0x0084 (size: 0x4)

}; // Size: 0x88

class UVectorFieldComponent : public UPrimitiveComponent
{
    class UVectorField* VectorField;                                                  // 0x0450 (size: 0x8)
    float Intensity;                                                                  // 0x0458 (size: 0x4)
    float Tightness;                                                                  // 0x045C (size: 0x4)
    uint8 bPreviewVectorField;                                                        // 0x0460 (size: 0x1)

    void SetIntensity(float NewIntensity);
}; // Size: 0x480

class UVectorFieldStatic : public UVectorField
{
    int32 SizeX;                                                                      // 0x0048 (size: 0x4)
    int32 SizeY;                                                                      // 0x004C (size: 0x4)
    int32 SizeZ;                                                                      // 0x0050 (size: 0x4)
    bool bAllowCPUAccess;                                                             // 0x0054 (size: 0x1)

}; // Size: 0x98

class AVectorFieldVolume : public AActor
{
    class UVectorFieldComponent* VectorFieldComponent;                                // 0x0228 (size: 0x8)

}; // Size: 0x230

class UViewportStatsSubsystem : public UWorldSubsystem
{

    void RemoveDisplayDelegate(const int32 IndexToRemove);
    void AddTimedDisplay(FText Text, FLinearColor Color, float Duration);
    int32 AddDisplayDelegate(const FAddDisplayDelegateDelegate& Delegate);
}; // Size: 0x50

class UVirtualTexture : public UObject
{
}; // Size: 0x28

class ULightMapVirtualTexture : public UVirtualTexture
{
}; // Size: 0x28

class URuntimeVirtualTextureStreamingProxy : public UTexture2D
{
}; // Size: 0x1A0

struct FVirtualTextureBuildSettings
{
    int32 TileSize;                                                                   // 0x0000 (size: 0x4)
    int32 TileBorderSize;                                                             // 0x0004 (size: 0x4)
    bool bEnableCompressCrunch;                                                       // 0x0008 (size: 0x1)
    bool bEnableCompressZlib;                                                         // 0x0009 (size: 0x1)

}; // Size: 0xC

class UVirtualTexture2D : public UTexture2D
{
    FVirtualTextureBuildSettings Settings;                                            // 0x01A0 (size: 0xC)
    bool bContinuousUpdate;                                                           // 0x01AC (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x01AD (size: 0x1)

}; // Size: 0x1B0

class UVirtualTextureBuilder : public UObject
{
    class UVirtualTexture2D* Texture;                                                 // 0x0028 (size: 0x8)
    uint64 BuildHash;                                                                 // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FVirtualTextureSpacePoolConfig
{
    int32 MinTileSize;                                                                // 0x0000 (size: 0x4)
    int32 MaxTileSize;                                                                // 0x0004 (size: 0x4)
    TArray<TEnumAsByte<EPixelFormat>> Formats;                                        // 0x0008 (size: 0x10)
    int32 SizeInMegabyte;                                                             // 0x0018 (size: 0x4)
    bool bAllowSizeScale;                                                             // 0x001C (size: 0x1)
    uint32 ScalabilityGroup;                                                          // 0x0020 (size: 0x4)

}; // Size: 0x28

class UVirtualTexturePoolConfig : public UObject
{
    int32 DefaultSizeInMegabyte;                                                      // 0x0028 (size: 0x4)
    TArray<FVirtualTextureSpacePoolConfig> Pools;                                     // 0x0030 (size: 0x10)

}; // Size: 0x40

class UVisualLoggerAutomationTests : public UObject
{
}; // Size: 0x28

class IVisualLoggerDebugSnapshotInterface : public IInterface
{
}; // Size: 0x28

class UVisualLoggerKismetLibrary : public UBlueprintFunctionLibrary
{

    void RedirectVislog(class UObject* SourceOwner, class UObject* DestinationOwner);
    void LogText(class UObject* WorldContextObject, FString Text, FName LogCategory, bool bAddToMessageLog);
    void LogSegment(class UObject* WorldContextObject, const FVector SegmentStart, const FVector SegmentEnd, FString Text, FLinearColor ObjectColor, const float Thickness, FName CategoryName, bool bAddToMessageLog);
    void LogLocation(class UObject* WorldContextObject, FVector Location, FString Text, FLinearColor ObjectColor, float Radius, FName LogCategory, bool bAddToMessageLog);
    void LogBox(class UObject* WorldContextObject, FBox BoxShape, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog);
    void EnableRecording(bool bEnabled);
}; // Size: 0x28

class UVoiceChannel : public UChannel
{
}; // Size: 0x78

struct FVoiceSettings
{
    class USceneComponent* ComponentToAttachTo;                                       // 0x0000 (size: 0x8)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0008 (size: 0x8)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0010 (size: 0x8)

}; // Size: 0x18

class UVOIPTalker : public UActorComponent
{
    FVoiceSettings Settings;                                                          // 0x00B0 (size: 0x18)

    void RegisterWithPlayerState(class APlayerState* OwningState);
    float GetVoiceLevel();
    class UVOIPTalker* CreateTalkerForPlayer(class APlayerState* OwningState);
    void BPOnTalkingEnd();
    void BPOnTalkingBegin(class UAudioComponent* AudioComponent);
}; // Size: 0xE8

class UVOIPStatics : public UBlueprintFunctionLibrary
{

    void SetMicThreshold(float InThreshold);
}; // Size: 0x28

class UVolumeTexture : public UTexture
{
}; // Size: 0x1D0

class UVolumetricCloudComponent : public USceneComponent
{
    float LayerBottomAltitude;                                                        // 0x01F8 (size: 0x4)
    float LayerHeight;                                                                // 0x01FC (size: 0x4)
    float TracingStartMaxDistance;                                                    // 0x0200 (size: 0x4)
    float TracingMaxDistance;                                                         // 0x0204 (size: 0x4)
    float PlanetRadius;                                                               // 0x0208 (size: 0x4)
    FColor GroundAlbedo;                                                              // 0x020C (size: 0x4)
    class UMaterialInterface* Material;                                               // 0x0210 (size: 0x8)
    uint8 bUsePerSampleAtmosphericLightTransmittance;                                 // 0x0218 (size: 0x1)
    float SkyLightCloudBottomOcclusion;                                               // 0x021C (size: 0x4)
    float ViewSampleCountScale;                                                       // 0x0220 (size: 0x4)
    float ReflectionSampleCountScale;                                                 // 0x0224 (size: 0x4)
    float ShadowViewSampleCountScale;                                                 // 0x0228 (size: 0x4)
    float ShadowReflectionSampleCountScale;                                           // 0x022C (size: 0x4)
    float ShadowTracingDistance;                                                      // 0x0230 (size: 0x4)
    float StopTracingTransmittanceThreshold;                                          // 0x0234 (size: 0x4)

    void SetViewSampleCountScale(float newValue);
    void SetTracingStartMaxDistance(float newValue);
    void SetTracingMaxDistance(float newValue);
    void SetStopTracingTransmittanceThreshold(float newValue);
    void SetSkyLightCloudBottomOcclusion(float newValue);
    void SetShadowViewSampleCountScale(float newValue);
    void SetShadowTracingDistance(float newValue);
    void SetShadowReflectionSampleCountScale(float newValue);
    void SetReflectionSampleCountScale(float newValue);
    void SetPlanetRadius(float newValue);
    void SetMaterial(class UMaterialInterface* newValue);
    void SetLayerHeight(float newValue);
    void SetLayerBottomAltitude(float newValue);
    void SetGroundAlbedo(FColor newValue);
    void SetbUsePerSampleAtmosphericLightTransmittance(bool newValue);
}; // Size: 0x240

class AVolumetricCloud : public AInfo
{
    class UVolumetricCloudComponent* VolumetricCloudComponent;                        // 0x0228 (size: 0x8)

}; // Size: 0x230

class AVolumetricLightmapDensityVolume : public AVolume
{
    FInt32Interval AllowedMipLevelRange;                                              // 0x0260 (size: 0x8)

}; // Size: 0x268

class AWindDirectionalSource : public AInfo
{
    class UWindDirectionalSourceComponent* Component;                                 // 0x0228 (size: 0x8)

}; // Size: 0x230

class UWindDirectionalSourceComponent : public USceneComponent
{
    float Strength;                                                                   // 0x01F8 (size: 0x4)
    float Speed;                                                                      // 0x01FC (size: 0x4)
    float MinGustAmount;                                                              // 0x0200 (size: 0x4)
    float MaxGustAmount;                                                              // 0x0204 (size: 0x4)
    float Radius;                                                                     // 0x0208 (size: 0x4)
    uint8 bPointWind;                                                                 // 0x020C (size: 0x1)

    void SetWindType(EWindSourceType InNewType);
    void SetStrength(float InNewStrength);
    void SetSpeed(float InNewSpeed);
    void SetRadius(float InNewRadius);
    void SetMinimumGustAmount(float InNewMinGust);
    void SetMaximumGustAmount(float InNewMaxGust);
}; // Size: 0x220

class UWorldComposition : public UObject
{
    TArray<class ULevelStreaming*> TilesStreaming;                                    // 0x0048 (size: 0x10)
    double TilesStreamingTimeThreshold;                                               // 0x0058 (size: 0x8)
    bool bLoadAllTilesDuringCinematic;                                                // 0x0060 (size: 0x1)
    bool bRebaseOriginIn3DSpace;                                                      // 0x0061 (size: 0x1)
    float RebaseOriginDistance;                                                       // 0x0064 (size: 0x4)

}; // Size: 0x68

struct FMaterialProxySettings
{
    FIntPoint TextureSize;                                                            // 0x0000 (size: 0x8)
    float GutterSpace;                                                                // 0x0008 (size: 0x4)
    float MetallicConstant;                                                           // 0x000C (size: 0x4)
    float RoughnessConstant;                                                          // 0x0010 (size: 0x4)
    float AnisotropyConstant;                                                         // 0x0014 (size: 0x4)
    float SpecularConstant;                                                           // 0x0018 (size: 0x4)
    float OpacityConstant;                                                            // 0x001C (size: 0x4)
    float OpacityMaskConstant;                                                        // 0x0020 (size: 0x4)
    float AmbientOcclusionConstant;                                                   // 0x0024 (size: 0x4)
    TEnumAsByte<ETextureSizingType> TextureSizingType;                                // 0x0028 (size: 0x1)
    TEnumAsByte<EMaterialMergeType> MaterialMergeType;                                // 0x0029 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x002A (size: 0x1)
    uint8 bAllowTwoSidedMaterial;                                                     // 0x002B (size: 0x1)
    uint8 bNormalMap;                                                                 // 0x002B (size: 0x1)
    uint8 bTangentMap;                                                                // 0x002B (size: 0x1)
    uint8 bMetallicMap;                                                               // 0x002B (size: 0x1)
    uint8 bRoughnessMap;                                                              // 0x002B (size: 0x1)
    uint8 bAnisotropyMap;                                                             // 0x002B (size: 0x1)
    uint8 bSpecularMap;                                                               // 0x002B (size: 0x1)
    uint8 bEmissiveMap;                                                               // 0x002B (size: 0x1)
    uint8 bOpacityMap;                                                                // 0x002C (size: 0x1)
    uint8 bOpacityMaskMap;                                                            // 0x002C (size: 0x1)
    uint8 bAmbientOcclusionMap;                                                       // 0x002C (size: 0x1)
    FIntPoint DiffuseTextureSize;                                                     // 0x0030 (size: 0x8)
    FIntPoint NormalTextureSize;                                                      // 0x0038 (size: 0x8)
    FIntPoint TangentTextureSize;                                                     // 0x0040 (size: 0x8)
    FIntPoint MetallicTextureSize;                                                    // 0x0048 (size: 0x8)
    FIntPoint RoughnessTextureSize;                                                   // 0x0050 (size: 0x8)
    FIntPoint AnisotropyTextureSize;                                                  // 0x0058 (size: 0x8)
    FIntPoint SpecularTextureSize;                                                    // 0x0060 (size: 0x8)
    FIntPoint EmissiveTextureSize;                                                    // 0x0068 (size: 0x8)
    FIntPoint OpacityTextureSize;                                                     // 0x0070 (size: 0x8)
    FIntPoint OpacityMaskTextureSize;                                                 // 0x0078 (size: 0x8)
    FIntPoint AmbientOcclusionTextureSize;                                            // 0x0080 (size: 0x8)

}; // Size: 0x88

struct FMeshProxySettings
{
    int32 ScreenSize;                                                                 // 0x0000 (size: 0x4)
    float VoxelSize;                                                                  // 0x0004 (size: 0x4)
    FMaterialProxySettings MaterialSettings;                                          // 0x0008 (size: 0x88)
    float MergeDistance;                                                              // 0x0090 (size: 0x4)
    FColor UnresolvedGeometryColor;                                                   // 0x0094 (size: 0x4)
    float MaxRayCastDist;                                                             // 0x0098 (size: 0x4)
    float HardAngleThreshold;                                                         // 0x009C (size: 0x4)
    int32 LightMapResolution;                                                         // 0x00A0 (size: 0x4)
    TEnumAsByte<EProxyNormalComputationMethod::Type> NormalCalculationMethod;         // 0x00A4 (size: 0x1)
    TEnumAsByte<ELandscapeCullingPrecision::Type> LandscapeCullingPrecision;          // 0x00A5 (size: 0x1)
    uint8 bCalculateCorrectLODModel;                                                  // 0x00A6 (size: 0x1)
    uint8 bOverrideVoxelSize;                                                         // 0x00A6 (size: 0x1)
    uint8 bOverrideTransferDistance;                                                  // 0x00A6 (size: 0x1)
    uint8 bUseHardAngleThreshold;                                                     // 0x00A6 (size: 0x1)
    uint8 bComputeLightMapResolution;                                                 // 0x00A6 (size: 0x1)
    uint8 bRecalculateNormals;                                                        // 0x00A6 (size: 0x1)
    uint8 bUseLandscapeCulling;                                                       // 0x00A6 (size: 0x1)
    uint8 bAllowAdjacency;                                                            // 0x00A6 (size: 0x1)
    uint8 bAllowDistanceField;                                                        // 0x00A7 (size: 0x1)
    uint8 bReuseMeshLightmapUVs;                                                      // 0x00A7 (size: 0x1)
    uint8 bCreateCollision;                                                           // 0x00A7 (size: 0x1)
    uint8 bAllowVertexColors;                                                         // 0x00A7 (size: 0x1)
    uint8 bGenerateLightmapUVs;                                                       // 0x00A7 (size: 0x1)

}; // Size: 0xA8

struct FMeshMergingSettings
{
    int32 TargetLightMapResolution;                                                   // 0x0000 (size: 0x4)
    EUVOutput OutputUVs;                                                              // 0x0004 (size: 0x8)
    FMaterialProxySettings MaterialSettings;                                          // 0x000C (size: 0x88)
    int32 GutterSize;                                                                 // 0x0094 (size: 0x4)
    int32 SpecificLOD;                                                                // 0x0098 (size: 0x4)
    EMeshLODSelectionType LODSelectionType;                                           // 0x009C (size: 0x1)
    uint8 bGenerateLightMapUV;                                                        // 0x009D (size: 0x1)
    uint8 bComputedLightMapResolution;                                                // 0x009D (size: 0x1)
    uint8 bPivotPointAtZero;                                                          // 0x009D (size: 0x1)
    uint8 bMergePhysicsData;                                                          // 0x009D (size: 0x1)
    uint8 bMergeMaterials;                                                            // 0x009D (size: 0x1)
    uint8 bCreateMergedMaterial;                                                      // 0x009D (size: 0x1)
    uint8 bBakeVertexDataToMesh;                                                      // 0x009D (size: 0x1)
    uint8 bUseVertexDataForBakingMaterial;                                            // 0x009D (size: 0x1)
    uint8 bUseTextureBinning;                                                         // 0x009E (size: 0x1)
    uint8 bReuseMeshLightmapUVs;                                                      // 0x009E (size: 0x1)
    uint8 bMergeEquivalentMaterials;                                                  // 0x009E (size: 0x1)
    uint8 bUseLandscapeCulling;                                                       // 0x009E (size: 0x1)
    uint8 bIncludeImposters;                                                          // 0x009E (size: 0x1)
    uint8 bAllowDistanceField;                                                        // 0x009E (size: 0x1)

}; // Size: 0xA0

struct FHierarchicalSimplification
{
    float TransitionScreenSize;                                                       // 0x0000 (size: 0x4)
    float OverrideDrawDistance;                                                       // 0x0004 (size: 0x4)
    uint8 bUseOverrideDrawDistance;                                                   // 0x0008 (size: 0x1)
    uint8 bAllowSpecificExclusion;                                                    // 0x0008 (size: 0x1)
    uint8 bSimplifyMesh;                                                              // 0x0008 (size: 0x1)
    uint8 bOnlyGenerateClustersForVolumes;                                            // 0x0008 (size: 0x1)
    uint8 bReusePreviousLevelClusters;                                                // 0x0008 (size: 0x1)
    FMeshProxySettings ProxySetting;                                                  // 0x000C (size: 0xA8)
    FMeshMergingSettings MergeSetting;                                                // 0x00B4 (size: 0xA0)
    float DesiredBoundRadius;                                                         // 0x0154 (size: 0x4)
    float DesiredFillingPercentage;                                                   // 0x0158 (size: 0x4)
    int32 MinNumberOfActorsToBuild;                                                   // 0x015C (size: 0x4)

}; // Size: 0x160

class UHierarchicalLODSetup : public UObject
{
    TArray<FHierarchicalSimplification> HierarchicalLODSetup;                         // 0x0028 (size: 0x10)
    TSoftObjectPtr<UMaterialInterface> OverrideBaseMaterial;                          // 0x0038 (size: 0x28)

}; // Size: 0x60

struct FNavDataConfig : public FNavAgentProperties
{
    FName Name;                                                                       // 0x0030 (size: 0x8)
    FColor Color;                                                                     // 0x0038 (size: 0x4)
    FVector DefaultQueryExtent;                                                       // 0x003C (size: 0xC)
    TSubclassOf<class AActor> NavigationDataClass;                                    // 0x0048 (size: 0x8)
    TSoftClassPtr<AActor> NavDataClass;                                               // 0x0050 (size: 0x28)

}; // Size: 0x78

struct FVectorDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FVector4Distribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FFloatRK4SpringInterpolator
{
    float StiffnessConstant;                                                          // 0x0000 (size: 0x4)
    float DampeningRatio;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FVectorRK4SpringInterpolator
{
    float StiffnessConstant;                                                          // 0x0000 (size: 0x4)
    float DampeningRatio;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FExpressionOutput
{
    FName OutputName;                                                                 // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FVector2MaterialInput : public FMaterialInput
{
}; // Size: 0x14

struct FPlatformInterfaceData
{
    FName DataName;                                                                   // 0x0000 (size: 0x8)
    TEnumAsByte<EPlatformInterfaceDataType> Type;                                     // 0x0008 (size: 0x1)
    int32 IntValue;                                                                   // 0x000C (size: 0x4)
    float FloatValue;                                                                 // 0x0010 (size: 0x4)
    FString StringValue;                                                              // 0x0018 (size: 0x10)
    class UObject* ObjectValue;                                                       // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FPlatformInterfaceDelegateResult
{
    bool bSuccessful;                                                                 // 0x0000 (size: 0x1)
    FPlatformInterfaceData Data;                                                      // 0x0008 (size: 0x30)

}; // Size: 0x38

struct FActorComponentDuplicatedObjectData
{
}; // Size: 0x10

struct FActorComponentInstanceData
{
    class UObject* SourceComponentTemplate;                                           // 0x0008 (size: 0x8)
    EComponentCreationMethod SourceComponentCreationMethod;                           // 0x0010 (size: 0x1)
    int32 SourceComponentTypeSerializedIndex;                                         // 0x0014 (size: 0x4)
    TArray<uint8> SavedProperties;                                                    // 0x0018 (size: 0x10)
    FActorComponentDuplicatedObjectData UniqueTransientPackage;                       // 0x0028 (size: 0x10)
    TArray<FActorComponentDuplicatedObjectData> DuplicatedObjects;                    // 0x0038 (size: 0x10)
    TArray<class UObject*> ReferencedObjects;                                         // 0x0048 (size: 0x10)
    TArray<FName> ReferencedNames;                                                    // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FAnimNode_Base
{
}; // Size: 0x10

struct FPoseLinkBase
{
    int32 LinkID;                                                                     // 0x0000 (size: 0x4)

}; // Size: 0x10

struct FPoseLink : public FPoseLinkBase
{
}; // Size: 0x10

struct FAnimInstanceProxy
{
}; // Size: 0x770

struct FComponentSpacePoseLink : public FPoseLinkBase
{
}; // Size: 0x10

struct FInputScaleBias
{
    float Scale;                                                                      // 0x0000 (size: 0x4)
    float Bias;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FInputAlphaBoolBlend
{
    float blendInTime;                                                                // 0x0000 (size: 0x4)
    float blendOutTime;                                                               // 0x0004 (size: 0x4)
    EAlphaBlendOption BlendOption;                                                    // 0x0008 (size: 0x1)
    bool bInitialized;                                                                // 0x0009 (size: 0x1)
    class UCurveFloat* CustomCurve;                                                   // 0x0010 (size: 0x8)
    FAlphaBlend AlphaBlend;                                                           // 0x0018 (size: 0x30)

}; // Size: 0x48

struct FInputRange
{
    float Min;                                                                        // 0x0000 (size: 0x4)
    float Max;                                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FInputScaleBiasClamp
{
    bool bMapRange;                                                                   // 0x0000 (size: 0x1)
    bool bClampResult;                                                                // 0x0001 (size: 0x1)
    bool bInterpResult;                                                               // 0x0002 (size: 0x1)
    FInputRange InRange;                                                              // 0x0004 (size: 0x8)
    FInputRange OutRange;                                                             // 0x000C (size: 0x8)
    float Scale;                                                                      // 0x0014 (size: 0x4)
    float Bias;                                                                       // 0x0018 (size: 0x4)
    float ClampMin;                                                                   // 0x001C (size: 0x4)
    float ClampMax;                                                                   // 0x0020 (size: 0x4)
    float InterpSpeedIncreasing;                                                      // 0x0024 (size: 0x4)
    float InterpSpeedDecreasing;                                                      // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FAnimNode_AssetPlayerBase : public FAnimNode_Base
{
    FName GroupName;                                                                  // 0x0010 (size: 0x8)
    TEnumAsByte<EAnimGroupRole::Type> GroupRole;                                      // 0x0018 (size: 0x1)
    EAnimSyncGroupScope GroupScope;                                                   // 0x0019 (size: 0x1)
    bool bIgnoreForRelevancyTest;                                                     // 0x001A (size: 0x1)
    float BlendWeight;                                                                // 0x001C (size: 0x4)
    float InternalTimeAccumulator;                                                    // 0x0020 (size: 0x4)

}; // Size: 0x38

struct FPerBoneBlendWeight
{
    int32 SourceIndex;                                                                // 0x0000 (size: 0x4)
    float BlendWeight;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FAnimNode_Root : public FAnimNode_Base
{
    FPoseLink Result;                                                                 // 0x0010 (size: 0x10)
    FName Name;                                                                       // 0x0020 (size: 0x8)
    FName Group;                                                                      // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FAnimCurveParam
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FSceneComponentInstanceData : public FActorComponentInstanceData
{
    TMap<class USceneComponent*, class FTransform> AttachedInstanceComponents;        // 0x0068 (size: 0x50)

}; // Size: 0xB8

struct FAnimationGroupReference
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    TEnumAsByte<EAnimGroupRole::Type> GroupRole;                                      // 0x0008 (size: 0x1)
    EAnimSyncGroupScope GroupScope;                                                   // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FAnimGroupInstance
{
}; // Size: 0x70

struct FAnimTickRecord
{
    class UAnimationAsset* SourceAsset;                                               // 0x0000 (size: 0x8)

}; // Size: 0x48

struct FBlendFilter
{
}; // Size: 0x78

struct FBlendSampleData
{
    int32 SampleDataIndex;                                                            // 0x0000 (size: 0x4)
    class UAnimSequence* Animation;                                                   // 0x0008 (size: 0x8)
    float TotalWeight;                                                                // 0x0010 (size: 0x4)
    float Time;                                                                       // 0x0014 (size: 0x4)
    float PreviousTime;                                                               // 0x0018 (size: 0x4)
    float SamplePlayRate;                                                             // 0x001C (size: 0x4)

}; // Size: 0x40

struct FAnimationRecordingSettings
{
    bool bRecordInWorldSpace;                                                         // 0x0000 (size: 0x1)
    bool bRemoveRootAnimation;                                                        // 0x0001 (size: 0x1)
    bool bAutoSaveAsset;                                                              // 0x0002 (size: 0x1)
    float SampleRate;                                                                 // 0x0004 (size: 0x4)
    float Length;                                                                     // 0x0008 (size: 0x4)
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x000C (size: 0x1)
    TEnumAsByte<ERichCurveTangentMode> TangentMode;                                   // 0x000D (size: 0x1)
    bool bRecordTransforms;                                                           // 0x000F (size: 0x1)
    bool bRecordCurves;                                                               // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FComponentSpacePose
{
    TArray<FTransform> Transforms;                                                    // 0x0000 (size: 0x10)
    TArray<FName> Names;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FLocalSpacePose
{
    TArray<FTransform> Transforms;                                                    // 0x0000 (size: 0x10)
    TArray<FName> Names;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FNamedTransform
{
    FTransform Value;                                                                 // 0x0000 (size: 0x30)
    FName Name;                                                                       // 0x0030 (size: 0x8)

}; // Size: 0x40

struct FNamedColor
{
    FColor Value;                                                                     // 0x0000 (size: 0x4)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FNamedVector
{
    FVector Value;                                                                    // 0x0000 (size: 0xC)
    FName Name;                                                                       // 0x000C (size: 0x8)

}; // Size: 0x14

struct FNamedFloat
{
    float Value;                                                                      // 0x0000 (size: 0x4)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FAnimParentNodeAssetOverride
{
    class UAnimationAsset* NewAsset;                                                  // 0x0000 (size: 0x8)
    FGuid ParentNodeGuid;                                                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAnimBlueprintDebugData
{
}; // Size: 0x1

struct FAnimationFrameSnapshot
{
}; // Size: 0x1

struct FStateMachineDebugData
{
}; // Size: 0xB0

struct FStateMachineStateDebugData
{
}; // Size: 0x10

struct FRootMotionExtractionStep
{
    class UAnimSequence* AnimSequence;                                                // 0x0000 (size: 0x8)
    float StartPosition;                                                              // 0x0008 (size: 0x4)
    float EndPosition;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FAnimationErrorStats
{
}; // Size: 0x10

struct FVectorCurve : public FAnimCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0018 (size: 0x180)

}; // Size: 0x198

struct FTransformCurve : public FAnimCurveBase
{
    FVectorCurve TranslationCurve;                                                    // 0x0018 (size: 0x198)
    FVectorCurve RotationCurve;                                                       // 0x01B0 (size: 0x198)
    FVectorCurve ScaleCurve;                                                          // 0x0348 (size: 0x198)

}; // Size: 0x4E0

struct FSlotEvaluationPose
{
    TEnumAsByte<EAdditiveAnimationType> AdditiveType;                                 // 0x0000 (size: 0x1)
    float Weight;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0xE0

struct FA2Pose
{
    TArray<FTransform> Bones;                                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FA2CSPose : public FA2Pose
{
    TArray<uint8> ComponentSpaceFlags;                                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FQueuedDrawDebugItem
{
    TEnumAsByte<EDrawDebugItemType::Type> ItemType;                                   // 0x0000 (size: 0x1)
    FVector StartLoc;                                                                 // 0x0004 (size: 0xC)
    FVector EndLoc;                                                                   // 0x0010 (size: 0xC)
    FVector Center;                                                                   // 0x001C (size: 0xC)
    FRotator Rotation;                                                                // 0x0028 (size: 0xC)
    float Radius;                                                                     // 0x0034 (size: 0x4)
    float Size;                                                                       // 0x0038 (size: 0x4)
    int32 Segments;                                                                   // 0x003C (size: 0x4)
    FColor Color;                                                                     // 0x0040 (size: 0x4)
    bool bPersistentLines;                                                            // 0x0044 (size: 0x1)
    float LifeTime;                                                                   // 0x0048 (size: 0x4)
    float Thickness;                                                                  // 0x004C (size: 0x4)
    FString Message;                                                                  // 0x0050 (size: 0x10)
    FVector2D TextScale;                                                              // 0x0060 (size: 0x8)

}; // Size: 0x68

struct FAnimInstanceSubsystemData
{
}; // Size: 0x1

struct FAnimMontageInstance
{
    class UAnimMontage* Montage;                                                      // 0x0000 (size: 0x8)
    bool bPlaying;                                                                    // 0x0028 (size: 0x1)
    float DefaultBlendTimeMultiplier;                                                 // 0x002C (size: 0x4)
    TArray<int32> NextSections;                                                       // 0x00E8 (size: 0x10)
    TArray<int32> PrevSections;                                                       // 0x00F8 (size: 0x10)
    TArray<FAnimNotifyEvent> ActiveStateBranchingPoints;                              // 0x0118 (size: 0x10)
    float Position;                                                                   // 0x0128 (size: 0x4)
    float PlayRate;                                                                   // 0x012C (size: 0x4)
    FAlphaBlend Blend;                                                                // 0x0130 (size: 0x30)
    int32 DisableRootMotionCount;                                                     // 0x018C (size: 0x4)

}; // Size: 0x1B0

struct FAnimNode_ApplyMeshSpaceAdditive : public FAnimNode_Base
{
    FPoseLink Base;                                                                   // 0x0010 (size: 0x10)
    FPoseLink Additive;                                                               // 0x0020 (size: 0x10)
    EAnimAlphaInputType AlphaInputType;                                               // 0x0030 (size: 0x1)
    float Alpha;                                                                      // 0x0034 (size: 0x4)
    uint8 bAlphaBoolEnabled;                                                          // 0x0038 (size: 0x1)
    FInputAlphaBoolBlend AlphaBoolBlend;                                              // 0x0040 (size: 0x48)
    FName AlphaCurveName;                                                             // 0x0088 (size: 0x8)
    FInputScaleBias AlphaScaleBias;                                                   // 0x0090 (size: 0x8)
    FInputScaleBiasClamp AlphaScaleBiasClamp;                                         // 0x0098 (size: 0x30)
    int32 LODThreshold;                                                               // 0x00C8 (size: 0x4)

}; // Size: 0xD0

struct FAnimNode_CustomProperty : public FAnimNode_Base
{
    TArray<FName> SourcePropertyNames;                                                // 0x0010 (size: 0x10)
    TArray<FName> DestPropertyNames;                                                  // 0x0020 (size: 0x10)
    class UObject* TargetInstance;                                                    // 0x0030 (size: 0x8)

}; // Size: 0x58

struct FAnimNode_Inertialization : public FAnimNode_Base
{
    FPoseLink Source;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x70

struct FInertializationPoseDiff
{
}; // Size: 0x28

struct FInertializationCurveDiff
{
}; // Size: 0x8

struct FInertializationBoneDiff
{
}; // Size: 0x3C

struct FInertializationPose
{
}; // Size: 0xA0

struct FAnimNode_LinkedAnimGraph : public FAnimNode_CustomProperty
{
    TArray<FPoseLink> InputPoses;                                                     // 0x0058 (size: 0x10)
    TArray<FName> InputPoseNames;                                                     // 0x0068 (size: 0x10)
    TSubclassOf<class UAnimInstance> InstanceClass;                                   // 0x0078 (size: 0x8)
    FName Tag;                                                                        // 0x0080 (size: 0x8)
    uint8 bReceiveNotifiesFromLinkedInstances;                                        // 0x009C (size: 0x1)
    uint8 bPropagateNotifiesToLinkedInstances;                                        // 0x009C (size: 0x1)

}; // Size: 0xA0

struct FAnimNode_LinkedAnimLayer : public FAnimNode_LinkedAnimGraph
{
    TSubclassOf<class UAnimLayerInterface> Interface;                                 // 0x00A0 (size: 0x8)
    FName Layer;                                                                      // 0x00A8 (size: 0x8)

}; // Size: 0xB0

struct FAnimNode_LinkedInputPose : public FAnimNode_Base
{
    FName Name;                                                                       // 0x0010 (size: 0x8)
    FName Graph;                                                                      // 0x0018 (size: 0x8)
    FPoseLink InputPose;                                                              // 0x0020 (size: 0x10)

}; // Size: 0x118

struct FAnimNode_SaveCachedPose : public FAnimNode_Base
{
    FPoseLink Pose;                                                                   // 0x0010 (size: 0x10)
    FName CachePoseName;                                                              // 0x0020 (size: 0x8)

}; // Size: 0x158

struct FAnimNode_SequencePlayer : public FAnimNode_AssetPlayerBase
{
    class UAnimSequenceBase* Sequence;                                                // 0x0038 (size: 0x8)
    float PlayRateBasis;                                                              // 0x0040 (size: 0x4)
    float PlayRate;                                                                   // 0x0044 (size: 0x4)
    FInputScaleBiasClamp PlayRateScaleBiasClamp;                                      // 0x0048 (size: 0x30)
    float StartPosition;                                                              // 0x0078 (size: 0x4)
    bool bLoopAnimation;                                                              // 0x007C (size: 0x1)

}; // Size: 0x80

struct FAnimNode_StateMachine : public FAnimNode_Base
{
    int32 StateMachineIndexInClass;                                                   // 0x0010 (size: 0x4)
    int32 MaxTransitionsPerFrame;                                                     // 0x0014 (size: 0x4)
    bool bSkipFirstUpdateTransition;                                                  // 0x0018 (size: 0x1)
    bool bReinitializeOnBecomingRelevant;                                             // 0x0019 (size: 0x1)

}; // Size: 0xB0

struct FAnimationPotentialTransition
{
}; // Size: 0x30

struct FAnimationActiveTransitionEntry
{
    class UBlendProfile* BlendProfile;                                                // 0x00B8 (size: 0x8)

}; // Size: 0xC8

struct FAnimNode_TransitionPoseEvaluator : public FAnimNode_Base
{
    int32 FramesToCachePose;                                                          // 0x00E8 (size: 0x4)
    TEnumAsByte<EEvaluatorDataSource::Type> DataSource;                               // 0x00F0 (size: 0x1)
    TEnumAsByte<EEvaluatorMode::Type> EvaluatorMode;                                  // 0x00F1 (size: 0x1)

}; // Size: 0xF8

struct FAnimNode_TransitionResult : public FAnimNode_Base
{
    bool bCanEnterTransition;                                                         // 0x0010 (size: 0x1)

}; // Size: 0x28

struct FAnimNode_UseCachedPose : public FAnimNode_Base
{
    FPoseLink LinkToCachingNode;                                                      // 0x0010 (size: 0x10)
    FName CachePoseName;                                                              // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FAnimNode_ConvertLocalToComponentSpace : public FAnimNode_Base
{
    FPoseLink LocalPose;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimNode_ConvertComponentToLocalSpace : public FAnimNode_Base
{
    FComponentSpacePoseLink ComponentPose;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FCompressedTrack
{
    TArray<uint8> ByteStream;                                                         // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)
    float Mins;                                                                       // 0x0020 (size: 0xC)
    float Ranges;                                                                     // 0x002C (size: 0xC)

}; // Size: 0x38

struct FCurveTrack
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)
    TArray<float> CurveWeights;                                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FScaleTrack
{
    TArray<FVector> ScaleKeys;                                                        // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FRotationTrack
{
    TArray<FQuat> RotKeys;                                                            // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FTranslationTrack
{
    TArray<FVector> PosKeys;                                                          // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FRawAnimSequenceTrack
{
    TArray<FVector> PosKeys;                                                          // 0x0000 (size: 0x10)
    TArray<FQuat> RotKeys;                                                            // 0x0010 (size: 0x10)
    TArray<FVector> ScaleKeys;                                                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FAnimSequenceTrackContainer
{
    TArray<FRawAnimSequenceTrack> AnimationTracks;                                    // 0x0000 (size: 0x10)
    TArray<FName> TrackNames;                                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimSingleNodeInstanceProxy : public FAnimInstanceProxy
{
}; // Size: 0x8C0

struct FAnimNode_SingleNode : public FAnimNode_Base
{
    FPoseLink SourcePose;                                                             // 0x0010 (size: 0x10)

}; // Size: 0x30

struct FAnimationTransitionRule
{
    FName RuleToExecute;                                                              // 0x0000 (size: 0x8)
    bool TransitionReturnVal;                                                         // 0x0008 (size: 0x1)
    int32 TransitionIndex;                                                            // 0x000C (size: 0x4)

}; // Size: 0x10

struct FAnimationState : public FAnimationStateBase
{
    TArray<FAnimationTransitionRule> Transitions;                                     // 0x0008 (size: 0x10)
    int32 StateRootNodeIndex;                                                         // 0x0018 (size: 0x4)
    int32 StartNotify;                                                                // 0x001C (size: 0x4)
    int32 EndNotify;                                                                  // 0x0020 (size: 0x4)
    int32 FullyBlendedNotify;                                                         // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FAnimNotifyTrack
{
    FName TrackName;                                                                  // 0x0000 (size: 0x8)
    FLinearColor TrackColor;                                                          // 0x0008 (size: 0x10)

}; // Size: 0x38

struct FPerBoneBlendWeights
{
    TArray<FPerBoneBlendWeight> BoneBlendWeights;                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAssetImportInfo
{
}; // Size: 0x1

struct FAssetManagerSearchRules
{
    TArray<FString> AssetScanPaths;                                                   // 0x0000 (size: 0x10)
    TArray<FString> IncludePatterns;                                                  // 0x0010 (size: 0x10)
    TArray<FString> ExcludePatterns;                                                  // 0x0020 (size: 0x10)
    UClass* AssetBaseClass;                                                           // 0x0030 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0038 (size: 0x1)
    bool bForceSynchronousScan;                                                       // 0x0039 (size: 0x1)
    bool bSkipVirtualPathExpansion;                                                   // 0x003A (size: 0x1)
    bool bSkipManagerIncludeCheck;                                                    // 0x003B (size: 0x1)

}; // Size: 0x50

struct FAtmospherePrecomputeInstanceData : public FSceneComponentInstanceData
{
}; // Size: 0x160

struct FAudioReverbEffect : public FAudioEffectParameters
{
}; // Size: 0x48

struct FNavAvoidanceData
{
}; // Size: 0x3C

struct FGridBlendSample
{
    FEditorElement GridElement;                                                       // 0x0000 (size: 0x18)
    float BlendWeight;                                                                // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FBPEditorBookmarkNode
{
    FGuid NodeGuid;                                                                   // 0x0000 (size: 0x10)
    FGuid ParentGuid;                                                                 // 0x0010 (size: 0x10)
    FText DisplayName;                                                                // 0x0020 (size: 0x18)

}; // Size: 0x38

struct FEditedDocumentInfo
{
    FSoftObjectPath EditedObjectPath;                                                 // 0x0000 (size: 0x18)
    FVector2D SavedViewOffset;                                                        // 0x0018 (size: 0x8)
    float SavedZoomAmount;                                                            // 0x0020 (size: 0x4)
    class UObject* EditedObject;                                                      // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FBPInterfaceDescription
{
    TSubclassOf<class UInterface> Interface;                                          // 0x0000 (size: 0x8)
    TArray<class UEdGraph*> Graphs;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBPVariableDescription
{
    FName VarName;                                                                    // 0x0000 (size: 0x8)
    FGuid VarGuid;                                                                    // 0x0008 (size: 0x10)
    FEdGraphPinType VarType;                                                          // 0x0018 (size: 0x58)
    FString FriendlyName;                                                             // 0x0070 (size: 0x10)
    FText Category;                                                                   // 0x0080 (size: 0x18)
    uint64 PropertyFlags;                                                             // 0x0098 (size: 0x8)
    FName RepNotifyFunc;                                                              // 0x00A0 (size: 0x8)
    TEnumAsByte<ELifetimeCondition> ReplicationCondition;                             // 0x00A8 (size: 0x1)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x00B0 (size: 0x10)
    FString DefaultValue;                                                             // 0x00C0 (size: 0x10)

}; // Size: 0xD0

struct FBlueprintMacroCosmeticInfo
{
}; // Size: 0x1

struct FCompilerNativizationOptions
{
    FName PlatformName;                                                               // 0x0000 (size: 0x8)
    bool ServerOnlyPlatform;                                                          // 0x0008 (size: 0x1)
    bool ClientOnlyPlatform;                                                          // 0x0009 (size: 0x1)
    bool bExcludeMonolithicHeaders;                                                   // 0x000A (size: 0x1)
    TArray<FName> ExcludedModules;                                                    // 0x0010 (size: 0x10)
    TSet<FSoftObjectPath> ExcludedAssets;                                             // 0x0020 (size: 0x50)
    TArray<FString> ExcludedFolderPaths;                                              // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FEventGraphFastCallPair
{
    class UFunction* FunctionToPatch;                                                 // 0x0000 (size: 0x8)
    int32 EventGraphCallOffset;                                                       // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FBlueprintDebugData
{
}; // Size: 0x1

struct FPointerToUberGraphFrame
{
}; // Size: 0x8

struct FDebuggingInfoForSingleFunction
{
}; // Size: 0x190

struct FNodeToCodeAssociation
{
}; // Size: 0x14

struct FAnimCurveType
{
}; // Size: 0x2

struct FBookmarkBaseJumpToSettings
{
}; // Size: 0x1

struct FBookmarkJumpToSettings : public FBookmarkBaseJumpToSettings
{
}; // Size: 0x1

struct FBookmark2DJumpToSettings
{
}; // Size: 0x1

struct FCachedAnimTransitionData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName FromStateName;                                                              // 0x0008 (size: 0x8)
    FName ToStateName;                                                                // 0x0010 (size: 0x8)

}; // Size: 0x24

struct FCachedAnimRelevancyData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x1C

struct FCachedAnimAssetPlayerData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x18

struct FCachedAnimStateData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x1C

struct FCachedAnimStateArray
{
    TArray<FCachedAnimStateData> States;                                              // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FCameraShakeDuration
{
    float Duration;                                                                   // 0x0000 (size: 0x4)
    ECameraShakeDurationType Type;                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FCameraShakeInfo
{
    FCameraShakeDuration Duration;                                                    // 0x0000 (size: 0x8)
    float BlendIn;                                                                    // 0x0008 (size: 0x4)
    float BlendOut;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FCameraShakeStopParams
{
    bool bImmediately;                                                                // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FCameraShakeUpdateResult
{
}; // Size: 0x590

struct FCameraShakeScrubParams
{
    float AbsoluteTime;                                                               // 0x0000 (size: 0x4)
    float ShakeScale;                                                                 // 0x0004 (size: 0x4)
    float DynamicScale;                                                               // 0x0008 (size: 0x4)
    float BlendingWeight;                                                             // 0x000C (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x5F0)

}; // Size: 0x600

struct FCameraShakeUpdateParams
{
    float DeltaTime;                                                                  // 0x0000 (size: 0x4)
    float ShakeScale;                                                                 // 0x0004 (size: 0x4)
    float DynamicScale;                                                               // 0x0008 (size: 0x4)
    float BlendingWeight;                                                             // 0x000C (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x5F0)

}; // Size: 0x600

struct FCameraShakeStartParams
{
    bool bIsRestarting;                                                               // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FDummySpacerCameraTypes
{
}; // Size: 0x1

struct FCanvasIcon
{
    class UTexture* Texture;                                                          // 0x0000 (size: 0x8)
    float U;                                                                          // 0x0008 (size: 0x4)
    float V;                                                                          // 0x000C (size: 0x4)
    float UL;                                                                         // 0x0010 (size: 0x4)
    float VL;                                                                         // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FWrappedStringElement
{
    FString Value;                                                                    // 0x0000 (size: 0x10)
    FVector2D LineExtent;                                                             // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FTextSizingParameters
{
    float DrawX;                                                                      // 0x0000 (size: 0x4)
    float DrawY;                                                                      // 0x0004 (size: 0x4)
    float DrawXL;                                                                     // 0x0008 (size: 0x4)
    float DrawYL;                                                                     // 0x000C (size: 0x4)
    FVector2D Scaling;                                                                // 0x0010 (size: 0x8)
    class UFont* DrawFont;                                                            // 0x0018 (size: 0x8)
    FVector2D SpacingAdjust;                                                          // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FChildActorAttachedActorInfo
{
    TWeakObjectPtr<class AActor> Actor;                                               // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FTransform RelativeTransform;                                                     // 0x0010 (size: 0x30)

}; // Size: 0x40

struct FChildActorComponentInstanceData : public FSceneComponentInstanceData
{
    TSubclassOf<class AActor> ChildActorClass;                                        // 0x00B8 (size: 0x8)
    FName ChildActorName;                                                             // 0x00C0 (size: 0x8)
    TArray<FChildActorAttachedActorInfo> AttachedActors;                              // 0x00C8 (size: 0x10)

}; // Size: 0xE8

struct FAutoCompleteNode
{
    int32 IndexChar;                                                                  // 0x0000 (size: 0x4)
    TArray<int32> AutoCompleteListIndices;                                            // 0x0008 (size: 0x10)

}; // Size: 0x28

struct FRuntimeCurveLinearColor
{
    FRichCurve ColorCurves;                                                           // 0x0000 (size: 0x200)
    class UCurveLinearColor* ExternalCurve;                                           // 0x0200 (size: 0x8)

}; // Size: 0x208

struct FCurveAtlasColorAdjustments
{
    uint8 bChromaKeyTexture;                                                          // 0x0000 (size: 0x1)
    float AdjustBrightness;                                                           // 0x0004 (size: 0x4)
    float AdjustBrightnessCurve;                                                      // 0x0008 (size: 0x4)
    float AdjustVibrance;                                                             // 0x000C (size: 0x4)
    float AdjustSaturation;                                                           // 0x0010 (size: 0x4)
    float AdjustRGBCurve;                                                             // 0x0014 (size: 0x4)
    float AdjustHue;                                                                  // 0x0018 (size: 0x4)
    float AdjustMinAlpha;                                                             // 0x001C (size: 0x4)
    float AdjustMaxAlpha;                                                             // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FCurveTableRowHandle
{
    class UCurveTable* CurveTable;                                                    // 0x0000 (size: 0x8)
    FName RowName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCustomAttribute
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    int32 VariantType;                                                                // 0x0008 (size: 0x4)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x30

struct FCustomAttributePerBoneData
{
    int32 BoneTreeIndex;                                                              // 0x0000 (size: 0x4)
    TArray<FCustomAttribute> Attributes;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FDataTableCategoryHandle
{
    class UDataTable* DataTable;                                                      // 0x0000 (size: 0x8)
    FName ColumnName;                                                                 // 0x0008 (size: 0x8)
    FName RowContents;                                                                // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FDataTableRowHandle
{
    class UDataTable* DataTable;                                                      // 0x0000 (size: 0x8)
    FName RowName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FGraphReference
{
    class UEdGraph* MacroGraph;                                                       // 0x0000 (size: 0x8)
    class UBlueprint* GraphBlueprint;                                                 // 0x0008 (size: 0x8)
    FGuid GraphGuid;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FEdGraphPinReference
{
    TWeakObjectPtr<class UEdGraphNode> OwningNode;                                    // 0x0000 (size: 0x8)
    FGuid PinId;                                                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FEdGraphSchemaAction
{
    FText MenuDescription;                                                            // 0x0008 (size: 0x18)
    FText TooltipDescription;                                                         // 0x0020 (size: 0x18)
    FText Category;                                                                   // 0x0038 (size: 0x18)
    FText Keywords;                                                                   // 0x0050 (size: 0x18)
    int32 Grouping;                                                                   // 0x0068 (size: 0x4)
    int32 SectionID;                                                                  // 0x006C (size: 0x4)
    TArray<FString> MenuDescriptionArray;                                             // 0x0070 (size: 0x10)
    TArray<FString> FullSearchTitlesArray;                                            // 0x0080 (size: 0x10)
    TArray<FString> FullSearchKeywordsArray;                                          // 0x0090 (size: 0x10)
    TArray<FString> FullSearchCategoryArray;                                          // 0x00A0 (size: 0x10)
    TArray<FString> LocalizedMenuDescriptionArray;                                    // 0x00B0 (size: 0x10)
    TArray<FString> LocalizedFullSearchTitlesArray;                                   // 0x00C0 (size: 0x10)
    TArray<FString> LocalizedFullSearchKeywordsArray;                                 // 0x00D0 (size: 0x10)
    TArray<FString> LocalizedFullSearchCategoryArray;                                 // 0x00E0 (size: 0x10)
    FString SearchText;                                                               // 0x00F0 (size: 0x10)

}; // Size: 0x100

struct FEdGraphSchemaAction_NewNode : public FEdGraphSchemaAction
{
    class UEdGraphNode* NodeTemplate;                                                 // 0x0100 (size: 0x8)

}; // Size: 0x108

struct FScreenMessageString
{
    uint64 Key;                                                                       // 0x0000 (size: 0x8)
    FString ScreenMessage;                                                            // 0x0008 (size: 0x10)
    FColor DisplayColor;                                                              // 0x0018 (size: 0x4)
    float TimeToDisplay;                                                              // 0x001C (size: 0x4)
    float CurrentTimeDisplayed;                                                       // 0x0020 (size: 0x4)
    FVector2D TextScale;                                                              // 0x0024 (size: 0x8)

}; // Size: 0x30

struct FURL
{
    FString Protocol;                                                                 // 0x0000 (size: 0x10)
    FString Host;                                                                     // 0x0010 (size: 0x10)
    int32 Port;                                                                       // 0x0020 (size: 0x4)
    int32 Valid;                                                                      // 0x0024 (size: 0x4)
    FString Map;                                                                      // 0x0028 (size: 0x10)
    FString RedirectURL;                                                              // 0x0038 (size: 0x10)
    TArray<FString> Op;                                                               // 0x0048 (size: 0x10)
    FString Portal;                                                                   // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FFullyLoadedPackagesInfo
{
    TEnumAsByte<EFullyLoadPackageType> FullyLoadType;                                 // 0x0000 (size: 0x1)
    FString Tag;                                                                      // 0x0008 (size: 0x10)
    TArray<FName> PackagesToLoad;                                                     // 0x0018 (size: 0x10)
    TArray<class UObject*> LoadedObjects;                                             // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FLevelStreamingStatus
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    uint8 bShouldBeLoaded;                                                            // 0x0008 (size: 0x1)
    uint8 bShouldBeVisible;                                                           // 0x0008 (size: 0x1)
    uint32 LODIndex;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

struct FNamedNetDriver
{
    class UNetDriver* NetDriver;                                                      // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FWorldContext
{
    FURL LastURL;                                                                     // 0x00D0 (size: 0x68)
    FURL LastRemoteURL;                                                               // 0x0138 (size: 0x68)
    class UPendingNetGame* PendingNetGame;                                            // 0x01A0 (size: 0x8)
    TArray<FFullyLoadedPackagesInfo> PackagesToFullyLoad;                             // 0x01A8 (size: 0x10)
    TArray<class ULevel*> LoadedLevelsForPendingMapChange;                            // 0x01C8 (size: 0x10)
    TArray<class UObjectReferencer*> ObjectReferencers;                               // 0x01F0 (size: 0x10)
    TArray<FLevelStreamingStatus> PendingLevelStreamingStatusUpdates;                 // 0x0200 (size: 0x10)
    class UGameViewportClient* GameViewport;                                          // 0x0210 (size: 0x8)
    class UGameInstance* OwningGameInstance;                                          // 0x0218 (size: 0x8)
    TArray<FNamedNetDriver> ActiveNetDrivers;                                         // 0x0220 (size: 0x10)

}; // Size: 0x288

struct FExposureSettings
{
    float FixedEV100;                                                                 // 0x0000 (size: 0x4)
    bool bFixed;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FTickPrerequisite
{
}; // Size: 0x10

struct FDepthFieldGlowInfo
{
    uint8 bEnableGlow;                                                                // 0x0000 (size: 0x1)
    FLinearColor GlowColor;                                                           // 0x0004 (size: 0x10)
    FVector2D GlowOuterRadius;                                                        // 0x0014 (size: 0x8)
    FVector2D GlowInnerRadius;                                                        // 0x001C (size: 0x8)

}; // Size: 0x24

struct FFontRenderInfo
{
    uint8 bClipText;                                                                  // 0x0000 (size: 0x1)
    uint8 bEnableShadow;                                                              // 0x0000 (size: 0x1)
    FDepthFieldGlowInfo GlowInfo;                                                     // 0x0004 (size: 0x24)

}; // Size: 0x28

struct FDamageEvent
{
    TSubclassOf<class UDamageType> DamageTypeClass;                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FRadialDamageParams
{
    float BaseDamage;                                                                 // 0x0000 (size: 0x4)
    float MinimumDamage;                                                              // 0x0004 (size: 0x4)
    float InnerRadius;                                                                // 0x0008 (size: 0x4)
    float OuterRadius;                                                                // 0x000C (size: 0x4)
    float DamageFalloff;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FRadialDamageEvent : public FDamageEvent
{
    FRadialDamageParams Params;                                                       // 0x0010 (size: 0x14)
    FVector Origin;                                                                   // 0x0024 (size: 0xC)
    TArray<FHitResult> ComponentHits;                                                 // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FPointDamageEvent : public FDamageEvent
{
    float Damage;                                                                     // 0x0010 (size: 0x4)
    FVector_NetQuantizeNormal ShotDirection;                                          // 0x0014 (size: 0xC)
    FHitResult HitInfo;                                                               // 0x0020 (size: 0x88)

}; // Size: 0xA8

struct FPOV
{
    FVector Location;                                                                 // 0x0000 (size: 0xC)
    FRotator Rotation;                                                                // 0x000C (size: 0xC)
    float FOV;                                                                        // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FAnimUpdateRateParameters
{
    EUpdateRateShiftBucket ShiftBucket;                                               // 0x0001 (size: 0x1)
    uint8 bInterpolateSkippedFrames;                                                  // 0x0002 (size: 0x1)
    uint8 bShouldUseLodMap;                                                           // 0x0002 (size: 0x1)
    uint8 bShouldUseMinLod;                                                           // 0x0002 (size: 0x1)
    uint8 bSkipUpdate;                                                                // 0x0002 (size: 0x1)
    uint8 bSkipEvaluation;                                                            // 0x0002 (size: 0x1)
    int32 UpdateRate;                                                                 // 0x0004 (size: 0x4)
    int32 EvaluationRate;                                                             // 0x0008 (size: 0x4)
    float TickedPoseOffestTime;                                                       // 0x000C (size: 0x4)
    float AdditionalTime;                                                             // 0x0010 (size: 0x4)
    int32 BaseNonRenderedUpdateRate;                                                  // 0x0018 (size: 0x4)
    int32 MaxEvalRateForInterpolation;                                                // 0x001C (size: 0x4)
    TArray<float> BaseVisibleDistanceFactorThesholds;                                 // 0x0020 (size: 0x10)
    TMap<int32, int32> LODToFrameSkipMap;                                             // 0x0030 (size: 0x50)
    int32 SkippedUpdateFrames;                                                        // 0x0080 (size: 0x4)
    int32 SkippedEvalFrames;                                                          // 0x0084 (size: 0x4)

}; // Size: 0x88

struct FAnimSlotDesc
{
    FName SlotName;                                                                   // 0x0000 (size: 0x8)
    int32 NumChannels;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FAnimSlotInfo
{
    FName SlotName;                                                                   // 0x0000 (size: 0x8)
    TArray<float> ChannelWeights;                                                     // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FMTDResult
{
    FVector Direction;                                                                // 0x0000 (size: 0xC)
    float Distance;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FOverlapResult
{
    TWeakObjectPtr<class AActor> Actor;                                               // 0x0000 (size: 0x8)
    TWeakObjectPtr<class UPrimitiveComponent> Component;                              // 0x0008 (size: 0x8)
    uint8 bBlockingHit;                                                               // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FSwarmDebugOptions
{
    uint8 bDistributionEnabled;                                                       // 0x0000 (size: 0x1)
    uint8 bForceContentExport;                                                        // 0x0000 (size: 0x1)
    uint8 bInitialized;                                                               // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FLightmassDebugOptions
{
    uint8 bDebugMode;                                                                 // 0x0000 (size: 0x1)
    uint8 bStatsEnabled;                                                              // 0x0000 (size: 0x1)
    uint8 bGatherBSPSurfacesAcrossComponents;                                         // 0x0000 (size: 0x1)
    float CoplanarTolerance;                                                          // 0x0004 (size: 0x4)
    uint8 bUseImmediateImport;                                                        // 0x0008 (size: 0x1)
    uint8 bImmediateProcessMappings;                                                  // 0x0008 (size: 0x1)
    uint8 bSortMappings;                                                              // 0x0008 (size: 0x1)
    uint8 bDumpBinaryFiles;                                                           // 0x0008 (size: 0x1)
    uint8 bDebugMaterials;                                                            // 0x0008 (size: 0x1)
    uint8 bPadMappings;                                                               // 0x0008 (size: 0x1)
    uint8 bDebugPaddings;                                                             // 0x0008 (size: 0x1)
    uint8 bOnlyCalcDebugTexelMappings;                                                // 0x0008 (size: 0x1)
    uint8 bUseRandomColors;                                                           // 0x0009 (size: 0x1)
    uint8 bColorBordersGreen;                                                         // 0x0009 (size: 0x1)
    uint8 bColorByExecutionTime;                                                      // 0x0009 (size: 0x1)
    float ExecutionTimeDivisor;                                                       // 0x000C (size: 0x4)

}; // Size: 0x10

struct FBasedPosition
{
    class AActor* Base;                                                               // 0x0000 (size: 0x8)
    FVector Position;                                                                 // 0x0008 (size: 0xC)
    FVector CachedBaseLocation;                                                       // 0x0014 (size: 0xC)
    FRotator CachedBaseRotation;                                                      // 0x0020 (size: 0xC)
    FVector CachedTransPosition;                                                      // 0x002C (size: 0xC)

}; // Size: 0x38

struct FRigidBodyContactInfo
{
    FVector ContactPosition;                                                          // 0x0000 (size: 0xC)
    FVector ContactNormal;                                                            // 0x000C (size: 0xC)
    float ContactPenetration;                                                         // 0x0018 (size: 0x4)
    class UPhysicalMaterial* PhysMaterial;                                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FCollisionImpactData
{
    TArray<FRigidBodyContactInfo> ContactInfos;                                       // 0x0000 (size: 0x10)
    FVector TotalNormalImpulse;                                                       // 0x0010 (size: 0xC)
    FVector TotalFrictionImpulse;                                                     // 0x001C (size: 0xC)
    bool bIsVelocityDeltaUnderThreshold;                                              // 0x0028 (size: 0x1)

}; // Size: 0x30

struct FRigidBodyState
{
    FVector_NetQuantize100 Position;                                                  // 0x0000 (size: 0xC)
    FQuat Quaternion;                                                                 // 0x0010 (size: 0x10)
    FVector_NetQuantize100 LinVel;                                                    // 0x0020 (size: 0xC)
    FVector_NetQuantize100 AngVel;                                                    // 0x002C (size: 0xC)
    uint8 Flags;                                                                      // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FActiveHapticFeedbackEffect
{
    class UHapticFeedbackEffect_Base* HapticEffect;                                   // 0x0000 (size: 0x8)

}; // Size: 0x18

struct FClusterNode
{
    FVector BoundMin;                                                                 // 0x0000 (size: 0xC)
    int32 FirstChild;                                                                 // 0x000C (size: 0x4)
    FVector BoundMax;                                                                 // 0x0010 (size: 0xC)
    int32 LastChild;                                                                  // 0x001C (size: 0x4)
    int32 FirstInstance;                                                              // 0x0020 (size: 0x4)
    int32 LastInstance;                                                               // 0x0024 (size: 0x4)
    FVector MinInstanceScale;                                                         // 0x0028 (size: 0xC)
    FVector MaxInstanceScale;                                                         // 0x0034 (size: 0xC)

}; // Size: 0x40

struct FClusterNode_DEPRECATED
{
    FVector BoundMin;                                                                 // 0x0000 (size: 0xC)
    int32 FirstChild;                                                                 // 0x000C (size: 0x4)
    FVector BoundMax;                                                                 // 0x0010 (size: 0xC)
    int32 LastChild;                                                                  // 0x001C (size: 0x4)
    int32 FirstInstance;                                                              // 0x0020 (size: 0x4)
    int32 LastInstance;                                                               // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FHLODISMComponentDesc
{
    class UStaticMesh* StaticMesh;                                                    // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)
    TArray<FTransform> Instances;                                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FInstancedStaticMeshLightMapInstanceData
{
    FTransform Transform;                                                             // 0x0000 (size: 0x30)
    TArray<FGuid> MapBuildDataIds;                                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FInstancedStaticMeshComponentInstanceData : public FSceneComponentInstanceData
{
    class UStaticMesh* StaticMesh;                                                    // 0x00B8 (size: 0x8)
    FInstancedStaticMeshLightMapInstanceData CachedStaticLighting;                    // 0x00C0 (size: 0x40)
    TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;                       // 0x0100 (size: 0x10)
    TArray<float> PerInstanceSMCustomData;                                            // 0x0110 (size: 0x10)
    int32 InstancingRandomSeed;                                                       // 0x0140 (size: 0x4)

}; // Size: 0x150

struct FInterpEdSelKey
{
    class UInterpGroup* Group;                                                        // 0x0000 (size: 0x8)
    class UInterpTrack* Track;                                                        // 0x0008 (size: 0x8)
    int32 KeyIndex;                                                                   // 0x0010 (size: 0x4)
    float UnsnappedPosition;                                                          // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FCameraPreviewInfo
{
    TSubclassOf<class APawn> PawnClass;                                               // 0x0000 (size: 0x8)
    class UAnimSequence* AnimSeq;                                                     // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0xC)
    FRotator Rotation;                                                                // 0x001C (size: 0xC)
    class APawn* PawnInst;                                                            // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FSubTrackGroup
{
    FString GroupName;                                                                // 0x0000 (size: 0x10)
    TArray<int32> TrackIndices;                                                       // 0x0010 (size: 0x10)
    uint8 bIsCollapsed;                                                               // 0x0020 (size: 0x1)
    uint8 bIsSelected;                                                                // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSupportedSubTrackInfo
{
    TSubclassOf<class UInterpTrack> SupportedClass;                                   // 0x0000 (size: 0x8)
    FString SubTrackName;                                                             // 0x0008 (size: 0x10)
    int32 GroupIndex;                                                                 // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FLatentActionManager
{
}; // Size: 0x60

struct FLevelSimplificationDetails
{
    bool bCreatePackagePerAsset;                                                      // 0x0000 (size: 0x1)
    float DetailsPercentage;                                                          // 0x0004 (size: 0x4)
    FMaterialProxySettings StaticMeshMaterialSettings;                                // 0x0008 (size: 0x88)
    bool bOverrideLandscapeExportLOD;                                                 // 0x0090 (size: 0x1)
    int32 LandscapeExportLOD;                                                         // 0x0094 (size: 0x4)
    FMaterialProxySettings LandscapeMaterialSettings;                                 // 0x0098 (size: 0x88)
    bool bBakeFoliageToLandscape;                                                     // 0x0120 (size: 0x1)
    bool bBakeGrassToLandscape;                                                       // 0x0121 (size: 0x1)
    bool bGenerateMeshNormalMap;                                                      // 0x0122 (size: 0x1)
    bool bGenerateMeshMetallicMap;                                                    // 0x0123 (size: 0x1)
    bool bGenerateMeshRoughnessMap;                                                   // 0x0124 (size: 0x1)
    bool bGenerateMeshSpecularMap;                                                    // 0x0125 (size: 0x1)
    bool bGenerateLandscapeNormalMap;                                                 // 0x0126 (size: 0x1)
    bool bGenerateLandscapeMetallicMap;                                               // 0x0127 (size: 0x1)
    bool bGenerateLandscapeRoughnessMap;                                              // 0x0128 (size: 0x1)
    bool bGenerateLandscapeSpecularMap;                                               // 0x0129 (size: 0x1)

}; // Size: 0x12C

struct FStreamableTextureInstance
{
}; // Size: 0x28

struct FDynamicTextureInstance : public FStreamableTextureInstance
{
    class UTexture2D* Texture;                                                        // 0x0028 (size: 0x8)
    bool bAttached;                                                                   // 0x0030 (size: 0x1)
    float OriginalRadius;                                                             // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FPrecomputedLightInstanceData : public FSceneComponentInstanceData
{
    FTransform Transform;                                                             // 0x00C0 (size: 0x30)
    FGuid LightGuid;                                                                  // 0x00F0 (size: 0x10)
    int32 PreviewShadowMapChannel;                                                    // 0x0100 (size: 0x4)

}; // Size: 0x110

struct FBatchedPoint
{
    FVector Position;                                                                 // 0x0000 (size: 0xC)
    FLinearColor Color;                                                               // 0x000C (size: 0x10)
    float PointSize;                                                                  // 0x001C (size: 0x4)
    float RemainingLifeTime;                                                          // 0x0020 (size: 0x4)
    uint8 DepthPriority;                                                              // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FBatchedLine
{
    FVector Start;                                                                    // 0x0000 (size: 0xC)
    FVector End;                                                                      // 0x000C (size: 0xC)
    FLinearColor Color;                                                               // 0x0018 (size: 0x10)
    float Thickness;                                                                  // 0x0028 (size: 0x4)
    float RemainingLifeTime;                                                          // 0x002C (size: 0x4)
    uint8 DepthPriority;                                                              // 0x0030 (size: 0x1)

}; // Size: 0x34

struct FClientReceiveData
{
    class APlayerController* LocalPC;                                                 // 0x0000 (size: 0x8)
    FName MessageType;                                                                // 0x0008 (size: 0x8)
    int32 MessageIndex;                                                               // 0x0010 (size: 0x4)
    FString MessageString;                                                            // 0x0018 (size: 0x10)
    class APlayerState* RelatedPlayerState_1;                                         // 0x0028 (size: 0x8)
    class APlayerState* RelatedPlayerState_2;                                         // 0x0030 (size: 0x8)
    class UObject* OptionalObject;                                                    // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FParameterGroupData
{
    FString GroupName;                                                                // 0x0000 (size: 0x10)
    int32 GroupSortPriority;                                                          // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FStaticComponentMaskValue
{
    bool R;                                                                           // 0x0000 (size: 0x1)
    bool G;                                                                           // 0x0001 (size: 0x1)
    bool B;                                                                           // 0x0002 (size: 0x1)
    bool A;                                                                           // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FParameterChannelNames
{
    FText R;                                                                          // 0x0000 (size: 0x18)
    FText G;                                                                          // 0x0018 (size: 0x18)
    FText B;                                                                          // 0x0030 (size: 0x18)
    FText A;                                                                          // 0x0048 (size: 0x18)

}; // Size: 0x60

struct FFunctionExpressionOutput
{
    class UMaterialExpressionFunctionOutput* ExpressionOutput;                        // 0x0000 (size: 0x8)
    FGuid ExpressionOutputId;                                                         // 0x0008 (size: 0x10)
    FExpressionOutput Output;                                                         // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FFunctionExpressionInput
{
    class UMaterialExpressionFunctionInput* ExpressionInput;                          // 0x0000 (size: 0x8)
    FGuid ExpressionInputId;                                                          // 0x0008 (size: 0x10)
    FExpressionInput Input;                                                           // 0x0018 (size: 0x14)

}; // Size: 0x30

struct FScalarParameterAtlasInstanceData
{
    bool bIsUsedAsAtlasPosition;                                                      // 0x0000 (size: 0x1)
    TSoftObjectPtr<UCurveLinearColor> Curve;                                          // 0x0008 (size: 0x28)
    TSoftObjectPtr<UCurveLinearColorAtlas> Atlas;                                     // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FMemberReference
{
    class UObject* MemberParent;                                                      // 0x0000 (size: 0x8)
    FString MemberScope;                                                              // 0x0008 (size: 0x10)
    FName MemberName;                                                                 // 0x0018 (size: 0x8)
    FGuid MemberGuid;                                                                 // 0x0020 (size: 0x10)
    bool bSelfContext;                                                                // 0x0030 (size: 0x1)
    bool bWasDeprecated;                                                              // 0x0031 (size: 0x1)

}; // Size: 0x38

struct FMeshInstancingSettings
{
    TSubclassOf<class AActor> ActorClassToUse;                                        // 0x0000 (size: 0x8)
    int32 InstanceReplacementThreshold;                                               // 0x0008 (size: 0x4)
    EMeshInstancingReplacementMethod MeshReplacementMethod;                           // 0x000C (size: 0x1)
    bool bSkipMeshesWithVertexColors;                                                 // 0x000D (size: 0x1)
    bool bUseHLODVolumes;                                                             // 0x000E (size: 0x1)
    TSubclassOf<class UInstancedStaticMeshComponent> ISMComponentToUse;               // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMeshReductionSettings
{
    float PercentTriangles;                                                           // 0x0000 (size: 0x4)
    float PercentVertices;                                                            // 0x0004 (size: 0x4)
    float MaxDeviation;                                                               // 0x0008 (size: 0x4)
    float PixelError;                                                                 // 0x000C (size: 0x4)
    float WeldingThreshold;                                                           // 0x0010 (size: 0x4)
    float HardAngleThreshold;                                                         // 0x0014 (size: 0x4)
    int32 BaseLODModel;                                                               // 0x0018 (size: 0x4)
    TEnumAsByte<EMeshFeatureImportance::Type> SilhouetteImportance;                   // 0x001C (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> TextureImportance;                      // 0x001D (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> ShadingImportance;                      // 0x001E (size: 0x1)
    uint8 bRecalculateNormals;                                                        // 0x001F (size: 0x1)
    uint8 bGenerateUniqueLightmapUVs;                                                 // 0x001F (size: 0x1)
    uint8 bKeepSymmetry;                                                              // 0x001F (size: 0x1)
    uint8 bVisibilityAided;                                                           // 0x001F (size: 0x1)
    uint8 bCullOccluded;                                                              // 0x001F (size: 0x1)
    EStaticMeshReductionTerimationCriterion TerminationCriterion;                     // 0x0020 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> VisibilityAggressiveness;               // 0x0021 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> VertexColorImportance;                  // 0x0022 (size: 0x1)

}; // Size: 0x24

struct FPacketSimulationSettings
{
    int32 PktLoss;                                                                    // 0x0000 (size: 0x4)
    int32 PktLossMaxSize;                                                             // 0x0004 (size: 0x4)
    int32 PktLossMinSize;                                                             // 0x0008 (size: 0x4)
    int32 PktOrder;                                                                   // 0x000C (size: 0x4)
    int32 PktDup;                                                                     // 0x0010 (size: 0x4)
    int32 PktLag;                                                                     // 0x0014 (size: 0x4)
    int32 PktLagVariance;                                                             // 0x0018 (size: 0x4)
    int32 PktLagMin;                                                                  // 0x001C (size: 0x4)
    int32 PktLagMax;                                                                  // 0x0020 (size: 0x4)
    int32 PktIncomingLagMin;                                                          // 0x0024 (size: 0x4)
    int32 PktIncomingLagMax;                                                          // 0x0028 (size: 0x4)
    int32 PktIncomingLoss;                                                            // 0x002C (size: 0x4)
    int32 PktJitter;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FFastArraySerializer
{
    int32 ArrayReplicationKey;                                                        // 0x0054 (size: 0x4)
    EFastArraySerializerDeltaFlags DeltaFlags;                                        // 0x0100 (size: 0x1)

}; // Size: 0x108

struct FFastArraySerializerItem
{
    int32 ReplicationID;                                                              // 0x0000 (size: 0x4)
    int32 ReplicationKey;                                                             // 0x0004 (size: 0x4)
    int32 MostRecentArrayReplicationKey;                                              // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FParticleCurvePair
{
    FString CurveName;                                                                // 0x0000 (size: 0x10)
    class UObject* CurveObject;                                                       // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FBeamTargetData
{
    FName TargetName;                                                                 // 0x0000 (size: 0x8)
    float TargetPercentage;                                                           // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FParticleSystemWorldManagerTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FParticleSystemReplayFrame
{
}; // Size: 0x10

struct FParticleEmitterReplayFrame
{
}; // Size: 0x10

struct FFreezablePerPlatformInt
{
}; // Size: 0x4

struct FPlayerMuteList
{
    bool bHasVoiceHandshakeCompleted;                                                 // 0x0030 (size: 0x1)
    int32 VoiceChannelIdx;                                                            // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FPreviewAttachedObjectPair
{
    TSoftObjectPtr<UObject> AttachedObject;                                           // 0x0000 (size: 0x28)
    class UObject* Object;                                                            // 0x0028 (size: 0x8)
    FName AttachedTo;                                                                 // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FPreviewAssetAttachContainer
{
    TArray<FPreviewAttachedObjectPair> AttachedObjects;                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPrimitiveComponentInstanceData : public FSceneComponentInstanceData
{
    FTransform ComponentTransform;                                                    // 0x00C0 (size: 0x30)
    int32 VisibilityId;                                                               // 0x00F0 (size: 0x4)
    class UPrimitiveComponent* LODParent;                                             // 0x00F8 (size: 0x8)

}; // Size: 0x100

struct FSpriteCategoryInfo
{
    FName Category;                                                                   // 0x0000 (size: 0x8)
    FText DisplayName;                                                                // 0x0008 (size: 0x18)
    FText Description;                                                                // 0x0020 (size: 0x18)

}; // Size: 0x38

struct FLevelNameAndTime
{
    FString LevelName;                                                                // 0x0000 (size: 0x10)
    uint32 LevelChangeTimeInMS;                                                       // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FCompressedRichCurve
{
}; // Size: 0x18

struct FRootMotionSourceStatus
{
    uint8 Flags;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FRootMotionFinishVelocitySettings
{
    ERootMotionFinishVelocityMode Mode;                                               // 0x0000 (size: 0x1)
    FVector SetVelocity;                                                              // 0x0004 (size: 0xC)
    float ClampVelocity;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FRootMotionSource
{
    uint16 Priority;                                                                  // 0x0010 (size: 0x2)
    uint16 LocalID;                                                                   // 0x0012 (size: 0x2)
    ERootMotionAccumulateMode AccumulateMode;                                         // 0x0014 (size: 0x1)
    FName InstanceName;                                                               // 0x0018 (size: 0x8)
    float StartTime;                                                                  // 0x0020 (size: 0x4)
    float CurrentTime;                                                                // 0x0024 (size: 0x4)
    float PreviousTime;                                                               // 0x0028 (size: 0x4)
    float Duration;                                                                   // 0x002C (size: 0x4)
    FRootMotionSourceStatus status;                                                   // 0x0030 (size: 0x1)
    FRootMotionSourceSettings Settings;                                               // 0x0031 (size: 0x1)
    bool bInLocalSpace;                                                               // 0x0032 (size: 0x1)
    FRootMotionMovementParams RootMotionParams;                                       // 0x0040 (size: 0x40)
    FRootMotionFinishVelocitySettings FinishVelocityParams;                           // 0x0080 (size: 0x14)

}; // Size: 0xA0

struct FRootMotionSource_JumpForce : public FRootMotionSource
{
    FRotator Rotation;                                                                // 0x0098 (size: 0xC)
    float Distance;                                                                   // 0x00A4 (size: 0x4)
    float Height;                                                                     // 0x00A8 (size: 0x4)
    bool bDisableTimeout;                                                             // 0x00AC (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x00B0 (size: 0x8)
    class UCurveFloat* TimeMappingCurve;                                              // 0x00B8 (size: 0x8)

}; // Size: 0xD0

struct FRootMotionSource_MoveToDynamicForce : public FRootMotionSource
{
    FVector StartLocation;                                                            // 0x0098 (size: 0xC)
    FVector InitialTargetLocation;                                                    // 0x00A4 (size: 0xC)
    FVector TargetLocation;                                                           // 0x00B0 (size: 0xC)
    bool bRestrictSpeedToExpected;                                                    // 0x00BC (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x00C0 (size: 0x8)
    class UCurveFloat* TimeMappingCurve;                                              // 0x00C8 (size: 0x8)

}; // Size: 0xD0

struct FRootMotionSource_MoveToForce : public FRootMotionSource
{
    FVector StartLocation;                                                            // 0x0098 (size: 0xC)
    FVector TargetLocation;                                                           // 0x00A4 (size: 0xC)
    bool bRestrictSpeedToExpected;                                                    // 0x00B0 (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x00B8 (size: 0x8)

}; // Size: 0xC0

struct FRootMotionSource_RadialForce : public FRootMotionSource
{
    FVector Location;                                                                 // 0x0098 (size: 0xC)
    class AActor* LocationActor;                                                      // 0x00A8 (size: 0x8)
    float Radius;                                                                     // 0x00B0 (size: 0x4)
    float Strength;                                                                   // 0x00B4 (size: 0x4)
    bool bIsPush;                                                                     // 0x00B8 (size: 0x1)
    bool bNoZForce;                                                                   // 0x00B9 (size: 0x1)
    class UCurveFloat* StrengthDistanceFalloff;                                       // 0x00C0 (size: 0x8)
    class UCurveFloat* StrengthOverTime;                                              // 0x00C8 (size: 0x8)
    bool bUseFixedWorldDirection;                                                     // 0x00D0 (size: 0x1)
    FRotator FixedWorldDirection;                                                     // 0x00D4 (size: 0xC)

}; // Size: 0xE0

struct FRootMotionSource_ConstantForce : public FRootMotionSource
{
    FVector Force;                                                                    // 0x0098 (size: 0xC)
    class UCurveFloat* StrengthOverTime;                                              // 0x00A8 (size: 0x8)

}; // Size: 0xB0

struct FCameraExposureSettings
{
    TEnumAsByte<EAutoExposureMethod> Method;                                          // 0x0000 (size: 0x1)
    float LowPercent;                                                                 // 0x0004 (size: 0x4)
    float HighPercent;                                                                // 0x0008 (size: 0x4)
    float MinBrightness;                                                              // 0x000C (size: 0x4)
    float MaxBrightness;                                                              // 0x0010 (size: 0x4)
    float SpeedUp;                                                                    // 0x0014 (size: 0x4)
    float SpeedDown;                                                                  // 0x0018 (size: 0x4)
    float Bias;                                                                       // 0x001C (size: 0x4)
    class UCurveFloat* BiasCurve;                                                     // 0x0020 (size: 0x8)
    class UTexture* MeterMask;                                                        // 0x0028 (size: 0x8)
    float HistogramLogMin;                                                            // 0x0030 (size: 0x4)
    float HistogramLogMax;                                                            // 0x0034 (size: 0x4)
    float CalibrationConstant;                                                        // 0x0038 (size: 0x4)
    uint8 ApplyPhysicalCameraExposure;                                                // 0x003C (size: 0x1)

}; // Size: 0x40

struct FGaussianSumBloomSettings
{
    float Intensity;                                                                  // 0x0000 (size: 0x4)
    float Threshold;                                                                  // 0x0004 (size: 0x4)
    float SizeScale;                                                                  // 0x0008 (size: 0x4)
    float Filter1Size;                                                                // 0x000C (size: 0x4)
    float Filter2Size;                                                                // 0x0010 (size: 0x4)
    float Filter3Size;                                                                // 0x0014 (size: 0x4)
    float Filter4Size;                                                                // 0x0018 (size: 0x4)
    float Filter5Size;                                                                // 0x001C (size: 0x4)
    float Filter6Size;                                                                // 0x0020 (size: 0x4)
    FLinearColor Filter1Tint;                                                         // 0x0024 (size: 0x10)
    FLinearColor Filter2Tint;                                                         // 0x0034 (size: 0x10)
    FLinearColor Filter3Tint;                                                         // 0x0044 (size: 0x10)
    FLinearColor Filter4Tint;                                                         // 0x0054 (size: 0x10)
    FLinearColor Filter5Tint;                                                         // 0x0064 (size: 0x10)
    FLinearColor Filter6Tint;                                                         // 0x0074 (size: 0x10)

}; // Size: 0x84

struct FConvolutionBloomSettings
{
    class UTexture2D* Texture;                                                        // 0x0000 (size: 0x8)
    float Size;                                                                       // 0x0008 (size: 0x4)
    FVector2D CenterUV;                                                               // 0x000C (size: 0x8)
    float PreFilterMin;                                                               // 0x0014 (size: 0x4)
    float PreFilterMax;                                                               // 0x0018 (size: 0x4)
    float PreFilterMult;                                                              // 0x001C (size: 0x4)
    float BufferScale;                                                                // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FLensBloomSettings
{
    FGaussianSumBloomSettings GaussianSum;                                            // 0x0000 (size: 0x84)
    FConvolutionBloomSettings Convolution;                                            // 0x0088 (size: 0x28)
    TEnumAsByte<EBloomMethod> Method;                                                 // 0x00B0 (size: 0x1)

}; // Size: 0xB8

struct FLensImperfectionSettings
{
    class UTexture* DirtMask;                                                         // 0x0000 (size: 0x8)
    float DirtMaskIntensity;                                                          // 0x0008 (size: 0x4)
    FLinearColor DirtMaskTint;                                                        // 0x000C (size: 0x10)

}; // Size: 0x20

struct FLensSettings
{
    FLensBloomSettings Bloom;                                                         // 0x0000 (size: 0xB8)
    FLensImperfectionSettings Imperfections;                                          // 0x00B8 (size: 0x20)
    float ChromaticAberration;                                                        // 0x00D8 (size: 0x4)

}; // Size: 0xE0

struct FFilmStockSettings
{
    float slope;                                                                      // 0x0000 (size: 0x4)
    float Toe;                                                                        // 0x0004 (size: 0x4)
    float Shoulder;                                                                   // 0x0008 (size: 0x4)
    float BlackClip;                                                                  // 0x000C (size: 0x4)
    float WhiteClip;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FColorGradePerRangeSettings
{
    FVector4 Saturation;                                                              // 0x0000 (size: 0x10)
    FVector4 Contrast;                                                                // 0x0010 (size: 0x10)
    FVector4 Gamma;                                                                   // 0x0020 (size: 0x10)
    FVector4 Gain;                                                                    // 0x0030 (size: 0x10)
    FVector4 Offset;                                                                  // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FColorGradingSettings
{
    FColorGradePerRangeSettings Global;                                               // 0x0000 (size: 0x50)
    FColorGradePerRangeSettings Shadows;                                              // 0x0050 (size: 0x50)
    FColorGradePerRangeSettings Midtones;                                             // 0x00A0 (size: 0x50)
    FColorGradePerRangeSettings Highlights;                                           // 0x00F0 (size: 0x50)
    float ShadowsMax;                                                                 // 0x0140 (size: 0x4)
    float HighlightsMin;                                                              // 0x0144 (size: 0x4)

}; // Size: 0x150

struct FSceneViewExtensionIsActiveFunctor
{
}; // Size: 0x50

struct FClothPhysicsProperties_Legacy
{
    float VerticalResistance;                                                         // 0x0000 (size: 0x4)
    float HorizontalResistance;                                                       // 0x0004 (size: 0x4)
    float BendResistance;                                                             // 0x0008 (size: 0x4)
    float ShearResistance;                                                            // 0x000C (size: 0x4)
    float Friction;                                                                   // 0x0010 (size: 0x4)
    float Damping;                                                                    // 0x0014 (size: 0x4)
    float TetherStiffness;                                                            // 0x0018 (size: 0x4)
    float TetherLimit;                                                                // 0x001C (size: 0x4)
    float Drag;                                                                       // 0x0020 (size: 0x4)
    float StiffnessFrequency;                                                         // 0x0024 (size: 0x4)
    float GravityScale;                                                               // 0x0028 (size: 0x4)
    float MassScale;                                                                  // 0x002C (size: 0x4)
    float InertiaBlend;                                                               // 0x0030 (size: 0x4)
    float SelfCollisionThickness;                                                     // 0x0034 (size: 0x4)
    float SelfCollisionSquashScale;                                                   // 0x0038 (size: 0x4)
    float SelfCollisionStiffness;                                                     // 0x003C (size: 0x4)
    float SolverFrequency;                                                            // 0x0040 (size: 0x4)
    float FiberCompression;                                                           // 0x0044 (size: 0x4)
    float FiberExpansion;                                                             // 0x0048 (size: 0x4)
    float FiberResistance;                                                            // 0x004C (size: 0x4)

}; // Size: 0x50

struct FClothingAssetData_Legacy
{
    FName AssetName;                                                                  // 0x0000 (size: 0x8)
    FString ApexFileName;                                                             // 0x0008 (size: 0x10)
    bool bClothPropertiesChanged;                                                     // 0x0018 (size: 0x1)
    FClothPhysicsProperties_Legacy PhysicsProperties;                                 // 0x001C (size: 0x50)

}; // Size: 0x78

struct FSkeletalMeshClothBuildParams
{
    TWeakObjectPtr<class UClothingAssetBase> TargetAsset;                             // 0x0000 (size: 0x8)
    int32 TargetLod;                                                                  // 0x0008 (size: 0x4)
    bool bRemapParameters;                                                            // 0x000C (size: 0x1)
    FString AssetName;                                                                // 0x0010 (size: 0x10)
    int32 LODIndex;                                                                   // 0x0020 (size: 0x4)
    int32 SourceSection;                                                              // 0x0024 (size: 0x4)
    bool bRemoveFromMesh;                                                             // 0x0028 (size: 0x1)
    TSoftObjectPtr<UPhysicsAsset> PhysicsAsset;                                       // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FBoneMirrorExport
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    FName SourceBoneName;                                                             // 0x0008 (size: 0x8)
    TEnumAsByte<EAxis::Type> BoneFlipAxis;                                            // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FSkeletalMeshComponentClothTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FSkeletalMeshComponentEndPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FNameMapping
{
    FName NodeName;                                                                   // 0x0000 (size: 0x8)
    FName BoneName;                                                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FRigConfiguration
{
    class URig* Rig;                                                                  // 0x0000 (size: 0x8)
    TArray<FNameMapping> BoneMappingTable;                                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBoneReductionSetting
{
    TArray<FName> BonesToRemove;                                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FReferencePose
{
    FName PoseName;                                                                   // 0x0000 (size: 0x8)
    TArray<FTransform> ReferencePose;                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSkeletonToMeshLinkup
{
    TArray<int32> SkeletonToMeshTable;                                                // 0x0000 (size: 0x10)
    TArray<int32> MeshToSkeletonTable;                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSkinWeightProfileManagerTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FPrecomputedSkyLightInstanceData : public FSceneComponentInstanceData
{
    FGuid LightGuid;                                                                  // 0x00B8 (size: 0x10)
    float AverageBrightness;                                                          // 0x00C8 (size: 0x4)

}; // Size: 0x170

struct FSmartNameMapping
{
}; // Size: 0x70

struct FCurveMetaData
{
}; // Size: 0x18

struct FSoundClassEditorData
{
}; // Size: 0x8

struct FSoundNodeEditorData
{
}; // Size: 0x8

struct FStreamedAudioPlatformData
{
}; // Size: 0x20

struct FSplineInstanceData : public FSceneComponentInstanceData
{
    bool bSplineHasBeenEdited;                                                        // 0x00B8 (size: 0x1)
    FSplineCurves SplineCurves;                                                       // 0x00C0 (size: 0x70)
    FSplineCurves SplineCurvesPreUCS;                                                 // 0x0130 (size: 0x70)

}; // Size: 0x1A0

struct FSplineMeshInstanceData : public FSceneComponentInstanceData
{
    FVector StartPos;                                                                 // 0x00B8 (size: 0xC)
    FVector EndPos;                                                                   // 0x00C4 (size: 0xC)
    FVector StartTangent;                                                             // 0x00D0 (size: 0xC)
    FVector EndTangent;                                                               // 0x00DC (size: 0xC)

}; // Size: 0xE8

struct FMaterialRemapIndex
{
    uint32 ImportVersionKey;                                                          // 0x0000 (size: 0x4)
    TArray<int32> MaterialRemap;                                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAssetEditorOrbitCameraPosition
{
    bool bIsSet;                                                                      // 0x0000 (size: 0x1)
    FVector CamOrbitPoint;                                                            // 0x0004 (size: 0xC)
    FVector CamOrbitZoom;                                                             // 0x0010 (size: 0xC)
    FRotator CamOrbitRotation;                                                        // 0x001C (size: 0xC)

}; // Size: 0x28

struct FMeshSectionInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    bool bEnableCollision;                                                            // 0x0004 (size: 0x1)
    bool bCastShadow;                                                                 // 0x0005 (size: 0x1)
    bool bVisibleInRayTracing;                                                        // 0x0006 (size: 0x1)
    bool bForceOpaque;                                                                // 0x0007 (size: 0x1)

}; // Size: 0x8

struct FMeshSectionInfoMap
{
    TMap<uint32, FMeshSectionInfo> Map;                                               // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FStaticMeshSourceModel
{
    FMeshBuildSettings BuildSettings;                                                 // 0x0000 (size: 0x30)
    FMeshReductionSettings ReductionSettings;                                         // 0x0030 (size: 0x24)
    float LODDistance;                                                                // 0x0054 (size: 0x4)
    FPerPlatformFloat ScreenSize;                                                     // 0x0058 (size: 0x4)
    FString SourceImportFilename;                                                     // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FStaticMeshOptimizationSettings
{
    TEnumAsByte<EOptimizationType> ReductionMethod;                                   // 0x0000 (size: 0x1)
    float NumOfTrianglesPercentage;                                                   // 0x0004 (size: 0x4)
    float MaxDeviationPercentage;                                                     // 0x0008 (size: 0x4)
    float WeldingThreshold;                                                           // 0x000C (size: 0x4)
    bool bRecalcNormals;                                                              // 0x0010 (size: 0x1)
    float NormalsThreshold;                                                           // 0x0014 (size: 0x4)
    uint8 SilhouetteImportance;                                                       // 0x0018 (size: 0x1)
    uint8 TextureImportance;                                                          // 0x0019 (size: 0x1)
    uint8 ShadingImportance;                                                          // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FPaintedVertex
{
    FVector Position;                                                                 // 0x0000 (size: 0xC)
    FColor Color;                                                                     // 0x000C (size: 0x4)
    FVector4 Normal;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FStaticMeshVertexColorLODData
{
    TArray<FPaintedVertex> PaintedVertices;                                           // 0x0000 (size: 0x10)
    TArray<FColor> VertexBufferColors;                                                // 0x0010 (size: 0x10)
    uint32 LODIndex;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FStaticMeshComponentInstanceData : public FPrimitiveComponentInstanceData
{
    class UStaticMesh* StaticMesh;                                                    // 0x0100 (size: 0x8)
    TArray<FStaticMeshVertexColorLODData> VertexColorLODs;                            // 0x0108 (size: 0x10)
    TArray<FGuid> CachedStaticLighting;                                               // 0x0118 (size: 0x10)
    TArray<FStreamingTextureBuildInfo> StreamingTextureData;                          // 0x0128 (size: 0x10)

}; // Size: 0x140

struct FTextureFormatSettings
{
    TEnumAsByte<TextureCompressionSettings> CompressionSettings;                      // 0x0000 (size: 0x1)
    uint8 CompressionNoAlpha;                                                         // 0x0001 (size: 0x1)
    uint8 CompressionNone;                                                            // 0x0001 (size: 0x1)
    uint8 CompressionYCoCg;                                                           // 0x0001 (size: 0x1)
    uint8 sRGB;                                                                       // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FTexturePlatformData
{
}; // Size: 0x30

struct FTextureSource
{
}; // Size: 0x38

struct FTextureSourceBlock
{
    int32 BlockX;                                                                     // 0x0000 (size: 0x4)
    int32 BlockY;                                                                     // 0x0004 (size: 0x4)
    int32 SizeX;                                                                      // 0x0008 (size: 0x4)
    int32 SizeY;                                                                      // 0x000C (size: 0x4)
    int32 NumSlices;                                                                  // 0x0010 (size: 0x4)
    int32 NumMips;                                                                    // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FStreamingRenderAssetPrimitiveInfo
{
    class UStreamableRenderAsset* RenderAsset;                                        // 0x0000 (size: 0x8)
    FBoxSphereBounds Bounds;                                                          // 0x0008 (size: 0x1C)
    float TexelFactor;                                                                // 0x0024 (size: 0x4)
    uint32 PackedRelativeBox;                                                         // 0x0028 (size: 0x4)
    uint8 bAllowInvalidTexelFactorWhenUnregistered;                                   // 0x002C (size: 0x1)

}; // Size: 0x30

struct FTTTrackId
{
    int32 TrackType;                                                                  // 0x0000 (size: 0x4)
    int32 TrackIndex;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTimeStretchCurveInstance
{
    bool bHasValidData;                                                               // 0x0000 (size: 0x1)

}; // Size: 0x30

struct FEndPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FStartPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FLevelViewportInfo
{
    FVector CamPosition;                                                              // 0x0000 (size: 0xC)
    FRotator CamRotation;                                                             // 0x000C (size: 0xC)
    float CamOrthoZoom;                                                               // 0x0018 (size: 0x4)
    bool CamUpdated;                                                                  // 0x001C (size: 0x1)

}; // Size: 0x20

struct FLightmassWorldInfoSettings
{
    float StaticLightingLevelScale;                                                   // 0x0000 (size: 0x4)
    int32 NumIndirectLightingBounces;                                                 // 0x0004 (size: 0x4)
    int32 NumSkyLightingBounces;                                                      // 0x0008 (size: 0x4)
    float IndirectLightingQuality;                                                    // 0x000C (size: 0x4)
    float IndirectLightingSmoothness;                                                 // 0x0010 (size: 0x4)
    FColor EnvironmentColor;                                                          // 0x0014 (size: 0x4)
    float EnvironmentIntensity;                                                       // 0x0018 (size: 0x4)
    float EmissiveBoost;                                                              // 0x001C (size: 0x4)
    float DiffuseBoost;                                                               // 0x0020 (size: 0x4)
    TEnumAsByte<EVolumeLightingMethod> VolumeLightingMethod;                          // 0x0024 (size: 0x1)
    uint8 bUseAmbientOcclusion;                                                       // 0x0025 (size: 0x1)
    uint8 bGenerateAmbientOcclusionMaterialMask;                                      // 0x0025 (size: 0x1)
    uint8 bVisualizeMaterialDiffuse;                                                  // 0x0025 (size: 0x1)
    uint8 bVisualizeAmbientOcclusion;                                                 // 0x0025 (size: 0x1)
    uint8 bCompressLightmaps;                                                         // 0x0025 (size: 0x1)
    float VolumetricLightmapDetailCellSize;                                           // 0x0028 (size: 0x4)
    float VolumetricLightmapMaximumBrickMemoryMb;                                     // 0x002C (size: 0x4)
    float VolumetricLightmapSphericalHarmonicSmoothing;                               // 0x0030 (size: 0x4)
    float VolumeLightSamplePlacementScale;                                            // 0x0034 (size: 0x4)
    float DirectIlluminationOcclusionFraction;                                        // 0x0038 (size: 0x4)
    float IndirectIlluminationOcclusionFraction;                                      // 0x003C (size: 0x4)
    float OcclusionExponent;                                                          // 0x0040 (size: 0x4)
    float FullyOccludedSamplesFraction;                                               // 0x0044 (size: 0x4)
    float MaxOcclusionDistance;                                                       // 0x0048 (size: 0x4)

}; // Size: 0x4C

class UDefault__BlueprintGeneratedClass
{
}; // Size: 0x0

class UDefault__AnimBlueprintGeneratedClass
{
}; // Size: 0x0

struct FDefault__UserDefinedStruct
{
}; // Size: 0x0

#endif
